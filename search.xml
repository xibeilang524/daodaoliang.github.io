<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[梦想清单]]></title>
    <url>%2F%E5%BF%83%E4%B8%96%E7%95%8C%2F2099%2F04%2F14%2F%E6%96%B0%E4%B8%96%E7%95%8C-2015-04-14-%E6%A2%A6%E6%83%B3%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[target = ‘日日当精进 但求无愧’target = ‘just do it’ 完成自己制定的读书计划，按照书单列表进行阅读； 长途骑行一次； 拥有六块腹肌和匀称的身材； 参加一次马拉松比赛； 每天坚持锻炼(在生活轨迹里面打卡吧，这里就不占地方了)； 去心仪的大学读书深造； 拥有自己的工作室；]]></content>
      <categories>
        <category>心世界</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CentOS6升级GCC版本]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2017%2F04%2F20%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2017-04-20-CentOS6%E5%8D%87%E7%BA%A7GCC%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[123作者 : daodaoliang@yeah.net日期 : 2017-04-20版本 : 0.0.1 [TOC] 1. 背景简述CentOS 6系列的服务器,默认的gcc编译器都是 4.4.7 版本,有事后为了开发或者编译其他开源软件，则需要对gcc编译器进行升级; 2. 安装GCC前准备2.1 下载指定版本首先在官网上面下载你需要的GCC版本,官网在这里,笔者选择的是GCC 4.8.4版本; 12cd /usr/local/src wget http://ftp.gnu.org/gnu/gcc/gcc-4.8.4/gcc-4.8.4.tar.gz 2.2 解压并进行准备工作1tar zxvf gcc-4.8.4.tar.gz 2.3 下载供编译需求的依赖项1/usr/local/src/gcc-4.8.4/contrib/download_prerequisites 3. 开始安装1234cd /usr/local/src/gcc-4.8.4 mkdir gcc-build cd gcc-build ../configure -enable-checking=release -enable-languages=c,c++ -disable-multilib 1make -j4 1sudo make install 4. 配置环境12cp /usr/local/lib64/libstdc++* /usr/lib64/ ln -s /usr/lib64/libstdc++.so /usr/lib64/libstdc++.so.6.0.19]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CentOS下Nexus搭建Maven私库]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2017%2F04%2F20%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2017-04-20-CentOS%E4%B8%8BNexus%E6%90%AD%E5%BB%BAMaven%E7%A7%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[123作者 : daodaoliang@yeah.net日期 : 2017-04-20版本 : 0.0.4 [TOC] 1. Maven私服简介搭建私服可以做什么？1、如果公司开发组的开发环境全部内网，这时如何连接到在互联网上的Maven中央仓库呢？2、如果公司经常开发一些公共的组件，如何共享给各个开发组，使用拷贝方式吗？如果这样，公共库升级了怎么办？当然可以解决的问题可能不止上面两点，下面来介绍在CentOS中搭建自己的Maven私服，使用Nexus。 2. java 运行环境准备根据官网的介绍，运行环境最好是使用最新的8版本，官网文如下: 12Nexus Repository Manager requires a Java 8 Runtime Environment (JRE) from Oracle. The distributions for OSX and Windows include suitable runtime environments for the specific operating system. The distributions for Unix do not include the runtime environment.If you prefer to use an external runtime or use a Unix operating system, it is recommended to use the latest version of Java 8 available from the Oracle website. You can choose to install the full JDK or the JRE only. 2.1 本地java版本确认如果系统是新安装的并且没有进行相关配置的话，默认应该是openJDK1.7版本; 2.2 安装新的JDK 由于原有系统很多包都是依赖与JDK，以防万一，我就没有卸载原有的JDK而是在安装一个8版本的JDK; 在JDK官网找到对应的rpm包进行下载并安装,建议本机迅雷下载完成后再传到服务器,也可以找一些速度快的镜像站进行下载; 下载完后直接安装，然后查看对应的版本信息是否正确; 顺手改一下JAVA_HOME的环境变量; 3. 安装 Nexus3.1 下载Nexus 从官网下载对应的安装包到服务器 PS：建议在本机用迅雷下载完了在传上去，或者用一些快一点镜像站； 1wget https://www.sonatype.com/oss-thank-you-tar.gz 3.2 安装 Nexus 解压安装包 1tar zxvf oss-thank-you-tar.gz 安装成服务 1mv ./nexus-3.1.1-X86_64/ /usr/local/nexus3 增加环境变量NEXUS_HOME 创建并开启服务 12345sudo ln -s $NEXUS_HOME/bin/nexus /etc/init.d/nexus cd /etc/init.d sudo chkconfig --add nexus sudo chkconfig --levels 345 nexus on sudo service nexus start 4. 配置 Nexus4.1 配置WEB 访问 开启 8081 端口 1vim /etc/sysconfig/iptables 增加如下一条: 浏览器访问 在浏览器中打开对应的URL 例如: http://10.140.22.205:8081,默认管理员用户名和密码如下: 12user: admin pwd: admin123 默认nexus已经帮我们创建了五个库和两个组,我们可以直接使用,其中Type为prosy的为代理库,Type为hosted的为宿主库,Type为group的为组; 一般用到的仓库种类是hosted、proxy。Hosted代表宿主仓库，用来发布一些第三方不允许的组件，比如Oracle驱动、比如商业软件jar包。Proxy代表代理远程的仓库，最典型的就是Maven官方中央仓库、JBoss仓库等等。如果构建的Maven项目本地仓库没有依赖包，那么就会去这个代理站点去下载，那么如果代理站点也没有此依赖包，就回去远程中央仓库下载依赖，这些中央仓库就是proxy。代理站点下载成功后再下载至本机。 4.2 本地项目配置在项目的pom.xml或者settings.xml文件里加入一下配置信息（区别，pom.xml是针对当前项目，settings.xml是全局的针对所有项目）配置信息中的id,name和url跟上图中的仓库对应，type为proxy，说明它只是代理，只能用于下载jar包，不能用于发布项目。 123456789101112131415&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;maven-central&lt;/id&gt; &lt;name&gt;maven-central&lt;/name&gt; &lt;url&gt;http://10.140.22.205:8081/repository/maven-central/&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshotPolicy&gt;always&lt;/snapshotPolicy&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt; 其他使用可以参考这里]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CentOS6.8下安装Maven]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2017%2F04%2F14%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2017-04-14-CentOS6-8%E4%B8%8B%E5%AE%89%E8%A3%85Maven%2F</url>
    <content type="text"><![CDATA[123作者 : daodaoliang@yeah.net日期 : 2017-04-13版本 : 0.0.4 [TOC] 0. 安装Maven前准备 确保系统已经安装了Java的运行环境; 12# 查看java版本，确保已经安装了javajava -version 终端输出如下内容说明已经安装了java，并且为 openJDK 系列的 1.7.0_131 版本 1234[root@yafan2-xb src]# java -versionjava version &quot;1.7.0_131&quot;OpenJDK Runtime Environment (rhel-2.6.9.0.el6_8-x86_64 u131-b00)OpenJDK 64-Bit Server VM (build 24.131-b00, mixed mode) 确保系统已经配置了JAVA_HOME系统环境变量; 123env | grep JAVA_HOME 或者 echo $JAVA_HOME 若是终端没有输出对应的值，则说明系统是没有配置JAVA_HOME环境变量的; 12345678# 查找 java 路径, 笔者电脑输出 /usr/bin/javawhich java # 查找 java 的真实路径 笔者电脑输出 /usr/bin/java -&gt; /etc/alternatives/java ls -alh /usr/bin/java # 继续查找 java 的真实路径 笔者电脑输出 /etc/alternatives/java -&gt; /usr/lib/jvm/jre-1.7.0-openjdk.x86_64/bin/java ls -alh /etc/alternatives/java 经过上一步找到了 java 的在当前系统中的真实可执行目录，按照如下方式配置环境变量 1vim /etc/profile 添加 123export JAVA_HOME=/usr/lib/jvm/jre-1.7.0-openjdk.x86_64export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin 使新的环境变量生效 1source /etc/profile 1.安装maven环境 下载maven二进制包 maven的官方下载地址在这里 。 PS: 建议在下载时选择一个比较快的源,笔者选择的是清华大学的源,下载速度在 400K左右; 12cd /usr/local/src wget http://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.5.0/binaries/apache-maven-3.5.0-bin.tar.gz 解压并配置 12tar zxf apache-maven-3.5.0-bin.tar.gzmv apache-maven-3.5.0 /usr/local/maven3 配置环境变量(/etc/profile) 123#在适当的位置添加export M2_HOME=/usr/local/maven3export PATH=$PATH:$JAVA_HOME/bin:$M2_HOME/bin 使环境变量生效 1source /etc/profile 验证版本 1mvn -v]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CentOS下搭建GitLab服务器]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2017%2F04%2F13%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2014-10-17-Ubuntu14-04%E4%B8%8B%E9%85%8D%E7%BD%AEGitLab7%2F</url>
    <content type="text"><![CDATA[123作者 : daodaoliang@yeah.net日期 : 2017-04-13版本 : 0.0.4 TOC{:toc} 0 Gitlab 简介GitLab 是一个用于仓库管理系统的开源项目。使用Git作为代码管理工具，并在此基础上搭建起来的web服务。可通过Web界面进行访问公开的或者私人项目。它拥有与Github类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序(Wall)进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用。 1. Gitlab 的安装Gitlab 有两种安装方式: 安装方式 简介 源码方式安装 这个有些费劲,时间充足喜欢折腾按照链接文档安装即可 Omnibus方式安装 这个简单,不出任何意外大约一个半小时左右安装完毕 1.1 采用 Omnibus 方式根据官网地址，选择 CentOS 6 然后执行相应命令，即可完成安装操作，如果你用虚拟机，就直接用迅雷搞定，然后再拖进去吧，毕竟200+M,下载连接在这里 如果你不想观看官网那么跟着下面步骤走： 1.1.1 安装配置依赖项如想使用Postfix来发送邮件,在安装期间请选择’Internet Site’. 您也可以用sendmai或者 配置SMTP服务 并 使用SMTP发送邮件.在 Centos 6 和 7 系统上, 下面的命令将在系统防火墙里面开放HTTP和SSH端口. 1234sudo yum install curl openssh-server openssh-clients postfix croniesudo service postfix startsudo chkconfig postfix onsudo lokkit -s http -s ssh 1.1.2 添加GitLab仓库,并安装到服务器上12curl -sS http://packages.gitlab.cc/install/gitlab-ce/script.rpm.sh | sudo bashsudo yum install gitlab-ce 1.1.3 启动 Gitlab1sudo gitlab-ctl reconfigure 2.邮箱配置当你按照提示安装好后，基本上就可以使用了，但是在使用的过程中，我们发现邮件通知功能不稳定，使用 1sudo vi /var/log/mail.log 查看后发现，邮件被当成了垃圾邮件，被退信了。使用默认Gitlab的邮件服务的话，貌似被退信的几率比较高，因此我们需修改一下，毕竟邮件通知还是很重要的。我们注册一个邮箱账号，让GitLab通过该账号向我们发送邮件通知，这看起来就像两个人正常通信了，基本上就不会被退信了。 2.1 注册邮箱注册QQ企业云邮箱不解释，记住用户名密码即可，你也可以随便使用其他邮箱服务器，不过不建议网易家的，他们会出现一些安全方面的拦截。 2.2 配置邮箱修改发送邮件步骤如下： 1sudo vi /etc/gitlab/gitlab.rb 增加如下配置项，例: 123456789gitlab_rails['smtp_enable'] = truegitlab_rails['smtp_address'] = "smtp.exmail.qq.com"gitlab_rails['smtp_port'] = 465gitlab_rails['smtp_user_name'] = "youraccount"gitlab_rails['smtp_password'] = "yourPWD"gitlab_rails['smtp_authentication'] = "login"gitlab_rails['smtp_enable_starttls_auto'] = truegitlab_rails['smtp_tls'] = truegitlab_rails['gitlab_email_from'] = 'youraccount' 修改完成后，需要执行以下命令使生效: 1gitlab-ctl reconfigure. 2.3 测试邮箱 执行 gitlab-rails console 在上面步骤后执行： 1Notify.test_email('destination_email@address.com', 'Message Subject', 'Message Body').deliver_now PS: 具体其他的请参考这篇文档 4. Gitlab 运维具体运维请参考这篇文档 4.1 管理12345678# 启动所有 gitlab 组件：sudo gitlab-ctl start# 停止所有 gitlab 组件：sudo gitlab-ctl stop# 重启所有 gitlab 组件：sudo gitlab-ctl restart 4.2 备份备份GitLab repositories and GitLab metadata 在 crontab 中加入如下命令： 10 2 * * * /usr/bin/gitlab-rake gitlab:backup:create 4.3 恢复首先进入备份 gitlab 的目录，这个目录是配置文件中的gitlab_rails[&#39;backup_path&#39;] ，默认为 /var/opt/gitlab/backups 。 然后停止 unicorn 和 sidekiq ，保证数据库没有新的连接，不会有写数据情况。 1234sudo gitlab-ctl stop unicorn# ok: down: unicorn: 0s, normally upsudo gitlab-ctl stop sidekiq# ok: down: sidekiq: 0s, normally up 然后恢复数据，1406691018为备份文件的时间戳 1gitlab-rake gitlab:backup:restore BACKUP=1406691018]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windows下服务程序相关]]></title>
    <url>%2Funcategorized%2F2017%2F04%2F12%2Fwindows%E5%AD%A6%E4%B9%A0-2017-04-12-windows%E4%B8%8B%E9%9D%A2%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[作者: daodaoliang 版本: V 0.0.1 日期: 2017年11月25日 1. Windows Service 编程实现在windows平台下面编写 服务程序 免不了要去查看微软的开发者文档，相关的介绍在这里, 多了也就不在罗嗦了,如果你嫌弃直接用他们的API的话,可以使用别人已经封装好的，比如: 参考代码 连接 参考代码001 https://github.com/magicsih/WindowsService 参考代码002 https://github.com/Olster/windows_service 参考代码003 https://github.com/Kingston1/windows-service 参考代码004 https://github.com/horigome/sylph 2. 采用第三方封装的SCP2.1 nssm (Non-Sucking Service Manager) 编译或者下载nssm 下载连接在这里,一定要注意系统位数的区别，32位和64位; 使用方式]]></content>
  </entry>
  <entry>
    <title><![CDATA[windows脚本UAC获取]]></title>
    <url>%2Fwindows%E5%AD%A6%E4%B9%A0%2F2017%2F04%2F12%2Fwindows%E5%AD%A6%E4%B9%A0-2017-04-12-windowsUAC%2F</url>
    <content type="text"><![CDATA[1234auther = 'daodaoliang'version = 'V 0.0.1'date = '2017年04月12日' 常用的windows下面的脚本，首先判断用户的管理员权限，而后进行sc的服务操作; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061echo offcls:-------------------------------------REM --&gt; Check for permissions&gt;nul 2&gt;&amp;1 "%SYSTEMROOT%\system32\cacls.exe" "%SYSTEMROOT%\system32\config\system"REM --&gt; If error flag set, we do not have admin.if '%errorlevel%' NEQ '0' ( echo Requesting administrative privileges... goto UACPrompt) else ( goto gotAdmin ):UACPrompt echo Set UAC = CreateObject^("Shell.Application"^) &gt; "%temp%\getadmin.vbs" set params = %*:"="" echo UAC.ShellExecute "cmd.exe", "/c %~s0 %params%", "", "runas", 1 &gt;&gt; "%temp%\getadmin.vbs" "%temp%\getadmin.vbs" del "%temp%\getadmin.vbs" exit /B:gotAdmin pushd "%CD%" CD /D "%~dp0":--------------------------------------echo --- Logger Service Installer ---set /p servicename=Service name :echo Options:echo 1. Installecho 2. Startecho 3. Stop echo 4. Removeecho 5. Exit:CASE_initSET /P option="Option: "2&gt;NUL CALL :CASE_%option% # jump to :CASE_1, :CASE_2, CASE_3, CASE_4, CASE_5IF ERRORLEVEL 1 CALL :DEFAULT_CASE # if label doesn't existECHO Done.EXIT /B:CASE_1sc create %servicename% binPath= "yourpath/app.exe"GOTO CASE_init:CASE_2sc start %servicename%GOTO CASE_init:CASE_3sc stop %servicename%GOTO CASE_init:CASE_4sc delete %servicename%GOTO CASE_init:CASE_5GOTO END_CASE:DEFAULT_CASEECHO Unknown option %option%GOTO CASE_init:END_CASEpause]]></content>
      <categories>
        <category>windows学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[最为常用的HASH算法]]></title>
    <url>%2Fc-%E5%AD%A6%E4%B9%A0%2F2017%2F03%2F08%2Fc-%E5%AD%A6%E4%B9%A0-2017-03-08-HashAlgorithm%2F</url>
    <content type="text"><![CDATA[作者: daodaoliang 版本: V 0.0.1 日期: 2017年03月08日 murmurhash2算法 和 DJB Hash算法是目前最流行的hash算法 1.DJB HASH算法1234567891011/* the famous DJB Hash Function for strings */unsigned int DJBHash(char *str)&#123; unsigned int hash = 5381; while (*str)&#123; hash = ((hash &lt;&lt; 5) + hash) + (*str++); /* times 33 */ &#125; hash &amp;= ~(1 &lt;&lt; 31); /* strip the highest bit */ return hash; &#125; 2.murmurhash212345678910111213141516171819202122232425262728293031323334353637383940uint32_tmurmur_hash2(char *data, size_t len)&#123; uint32_t h, k; h = 0 ^ len; while (len &gt;= 4) &#123; k = data[0]; k |= data[1] &lt;&lt; 8; k |= data[2] &lt;&lt; 16; k |= data[3] &lt;&lt; 24; k *= 0x5bd1e995; k ^= k &gt;&gt; 24; k *= 0x5bd1e995; h *= 0x5bd1e995; h ^= k; data += 4; len -= 4; &#125; switch (len) &#123; case 3: h ^= data[2] &lt;&lt; 16; case 2: h ^= data[1] &lt;&lt; 8; case 1: h ^= data[0]; h *= 0x5bd1e995; &#125; h ^= h &gt;&gt; 13; h *= 0x5bd1e995; h ^= h &gt;&gt; 15; return h;&#125;]]></content>
      <categories>
        <category>c++学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CentOS6.5下升级NodeJs]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2017%2F02%2F17%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2017-02-17-CentOS%E4%B8%8B%E5%8D%87%E7%BA%A7NodeJs%2F</url>
    <content type="text"><![CDATA[作者: daodaoliang 版本: V 1.0.1 邮箱：daodaoliang@yeah.net NodeJs 是什么就不在赘述，可一直接参考英文官网，或者中文官网，在项目中进行应用时，有时候需要用到最新版本的特性，但是CentOS系统为了稳定性，默认的源都是在该版本的操作系统发布时或者更新时的最稳定版本，所以仅仅是采用yum update 的操作是不能进行对应升级的。 所以下面采用两种方式来进行在线升级。 0x01 用 n 模块来进行 nodejs 升级 在 NodeJs 中有一个模块叫做 n 专门用来管理 NodeJs 的版本。 首先下载安装模块 n 1npm install -g n 升级NodeJs到最新版本 1n stable 升级NodeJs到指定版本 1n 0.10.23 0x04 用编译好的二进制文件进行安装更新 在官网下载相关系统平台下面编译好的二进制包。 123cd node-v0.10.28-linux-x64/binls./node -v 上面的二进制文件就是编译好的新版本的node文件，不过并没有添加到环境变量里面，所以可以通过下面这种方式进行设置为全局变量 12ln -s /home/kun/mysofltware/node-v0.10.28-linux-x64/bin/node /usr/local/bin/nodeln -s /home/kun/mysofltware/node-v0.10.28-linux-x64/bin/npm /usr/local/bin/npm 0x03 用源码的方式进行编译安装一般用方式一就可以完成升级安装，但是有时候会出现一些莫名其妙的错误，比如说是segment fault之类的错误，这个时候我只能用源码的方式进行编译安装。 首先NodeJs使用C++语言编写的，所以在编译源码时需要用到gcc-g++编译器，目前最新的NodeJs代码用到了c11的一些特性，所以对编译器的版本要求在4.8+所以首先要对编译器进行安装和升级。 安装并升级编译器到4.8+ 1234yum install gcc-c++ openssl-develwget http://people.centos.org/tru/devtools-2/devtools-2.repomv devtools-2.repo /etc/yum.repos.dyum install devtoolset-2-gcc devtoolset-2-binutils devtoolset-2-gcc-c++ 三个安装包被安装在/opt/rh/devtoolset-2/root/中 更新软连接: 1234567mv /usr/bin/gcc /usr/bin/gcc-4.4.7 mv /usr/bin/g++ /usr/bin/g++-4.4.7 mv /usr/bin/c++ /usr/bin/c++-4.4.7 ln -s /opt/rh/devtoolset-2/root/usr/bin/gcc /usr/bin/gcc ln -s /opt/rh/devtoolset-2/root/usr/bin/c++ /usr/bin/c++ ln -s /opt/rh/devtoolset-2/root/usr/bin/g++ /usr/bin/g++ gcc --version 检查核对python版本 nodejs需要python版本在2.6版本以上，我们需要检查版本是否对应符合，如果不符合那就进行一下升级； 编译安装最新版本的nodejs 123456cd /usr/local/srcwget http://nodejs.org/dist/node-latest.tar.gztar -zxvf node-latest.tar.gzcd node-v0.12.7./configuremake &amp;&amp; make install 不管是用哪种方式进行升级都需要很长的时间，休息一会等着就好了，升级完成后查看一下版本信息； 1node -v PS: 在升级的过程中把node 运行的相关程序要关闭，不然会在编译时由于文件占用的关系产生错误.]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux内核漫画(转载)]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2017%2F02%2F06%2Flinux%E5%AD%A6%E4%B9%A0-2017-02-06-linux%E5%86%85%E6%A0%B8%E6%BC%AB%E7%94%BB%2F</url>
    <content type="text"><![CDATA[作者: daodaoliang 版本: V 0.0.1 日期: 2017年02月06日 网络上看到的觉得很形象就转载过来啦，伟大的Linux内核漫画化。]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux下C++的编译过程]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2017%2F02%2F01%2Fc-%E5%AD%A6%E4%B9%A0-2017-02-14-linux%E4%B8%8BC-%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[作者: daodaoliang 版本: V 0.0.1 日期: 2017年02月01日 在linux下面c++程序从源码变成用户触手可用的可执行程序通常分为配置、编译和安装，具体的过程和描述如下. 0x01 配置阶段(Configure) 一个生产环境的系统一般都是需要调用一些系统提供的功能库和一些其他功能库，由于系统环境的不同编译器需要知道系统库存在哪里，软件编译完成后安装在哪里，需要安装那些第三方组件等等，同时工程项目的文件也存在相互的引用和依赖关系，所有这些都需要在configure阶段解决。配置阶段完成以后会产生makefile文件。 0x02 编译阶段(Make) 编译阶段的就是把程序工程文件从人类可读经过处理后变成机器可执行的二进制指令码的过程，对于linux 下面 gcc 编译器来说一般是预处理、编译、汇编和链接。 0x021 预处理(Preprocessing) 预处理后的文件一般为.i结尾，这个过程一般包含以下几个子过程: 展开宏定义，删除所有#define； 处理所有的条件预编译指令，#if #ifdef #elif #else #endif 等； 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置； 删除所有的注释； 添加行号和文件标识，以便在编译时产生调试用的行号，以及编译错误的警告行号； 保留所有的#pragma 编译器指令，在编译阶段编译器需要使用； 通常如果只进行预处理的话一般用如下命令: 1gcc -E hello.c -o hello.i 0x022 编译(Compilation) 编译的过程就是把工程文件进行一系列的词法分析、语法分析、语义分析、以及优化后生成相关的汇编代码； 通常如果只进行编译处理的一般用如下命令: 1gcc -S hello.i -o hello.s 0x023 汇编(Assembly)汇编器是将汇编代码转换成机器码 1gcc -c hello.c -o hello.o 或者 1as hello.s -o hello.o 0x024 连接(Linking)链接的主要作用就是把各个二进制中间文件链接起来生成一个可执行的二进制文件，链接分为动态链接和静态连接: 动态链接：链接阶段仅仅加入一些描述信息，而程序执行时再从系统中把相应的动态库加载到内存中。 0x03 安装阶段(make install)编译的整个过程都是在内存中进行，编译出来的二进制可执行文件也是存在编译时指定的位置，下一步就是将可执行文件安装到用户指定目录并做好善后工作，这其中包含，创建对应的目录，保存文件，设置权限等步骤；同时程序安装完成后也需要还需要进行操作系统的关联，创建快捷方式和做文件关联等等个性化需求。]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh超时时间设置]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2016%2F12%2F29%2Flinux%E5%AD%A6%E4%B9%A0-2016-12-29-ssh%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[作者: daodaoliang 版本: V 0.0.1 日期: 2016年12月29日 0x00 OpenSSH 简介OpenSSH是采用SSH协议实现的重要的远程连接工具，它对所有的数据进行加密以防止被中途窃听，OpenSSH提供了大量的安全通道的组件，比如： 远程操作用ssh、scp、sftp; 秘钥管理用ssh-add、ssh-keysign、ssh-keyscan、ssh-keygen; 服务端包含sshd、sftp-server、ssh-agent; 0x01 方案一上面的所有信息可以自行去对应官网链接进行进一步的学习，在下面只讨论对于sshd的超时连接的问题。 修改server端的配置文件/etc/ssh/sshd_config 12345# server每隔60秒给客户端发送一次保活信息包给客户端ClientAliveInterval 60# server端发出的请求客户端没有回应的次数达到86400次的时候就断开连接，正常情况下客户端都会相应ClientAliveCountMax 86400 修改client端的配置文件/etc/ssh/ssh_config 12345# client 每隔60秒给客户端发送一次保活信息包给客户端ServerAliveInterval 60# client 端发出的请求服务端没有回应的次数达到86400次的时候就断开连接，正常情况下服务端都会相应ServerAliveCountMax 86400 0x02 方案二在命令参数里 12ssh -o ServerAliveInterval=60 这样子只会在需要的连接中保持持久连接，具体的参数请参考这里。]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windows下获取系统信息VBS脚本]]></title>
    <url>%2Fwindows%E5%AD%A6%E4%B9%A0%2F2016%2F11%2F25%2Fwindows%E5%AD%A6%E4%B9%A0-2016-11-25-windows%E4%B8%8B%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AFVBS%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[作者: daodaoliang 版本: V 0.0.1 日期: 2016年11月25日 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999'********************************************************************'* *'* Begin of File *'* *'*******************************************************************On Error Resume NextConst forwriting=2Const forreading=1Dim oFSO,oF,eventlogText = "此脚本运行不会对您的系统造成任何损害或恶意行为" &amp;VbCrLf&amp;vbCrlf&amp; "通过连接WMI提供的公共接口枚举系统相关信息"&amp;VbCrLf&amp;VbCrLf&amp; "按确定键运行30秒左右会生成html格式报告"Title_Text = "bkReport Version 2.2"MsgBox Text,vbExclamation+vbSystemModal,Title_TextdtmStart = Now()strComputer = "."Set oShell = WScript.CreateObject("WScript.Shell")hostname=oShell.ExpandEnvironmentStrings("%computername%")MainReport=hostname&amp;"_Report.html"EventReport=hostname&amp;"_EventLog.html"datec=Now()Set oFSO = CreateObject("Scripting.FileSystemObject")Set oF = oFSO.CreateTextFile(MainReport)Set eventlog=oFSO.CreateTextFile(EventReport)strComputer = "."Set objWMIService = GetObject("winmgmts:\\" &amp; strComputer &amp; "\root\cimv2")Set colComputers = objWMIService.ExecQuery _ ("Select * from Win32_ComputerSystem")For Each objComputer in colComputers Select Case objComputer.DomainRole Case "0" machine= "独立工作站" Case "1" machine= "成员工作站" Case "2" machine= "独立服务器" Case "3" machine= "成员服务器" Case "4" machine= "备份服务器" Case "5" machine= "主域控制器" End SelectNextoF.WriteLine "&lt;html&gt;"oF.WriteLine "&lt;head&gt;&lt;title&gt;MainReport Build by bkReport.vbs&lt;/title&gt;&lt;/head&gt;"oF.Writeline "&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;"oF.WriteLine "&lt;h2&gt;&lt;font color=MidnightBlue&gt;&lt;center&gt;"&amp;hostname&amp;"@"&amp;machine&amp;" 快照信息 &lt;/center&gt;&lt;/font&gt;&lt;/h2&gt;"oF.WriteLine "&lt;p align=right&gt;&lt;font size=2&gt;date: " &amp; Now()&amp;"&lt;/font&gt;&lt;/p&gt;"oF.Writeline "&lt;hr width=80% color=#ff8000&gt;"oF.Writeline "&lt;p&gt;&amp;nbsp;&lt;/p&gt;"oF.WriteLine "&lt;OL&gt;&lt;LI&gt;&lt;a href=#here1&gt;系统摘要&lt;/a&gt;"oF.WriteLine "&lt;LI&gt;&lt;a href=#here2&gt;BIOS信息&lt;/a&gt;"oF.WriteLine "&lt;LI&gt;&lt;a href=#here3&gt;环境变量&lt;/a&gt;"oF.WriteLine "&lt;LI&gt;&lt;a href=#here4&gt;系统文件内容&lt;/a&gt;"oF.WriteLine "&lt;LI&gt;&lt;a href=#here5&gt;网络状态&lt;/a&gt;"oF.WriteLine "&lt;LI&gt;&lt;a href=#here6&gt;磁盘和共享&lt;/a&gt;"oF.WriteLine "&lt;LI&gt;&lt;a href=#here7&gt;进程&lt;/a&gt;"oF.WriteLine "&lt;LI&gt;&lt;a href=#here8&gt;进程ID对应的启动服务&lt;/a&gt;"oF.WriteLine "&lt;LI&gt;&lt;a href=#here9&gt;服务&lt;/a&gt;"oF.WriteLine "&lt;LI&gt;&lt;a href=#here10&gt;补丁&lt;/a&gt;"oF.WriteLine "&lt;LI&gt;&lt;a href=#here11&gt;软件&lt;/a&gt;"oF.WriteLine "&lt;LI&gt;&lt;a href=#here12&gt;帐号&lt;/a&gt;"oF.WriteLine "&lt;LI&gt;&lt;a href=#here13&gt;AT创建的计划任务&lt;/a&gt;"oF.WriteLine "&lt;LI&gt;&lt;a href=#here14&gt;重要文件属性&lt;/a&gt;"oF.WriteLine "&lt;LI&gt;&lt;a href=#here15&gt;自启动项&lt;/a&gt;"oF.WriteLine "&lt;LI&gt;&lt;a href=#here16&gt;注册表&lt;/a&gt;"oF.WriteLine "&lt;LI&gt;&lt;a href=#here17&gt;系统日志&lt;/a&gt;&lt;/LI&gt;&lt;/OL&gt;"oF.Writeline "&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;"'---------------------------------'系统摘要' --------------------------------Set objWMIService = GetObject("winmgmts:\\" &amp; strComputer)Set colOperatingSystems = objWMIService.InstancesOf("Win32_OperatingSystem")oF.WriteLine "&lt;h3&gt;&lt;font color=MidnightBlue&gt;&lt;a name=here1&gt;"&amp;"[ 1. 系统摘要 ]"&amp;"&lt;/a&gt;&lt;/font&gt;&lt;/h3&gt;"oF.WriteLine "&lt;table BORDER=1 style=font-size:9pt cellspacing=1 align=CENTER&gt;"For Each objOperatingSystem In colOperatingSystemsostype=objOperatingSystem.NameLastbootUpTime=objOperatingSystem.LastBootUpTime' oF.WriteLine "&lt;tr&gt;&lt;td&gt;&lt;b&gt;" &amp;"Name: "&amp;"&lt;/b&gt;&lt;/td&gt;&lt;td&gt;"&amp; objOperatingSystem.Name &amp;"&lt;/td&gt;&lt;/tr&gt;" ' oF.WriteLine "&lt;tr&gt;&lt;td&gt;&lt;b&gt;" &amp; "Caption: " &amp;"&lt;/b&gt;&lt;/td&gt;&lt;td&gt;" &amp;objOperatingSystem.Caption &amp;"&lt;/td&gt;&lt;/tr&gt;" ' oF.WriteLine "&lt;tr&gt;&lt;td&gt;&lt;b&gt;" &amp; "LastBootUpTime: "&amp;"&lt;/b&gt;&lt;/td&gt;&lt;td&gt;"&amp;objOperatingSystem.LastBootUpTime &amp;"&lt;/td&gt;&lt;/tr&gt;" ' oF.WriteLine "&lt;tr&gt;&lt;td&gt;&lt;b&gt;" &amp; "LocalDateTime: " &amp;"&lt;/b&gt;&lt;/td&gt;&lt;td&gt;"&amp;objOperatingSystem.LocalDateTime &amp;"&lt;/td&gt;&lt;/tr&gt;" ' oF.WriteLine "&lt;tr&gt;&lt;td&gt;&lt;b&gt;"&amp; "Version: " &amp;"&lt;/b&gt;&lt;/td&gt;&lt;td&gt;"&amp;objOperatingSystem.Version &amp;"&lt;/td&gt;&lt;/tr&gt;" 'oF.WriteLine "&lt;tr&gt;&lt;td&gt;&lt;b&gt;"&amp; "Windows Directory: "&amp;"&lt;/b&gt;&lt;/td&gt;&lt;td&gt;"&amp;objOperatingSystem.WindowsDirectory&amp;"&lt;/td&gt;&lt;/tr&gt;"NextSet objWMIService = GetObject("winmgmts:\\" &amp; strComputer &amp; "\root\cimv2")Set colItems = objWMIService.ExecQuery("Select * from Win32_MemoryArray")For Each objItem in colItemsmemsize =CLng(objItem.EndingAddress /1024)' oF.WriteLine "memory size: " &amp; objItem.EndingAddress /1024 &amp;" MB"NextSet objWMI = GetObject("winmgmts:\\" &amp; strComputer &amp; "\root\cimv2")Set col = objWMI.ExecQuery("Select * from Win32_Processor")For Each obj in col cpuinfo=obj.Name NextoF.WriteLine "&lt;table BORDER=1 style=font-size:9pt&gt; &lt;tr&gt;&lt;th CLASS=pt bgColor=#808080&gt;OS&lt;/th&gt;&lt;th bgColor=#808080&gt;HostName&lt;/th&gt;&lt;th bgColor=#808080&gt;Memory&lt;/th&gt;&lt;th bgColor=#808080&gt;CPU&lt;/th&gt;&lt;th bgColor=#808080&gt;LastBootUpTime&lt;/th&gt;&lt;/tr&gt; "oF.WriteLine "&lt;tr&gt;&lt;td&gt;"&amp;ostype&amp;"&lt;/td&gt;&lt;td&gt;"&amp;hostname&amp;"&lt;/td&gt;&lt;td&gt;"&amp;memsize&amp;"MB&lt;/td&gt;&lt;td&gt;"&amp;cpuinfo&amp;"&lt;/td&gt;&lt;td&gt;"&amp; LastBootUpTime &amp;"&lt;/td&gt;&lt;/tr&gt;" strComputer = "."Set objWMIService = GetObject("winmgmts:\\"&amp; strComputer &amp; "\root\cimv2")Set colAdapters = objWMIService.ExecQuery _ ("SELECT * FROM Win32_NetworkAdapterConfiguration WHERE IPEnabled = True") oF.WriteLine "&lt;tr&gt;&lt;th bgColor=#808080&gt;Adapter&lt;/th&gt;&lt;th bgColor=#808080&gt;MACaddr&lt;/th&gt;&lt;th bgColor=#808080&gt;IPaddr&lt;/th&gt;&lt;th bgColor=#808080&gt;Subnet&lt;/th&gt;&lt;th bgColor=#808080&gt;gateway&lt;/th&gt;&lt;/tr&gt; "For Each objAdapter in colAdapters Adapter= objAdapter.Description MACaddr= objAdapter.MACAddress If Not IsNull(objAdapter.IPAddress) Then For i = 0 To UBound(objAdapter.IPAddress) IPaddr=objAdapter.IPAddress(i) Next End If If Not IsNull(objAdapter.IPSubnet) Then For i = 0 To UBound(objAdapter.IPSubnet) Subnet=objAdapter.IPSubnet(i) Next End If If Not IsNull(objAdapter.DefaultIPGateway) Then For i = 0 To UBound(objAdapter.DefaultIPGateway) gateway = objAdapter.DefaultIPGateway(i) Next End IfoF.WriteLine "&lt;tr&gt;&lt;td&gt;"&amp;Adapter&amp;"&lt;/td&gt;&lt;td&gt;"&amp;MACaddr&amp;"&lt;/td&gt;&lt;td&gt;"&amp;IPaddr&amp;"&lt;/td&gt;&lt;td&gt;"&amp;Subnet&amp;"&lt;/td&gt;&lt;td&gt;"&amp;gateway&amp;"&lt;/td&gt;&lt;/tr&gt;" Next oF.WriteLine "&lt;/table&gt;" '-------------------------------------------------------------------- 'BIOS信息 '-------------------------------------------------------------------- oF.WriteLine "&lt;h3&gt;&lt;font color=MidnightBlue&gt;&lt;a name=here2&gt;"&amp;"[ 2. BIOS信息 ]"&amp;"&lt;/a&gt;&lt;/font &gt;&lt;/h3&gt;" Set objWMIService = GetObject("winmgmts:" _ &amp; "&#123;impersonationLevel=impersonate&#125;!\\" &amp; strComputer &amp; "\root\cimv2")Set colBIOS = objWMIService.ExecQuery _ ("Select * from Win32_BIOS") oF.WriteLine "&lt;TABLE BORDER=1 WIDTH=800 style=font-size:9pt cellspacing=1&gt;&lt;TR&gt;&lt;TD&gt;"For Each objBIOS in colBIOS oF.WriteLine "&lt;p&gt;&lt;font size=2&gt;"&amp;"Build Number: " &amp;objBIOS.BuildNumber&amp;"&lt;/font&gt;&lt;/p&gt;" oF.WriteLine "&lt;p&gt;&lt;font size=2&gt;"&amp;"Current Language: " &amp;objBIOS.CurrentLanguage&amp;"&lt;/font&gt;&lt;/p&gt;" oF.WriteLine "&lt;p&gt;&lt;font size=2&gt;"&amp;"Installable Languages: " &amp;objBIOS.InstallableLanguages&amp;"&lt;/font&gt;&lt;/p&gt;" oF.WriteLine "&lt;p&gt;&lt;font size=2&gt;"&amp; "Manufacturer: " &amp;objBIOS.Manufacturer&amp;"&lt;/font&gt;&lt;/p&gt;" oF.WriteLine "&lt;p&gt;&lt;font size=2&gt;"&amp; "Name: "&amp;objBIOS.Name&amp;"&lt;/font&gt;&lt;/p&gt;" oF.WriteLine "&lt;p&gt;&lt;font size=2&gt;"&amp; "Primary BIOS: "&amp; objBIOS.PrimaryBIOS&amp;"&lt;/font&gt;&lt;/p&gt;" oF.WriteLine "&lt;p&gt;&lt;font size=2&gt;"&amp; "Release Date: " &amp;objBIOS.ReleaseDate&amp;"&lt;/font&gt;&lt;/p&gt;" oF.WriteLine "&lt;p&gt;&lt;font size=2&gt;"&amp; "Serial Number: " &amp; objBIOS.SerialNumber&amp;"&lt;/font&gt;&lt;/p&gt;" oF.WriteLine "&lt;p&gt;&lt;font size=2&gt;"&amp; "SMBIOS Version: " &amp;objBIOS.SMBIOSBIOSVersion&amp;"&lt;/font&gt;&lt;/p&gt;" oF.WriteLine "&lt;p&gt;&lt;font size=2&gt;"&amp;"SMBIOS Minor Version: " &amp;objBIOS.SMBIOSMinorVersion&amp;"&lt;/font&gt;&lt;/p&gt;" oF.WriteLine "&lt;p&gt;&lt;font size=2&gt;"&amp; "SMBIOS Present: " &amp;objBIOS.SMBIOSPresent&amp;"&lt;/font&gt;&lt;/p&gt;" oF.WriteLine "&lt;p&gt;&lt;font size=2&gt;"&amp; "Status: " &amp;objBIOS.Status&amp;"&lt;/font&gt;&lt;/p&gt;" oF.WriteLine "&lt;p&gt;&lt;font size=2&gt;"&amp; "Version: " &amp;objBIOS.Version&amp;"&lt;/font&gt;&lt;/p&gt;" oF.WriteLine "&lt;p&gt;&lt;font size=2&gt;"&amp; "BIOS Characteristics: "&amp;"&lt;/font&gt;&lt;/p&gt;"Next oF.WriteLine "&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;" '----------------------------------------------------------------- '环境变量 '----------------------------------------------------------------- oF.WriteLine "&lt;h3&gt;&lt;font color=MidnightBlue&gt;&lt;a name=here3&gt;"&amp;"[ 3. 环境变量 ]"&amp;"&lt;/a&gt;&lt;/font &lt;/h3&gt;" Set wshshell = CreateObject("WScript.Shell")oF.WriteLine "&lt;TABLE BORDER=1 WIDTH=800 style=font-size:9pt cellspacing=1&gt;&lt;TR&gt;&lt;TD&gt;"oF.writeline "&lt;b&gt;&lt;font size=3&gt;SYSTEM variables&lt;/font&gt;&lt;/b&gt;"For Each EnvirSYSTEM In wshshell.Environment("SYSTEM") oF.writeline "&lt;p&gt;&lt;font size=2&gt;" &amp;EnvirSYSTEM &amp;"&lt;/font&gt;&lt;/p&gt;"Next oF.writeline "&lt;b&gt;&lt;font size=3&gt;PROCESS variables&lt;/font&gt;&lt;/b&gt;"For Each EnvirPROCESS In wshshell.Environment("PROCESS") oF.writeline "&lt;p&gt;&lt;font size=2&gt;"&amp;EnvirPROCESS &amp;"&lt;/font&gt;&lt;/p&gt;"Next oF.writeline "&lt;b&gt;&lt;font size=3&gt;USER variables&lt;/font&gt;&lt;/b&gt;"For Each EnvirUSER In wshshell.Environment("USER") oF.writeline "&lt;p&gt;&lt;font size=2&gt;"&amp;EnvirUSER &amp;"&lt;/font&gt;&lt;/p&gt;"Next oF.writeline "&lt;b&gt;&lt;font size=3&gt;VOLATILE variables&lt;/font&gt;&lt;/b&gt;"For Each EnvirVOLATILE In wshshell.Environment("VOLATILE") oF.writeline "&lt;p&gt;&lt;font size=2&gt;"&amp;EnvirVOLATILE &amp;"&lt;/font&gt;&lt;/p&gt;"Nextset wshshell=Nothing oF.WriteLine "&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;" '---------------------------------- '系统文件 '---------------------------------- oF.WriteLine "&lt;h3&gt;&lt;font color=MidnightBlue&gt;&lt;a name=here4&gt;"&amp;"[ 4. 系统文件内容 ]"&amp;"&lt;/a&gt;&lt;/font&gt;&lt;/h3&gt;" Set wshshell=wscript.CreateObject("WScript.shell")autoexecBAT=wshshell.expandEnvironmentStrings("%systemdrive%")&amp;"\autoexec.bat"configSYS=wshshell.expandEnvironmentStrings("%systemdrive%")&amp;"\config.sys"bootINI=wshshell.expandEnvironmentStrings("%systemdrive%")&amp;"\boot.ini"winINI=wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\win.ini"systemINI=wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system.ini"autoexecNT=wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\autoexec.nt"configNT=wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\config.nt"HOSTS=wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\drivers\etc\hosts"Function readtxt (txtfile)Set objFSO = CreateObject("Scripting.FileSystemObject")Set objFile = objFSO.OpenTextFile(txtfile, 1) oF.WriteLine "&lt;TABLE BORDER=1 WIDTH=800 cellspacing=1&gt;&lt;TR&gt;&lt;TD&gt;&lt;b&gt;&lt;font size=3&gt;" &amp;txtfile &amp;"&lt;/font&gt;&lt;/b&gt;"Do Until objFile.AtEndOfStream strCharacters = objFile.Readline oF.WriteLine "&lt;p&gt;&lt;font size=2&gt;" &amp;strCharacters &amp;"&lt;/font&gt;&lt;/p&gt;"LoopoF.WriteLine "&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;"End Functionreadtxt (autoexecBAT)readtxt (configSYS)readtxt (bootINI)readtxt (winINI)readtxt (systemINI)readtxt (autoexecNT)readtxt (configNT)readtxt (HOSTS) '---------------------------------'网络状态' --------------------------------oF.WriteLine "&lt;h3&gt;"&amp;"&lt;font color=MidnightBlue&gt;&lt;a name=here5&gt;"&amp;"[ 5. 网络状态 ]"&amp;"&lt;/a&gt;&lt;/font &gt;"&amp;"&lt;/h3&gt;"Dim f1Set ws=WScript.CreateObject ("wscript.shell")ws.run "%comspec% /c echo ######################### ipconfig /all ######################### &gt; ttmp",0,Truews.run "%comspec% /c ipconfig /all &gt;&gt; ttmp",0,Truews.run "%comspec% /c echo ######################### netstat -r ######################### &gt;&gt; ttmp",0,Truews.run "%comspec% /c netstat -r &gt;&gt;ttmp",0,Truews.run "%comspec% /c echo ######################### arp -a ######################### &gt;&gt; ttmp",0,Truews.run "%comspec% /c arp -a &gt;&gt;ttmp",0,Truews.run "%comspec% /c echo ######################### netstat -an ######################### &gt;&gt; ttmp",0,Truews.run "%comspec% /c netstat -an &gt;&gt;ttmp",0,Truews.run "%comspec% /c echo ######################### nbtstat -r ######################### &gt;&gt; ttmp",0,Truews.run "%comspec% /c nbtstat -r &gt;&gt;ttmp",0,Truews.run "%comspec% /c echo ######################### nbtstat -n ######################### &gt;&gt; ttmp",0,Truews.run "%comspec% /c nbtstat -n &gt;&gt;ttmp",0,Truews.run "%comspec% /c echo ######################### nbtstat -S ######################### &gt;&gt; ttmp",0,Truews.run "%comspec% /c nbtstat -S &gt;&gt;ttmp",0,Truews.run "%comspec% /c echo ######################### netstat -es ######################### &gt;&gt; ttmp",0,Truews.run "%comspec% /c netstat -es &gt;&gt;ttmp",0,TrueSet f1=oFSO.OpenTextFile ("ttmp",forreading,True)oF.WriteLine "&lt;TABLE BORDER=1 WIDTH=800 cellspacing=1&gt;&lt;TR&gt;&lt;TD&gt;"Do Until f1.AtEndOfStreama=f1.ReadLineoF.WriteLine "&lt;p&gt;&lt;font size=2&gt;" &amp;a&amp;"&lt;/font&gt;&lt;/p&gt;"LoopoF.WriteLine "&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;"f1.Closeofso.DeleteFile "ttmp",True'---------------------------------'检查磁盘和共享' --------------------------------oF.WriteLine "&lt;h3&gt;&lt;font color=MidnightBlue&gt;&lt;a name=here6&gt;"&amp;"[ 6. 磁盘和共享 ]"&amp;"&lt;/a&gt;&lt;/font &gt;&lt;/h3&gt;"Sub EnudiskoF.writeline "&lt;table BORDER=1 style=font-size:9pt cellspacing=1&gt;"On Error Resume Next'Enumerate Disk Drive Properties 用了除法转成MB单位，并用clng函数取整Set objFSO = CreateObject("Scripting.FileSystemObject")Set colDrives = objFSO.Drivesof.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;Drive letter: &lt;/th&gt;&lt;th bgColor=#808080&gt;Volume name: &lt;/th&gt;&lt;th bgColor=#808080&gt;File system: &lt;/th&gt;&lt;th bgColor=#808080&gt;Total size: &lt;/th&gt;&lt;th bgColor=#808080&gt;Free space: &lt;/th&gt;&lt;/tr&gt;"For Each objDrive in colDrives of.writeline "&lt;tr&gt;&lt;td&gt;" &amp; objDrive.DriveLetter &amp;"&lt;/td&gt;"&amp;_ "&lt;td&gt;" &amp; objDrive.VolumeName&amp;"&lt;/td&gt;"&amp;_ "&lt;td&gt;" &amp; objDrive.FileSystem&amp;"&lt;/td&gt;"&amp;_ "&lt;td&gt;" &amp; clng(objDrive.TotalSize /1024 /1024 ) &amp;"MB"&amp;"&lt;/td&gt;"&amp;_ "&lt;td&gt;" &amp; CLng(objDrive.FreeSpace /1024 /1024 ) &amp;"MB"&amp;"&lt;/td&gt;&lt;/tr&gt;"NextIf Err &lt;&gt;0 ThenErr.ClearEnd IfEnd SubEnudiskstrComputer = "."Set objWMIService = GetObject("winmgmts:\\" &amp; strComputer &amp; "\root\cimv2")Set colItems = objWMIService.ExecQuery("Select * from Win32_Share",,48) of.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;Path: &lt;/th&gt;&lt;th bgColor=#808080&gt;Name: &lt;/th&gt;&lt;th bgColor=#808080&gt;Caption:&lt;/th&gt;&lt;th bgColor=#808080&gt;Status:&lt;/th&gt;&lt;th bgColor=#808080&gt;MaximumAllowed:&lt;/th&gt;&lt;/tr&gt;"For Each objItem in colItems of.writeline "&lt;tr&gt;&lt;td&gt;"&amp; objItem.Path&amp;"&lt;/td&gt;"&amp; _ "&lt;td&gt;" &amp; objItem.Name&amp;"&lt;/td&gt;"&amp; _ "&lt;td&gt;" &amp; objItem.Caption&amp;"&lt;/td&gt;"&amp; _ "&lt;td&gt;" &amp; objItem.Status&amp;"&lt;/td&gt;"&amp;_ "&lt;td&gt;" &amp;objItem.MaximumAllowed &amp;"&lt;/td&gt;&lt;/tr&gt;"NextoF.WriteLine "&lt;/table&gt;" '---------------------------------'检测进程 ' --------------------------------oF.WriteLine "&lt;h3&gt;&lt;font color=MidnightBlue&gt;&lt;a name=here7&gt;"&amp;"[ 7. 进程 ]"&amp;"&lt;/a&gt;&lt;/font &gt;&lt;/h3&gt;"Set objWMI = _ GetObject("winmgmts:&#123;impersonationLevel=impersonate&#125;//./root/cimv2")Set colProcessList = objWMI.ExecQuery("SELECT * FROM Win32_Process")Set objFSO = CreateObject("Scripting.FileSystemObject")oF.WriteLine "&lt;table BORDER=1 WIDTH=%100 style=font-size:9pt cellspacing=1&gt;"oF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;UserDomain&lt;/th&gt;&lt;th bgColor=#808080&gt;Ownership&lt;/th&gt;&lt;th bgColor=#808080&gt;CreationDate&lt;/th&gt;&lt;th bgColor=#808080&gt;Process ID:&lt;/th&gt;&lt;th bgColor=#808080&gt;Process Name:&lt;/th&gt;"&amp;"&lt;th bgColor=#808080&gt;Executable Path:&lt;/th&gt;&lt;th bgColor=#808080&gt;Size:&lt;/th&gt;&lt;th bgColor=#808080&gt;File created:&lt;/th&gt;&lt;th bgColor=#808080&gt;File last modified:&lt;/th&gt;&lt;th bgColor=#808080&gt;File last accessed:&lt;/th&gt;&lt;/tr&gt;"For Each colprocess In colProcessListcolProperties=colProcess.GetOwner(strNameOfUser,strUserDomain)Set objFile = objFSO.GetFile (colProcess.ExecutablePath) oF.WriteLine "&lt;tr&gt;&lt;td&gt;" &amp; strUserDomain &amp; "&lt;/td&gt;&lt;td&gt;"&amp;strNameOfUser&amp;"&lt;/td&gt;&lt;td&gt;"&amp; colProcess.CreationDate&amp;"&lt;/td&gt;&lt;td&gt;"&amp;colProcess.Processid &amp;"&lt;/td&gt;&lt;td&gt;" &amp;colprocess.name&amp;"&lt;/td&gt;&lt;td&gt;"&amp;colProcess.ExecutablePath &amp; "&lt;/td&gt;"oF.WriteLine "&lt;td&gt;" &amp; objFile.Size &amp;"&lt;/td&gt;"oF.WriteLine "&lt;td&gt;" &amp; objFile.DateCreated &amp;"&lt;/td&gt;"oF.WriteLine "&lt;td&gt;" &amp; objFile.DateLastModified &amp;"&lt;/td&gt;"oF.WriteLine "&lt;td&gt;" &amp; objFile.DateLastAccessed &amp;"&lt;/td&gt;&lt;/tr&gt;"NextoF.WriteLine "&lt;/table&gt;"'---------------------------------'检测进程id对应的服务 ' --------------------------------oF.WriteLine "&lt;h3&gt;&lt;font color=MidnightBlue&gt;&lt;a name=here8&gt;"&amp;"[ 8. 进程ID对应的启动服务 ]"&amp;"&lt;/a&gt;&lt;/font &gt;&lt;/h3&gt;" set objIdDictionary = CreateObject("Scripting.Dictionary")strComputer = "."Set objWMIService = GetObject("winmgmts:" _ &amp; "&#123;impersonationLevel=impersonate&#125;!\\" &amp; strComputer &amp; "\root\cimv2")Set colServices = objWMIService.ExecQuery _ ("Select * from Win32_Service Where State &lt;&gt; 'Stopped'")For Each objService in colServices If objIdDictionary.Exists(objService.ProcessID) Then Else objIdDictionary.Add objService.ProcessID, objService.ProcessID End IfNextcolProcessIDs = objIdDictionary.ItemsoF.WriteLine "&lt;TABLE BORDER=1 style=font-size:9pt cellspacing=1&gt;"For i = 0 to objIdDictionary.Count - 1 Set colServices = objWMIService.ExecQuery _ ("Select * from Win32_Service Where ProcessID = '" &amp; _ colProcessIDs(i) &amp; "'") oF.WriteLine "&lt;TR&gt;&lt;TH bgColor=#808080&gt;Process ID: &lt;/TH&gt;&lt;td&gt;" &amp;colProcessIDs(i)&amp;"&lt;td/&gt;" For Each objService in colServices oF.WriteLine "&lt;tr&gt;&lt;td COLSPAN=2&gt;" &amp; objService.DisplayName &amp;"&lt;/td&gt;&lt;/tr&gt;" NextNext oF.WriteLine "&lt;/TABLE&gt;"'---------------------------------'检测服务 ' --------------------------------oF.WriteLine "&lt;h3&gt;"&amp;"&lt;font color=MidnightBlue&gt;&lt;a name=here9&gt;"&amp;"[ 9. 服务 ]"&amp;"&lt;/a&gt;&lt;/font &gt;"&amp;"&lt;/h3&gt;"strComputer = "." Set objWMIService = GetObject("winmgmts:" &amp; _ "&#123;impersonationLevel=Impersonate&#125;!\\" &amp; strComputer &amp; "\root\cimv2")Set colStartServices = objWMIService.ExecQuery _ ("SELECT DisplayName,State FROM Win32_Service WHERE State = 'Running'")oF.WriteLine "&lt;table BORDER=1 style=font-size:9pt width=100% cellspacing=1&gt;"oF.WriteLine "&lt;tr&gt;&lt;th bgColor=#808080&gt;Running server list:&lt;/th&gt;&lt;/tr&gt;"of.writeline "&lt;tr&gt;&lt;td&gt;"For Each objService in colStartServices of.writeline "&lt;p&gt;" &amp; objService.DisplayName &amp; "&lt;/p&gt;" NextoF.WriteLine "&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;" Set objWMIService = GetObject("winmgmts:\\" &amp; strComputer)Set colServices = objWMIService.InstancesOf("Win32_Service")oF.WriteLine "&lt;table BORDER=1 style=font-size:9pt width=100% cellspacing=1&gt;"oF.WriteLine "&lt;tr&gt;&lt;th bgColor=#808080&gt;Name:&lt;/th&gt;&lt;th bgColor=#808080&gt;Display Name:&lt;/th&gt;&lt;th bgColor=#808080&gt;Path Name:&lt;/th&gt;&lt;th bgColor=#808080&gt;Start Mode:&lt;/th&gt;&lt;th bgColor=#808080&gt;State:&lt;/th&gt;&lt;/tr&gt;"For Each objService In colServices oF.WriteLine "&lt;tr&gt;"&amp;"&lt;td&gt;" &amp;objService.Name &amp;"&lt;/td&gt;"&amp;_ "&lt;td&gt;" &amp; objService.DisplayName&amp;"&lt;/td&gt;"&amp; _ "&lt;td&gt;" &amp; objService.PathName &amp;"&lt;/td&gt;"&amp; _ "&lt;td&gt;" &amp; objService.StartMode &amp;"&lt;/td&gt;"&amp; _ "&lt;td&gt;" &amp;objService.State &amp;"&lt;/td&gt;"Next oF.WriteLine "&lt;/tr&gt;&lt;/table&gt;" '---------------------------------'检测补丁' --------------------------------oF.WriteLine "&lt;h3&gt;"&amp;"&lt;font color=MidnightBlue&gt;&lt;a name=here10&gt;"&amp;"[ 10. 补丁 ]"&amp;"&lt;/a&gt;&lt;/font &gt;"&amp;"&lt;/h3&gt;"strComputer = "."Set objWMIService = GetObject("winmgmts:" _ &amp; "&#123;impersonationLevel=impersonate&#125;!\\" &amp; strComputer &amp; "\root\cimv2")Set colOperatingSystems = objWMIService.ExecQuery _ ("Select * from Win32_OperatingSystem")For Each objOperatingSystem in colOperatingSystems PACKVER = objOperatingSystem.ServicePackMajorVersion _ &amp; "." &amp; objOperatingSystem.ServicePackMinorVersion NextSet objWMIService = GetObject("winmgmts:" _&amp; "&#123;impersonationLevel=impersonate&#125;!\\" &amp; strComputer &amp; "\root\cimv2")Set colQuickFixes = objWMIService.ExecQuery _("Select * from Win32_QuickFixEngineering")oF.WriteLine "&lt;table BORDER=1 style=font-size:9pt cellspacing=1&gt;"oF.WriteLine "&lt;tr&gt;&lt;th bgColor=#808080&gt;PackVersion: &lt;/th&gt;&lt;td&gt;"&amp;PACKVER&amp;"&lt;/td&gt;&lt;/tr&gt;"' oF.WriteLine "&lt;td&gt;Computer: &lt;/td&gt;" oF.WriteLine "&lt;tr&gt;&lt;th bgColor=#808080&gt;Description:&lt;/th&gt;" oF.WriteLine "&lt;th bgColor=#808080&gt;Hotfix ID:&lt;/th&gt;" ' oF.WriteLine "&lt;td&gt;Installation Date:&lt;/td&gt;" ' oF.WriteLine "&lt;td&gt;Installed By:&lt;/td&gt;" oF.WriteLine "&lt;/tr&gt;"For Each objQuickFix in colQuickFixes oF.WriteLine "&lt;tr&gt;"' oF.WriteLine "&lt;td&gt;" &amp; objQuickFix.CSName &amp; "&lt;/td&gt;" oF.WriteLine "&lt;td&gt;" &amp; objQuickFix.Description &amp; "&lt;/td&gt;" oF.WriteLine "&lt;td&gt;" &amp; objQuickFix.HotFixID &amp; "&lt;/td&gt;"' oF.WriteLine "&lt;td&gt;" &amp; objQuickFix.InstallDate &amp; "&lt;/td&gt;"' oF.WriteLine "&lt;td&gt;" &amp; objQuickFix.InstalledBy &amp; "&lt;/td&gt;" oF.WriteLine "&lt;/tr&gt;"NextoF.WriteLine "&lt;/table&gt;"'---------------------------------'检测软件' --------------------------------'get installed softwareoF.WriteLine "&lt;h3&gt;"&amp;"&lt;font color=MidnightBlue&gt;&lt;a name=here11&gt;"&amp;"[ 11. 软件 ]"&amp;"&lt;/a&gt;&lt;/font &gt;"&amp;"&lt;/h3&gt;"oF.WriteLine "&lt;table BORDER=1 style=font-size:9pt cellspacing=1&gt;"Set objWMIService = GetObject("winmgmts:\\" &amp; strComputer &amp; "\root\cimv2")oF.WriteLine "&lt;tr&gt;&lt;th bgColor=#808080&gt;Caption:&lt;/th&gt;&lt;th bgColor=#808080&gt;version:&lt;/th&gt;&lt;/tr&gt;"Set colApps = objWMIService.ExecQuery("Select * from Win32_Product")For Each objApp in colAppsoF.WriteLine "&lt;tr&gt;&lt;td&gt;"&amp;objApp.Caption &amp;"&lt;/td&gt;&lt;td&gt;"&amp; objApp.Version &amp;"&lt;/td&gt;&lt;/tr&gt;"NextDim oRegistry, sBaseKey, iRC, sKey, arSubKeys, sValueConst HKLM = &amp;H80000002 'HKEY_LOCAL_MACHINESet oRegistry = GetObject("winmgmts:\\" &amp; strComputer &amp; _"/root/default:StdRegProv")sBaseKey = "SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\"iRC = oRegistry.EnumKey(HKLM, sBaseKey, arSubKeys)For Each sKey In arSubKeys iRC = oRegistry.GetStringValue(HKLM, sBaseKey &amp; sKey, _ "DisplayName", sValue) version= oRegistry.GetStringValue(HKLM, sBaseKey &amp; sKey, _ "DisplayVersion", sVer) If iRC &lt;&gt; 0 Then oRegistry.GetStringValue HKLM, sBaseKey &amp; sKey, _ "QuietDisplayName", sValue End If If sValue &lt;&gt; "" Then of.writeline"&lt;tr&gt;&lt;td&gt;" &amp; sValue &amp; "&lt;/td&gt;&lt;td&gt;" &amp; sver &amp; "&lt;/td&gt;&lt;/tr&gt;" ElseIf Err &lt;&gt; 0 Then of.writeline"&lt;tr&gt;&lt;td&gt;"&amp; "Installed App Name Not Available" &amp; "&lt;/td&gt;&lt;/tr&gt;" err.clear err.Number=0 End IfNextConst ADMINISTRATIVE_TOOLS = &amp;H2f&amp;Set objShell = CreateObject("Shell.Application")Set objFolder = objShell.Namespace(ADMINISTRATIVE_TOOLS)Set objTools = objFolder.ItemsoF.WriteLine "&lt;tr&gt;&lt;th bgColor=#808080&gt;Admin tools:&lt;/th&gt;&lt;/tr&gt;"For i = 0 to objTools.Count - 1 oF.WriteLine "&lt;tr&gt;&lt;td&gt;"&amp; objTools.Item(i)&amp;"&lt;/td&gt;&lt;/tr&gt;"NextoF.WriteLine "&lt;/table&gt;"'---------------------------------'检测帐号' --------------------------------oF.WriteLine "&lt;h3&gt;&lt;font color=MidnightBlue&gt;&lt;a name=here12&gt;"&amp;"[ 12. 帐号 ]"&amp;"&lt;/a&gt;&lt;/font &gt;&lt;/h3&gt;"strComputer = "."Set objWMIService = GetObject("winmgmts:\\" &amp; strComputer &amp; "\root\cimv2")Set colItems = objWMIService.ExecQuery("Select * from Win32_UserAccount",,48)oF.WriteLine "&lt;table width=100% BORDER=1 style=font-size:9pt cellspacing=1&gt;" oF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;" &amp;"Name: "&amp; "&lt;/th&gt;"_ &amp;"&lt;th bgColor=#808080&gt;"&amp;"Description: "&amp; "&lt;/th&gt;"_ &amp;"&lt;th bgColor=#808080&gt;"&amp;"Lockout: "&amp; "&lt;/th&gt;"_ &amp;"&lt;th bgColor=#808080&gt;"&amp;"PasswordChangeable: "&amp; "&lt;/th&gt;"_ &amp;"&lt;th bgColor=#808080&gt;"&amp;"PasswordExpires: "&amp; "&lt;/t&gt;"_ &amp;"&lt;th bgColor=#808080&gt;"&amp;"SID: " &amp; "&lt;/th&gt;"_ &amp;"&lt;th bgColor=#808080&gt;"&amp; "Status: "&amp; "&lt;/th&gt;"_ &amp;"&lt;th bgColor=#808080&gt;"&amp; "administrators: "&amp; "&lt;/th&gt;"For Each objItem in colItems strUser = objItem.NameSet objGroup = GetObject("WinNT://" &amp; strComputer &amp; "/Administrators") oF.writeline "&lt;tr&gt;&lt;td&gt;" &amp; objItem.Name &amp;"&lt;/td&gt;&lt;td&gt;" &amp; _ objItem.Description &amp;"&lt;/td&gt;&lt;td&gt;" &amp; _ objItem.Lockout &amp;"&lt;/td&gt;&lt;td&gt;" &amp; _ objItem.PasswordChangeable &amp;"&lt;/td&gt;&lt;td&gt;" &amp; _ objItem.PasswordExpires &amp;"&lt;/td&gt;&lt;td&gt;" &amp; _ objItem.SID &amp;"&lt;/td&gt;&lt;td&gt;" &amp; _ objItem.Status&amp;"&lt;/td&gt;" For Each objUser in objGroup.Members If objUser.Name = strUser Then oF.writeline "&lt;td&gt;True&lt;/td&gt;" End If NextNextOn Error Resume NextSet objNetwork = CreateObject("Wscript.Network")strComputer = objNetwork.ComputerNamestrPassword = ""Set colAccounts = GetObject("WinNT://" &amp; strComputer)colAccounts.Filter = Array("user")For Each objUser In colAccounts objUser.ChangePassword strPassword, strPassword If Err = 0 or Err = -2147023569 Then oF.writeline "&lt;p&gt;&lt;font size=2&gt;" &amp;objUser.Name &amp; " password is null !.&lt;/font&gt;&lt;/p&gt;" End If Err.ClearNextoF.WriteLine "&lt;/tr&gt;"oF.WriteLine "&lt;/table&gt;"'---------------------------------'检查计划任务' --------------------------------oF.WriteLine "&lt;h3&gt;&lt;font color=MidnightBlue&gt;&lt;a name=here13&gt;"&amp;"[ 13. AT创建的计划任务 ]"&amp;"&lt;/a&gt;&lt;/font &gt;&lt;/h3&gt;"oF.writeline "&lt;table width=100% BORDER=1 style=font-size:9pt cellspacing=1&gt;"'oF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;Caption:&lt;/th&gt;&lt;th bgColor=#808080&gt;Command:&lt;/th&gt;&lt;th bgColor=#808080&gt;Days Of Month:&lt;/th&gt;&lt;th bgColor=#808080&gt;Days Of Week:&lt;/th&gt;&lt;th bgColor=#808080&gt;Description: &lt;/th&gt;&lt;th bgColor=#808080&gt;Elapsed Time:&lt;/th&gt;&lt;&gt;&lt;&gt;&lt;/th&gt;&lt;&gt;&lt;&gt;&lt;&gt;strComputer = "."Set objWMIService = GetObject("winmgmts:" _ &amp; "&#123;impersonationLevel=impersonate&#125;!\\" &amp; strComputer &amp; "\root\cimv2")Set colScheduledJobs = objWMIService.ExecQuery _ ("Select * from Win32_ScheduledJob")For Each objJob In colScheduledJobs oF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;Caption:&lt;/th&gt;&lt;td&gt; " &amp; objJob.Caption &amp;"&lt;/td&gt;&lt;/tr&gt;" oF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;Command:&lt;/th&gt;&lt;td&gt; " &amp; objJob.Command &amp;"&lt;/td&gt;&lt;/tr&gt;" oF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;Days Of Month: &lt;/th&gt;&lt;td&gt;" &amp; objJob.DaysOfMonth &amp;"&lt;/td&gt;&lt;/tr&gt;" oF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;Days Of Week: &lt;/th&gt;&lt;td&gt;" &amp; objJob.DaysOfWeek &amp;"&lt;/td&gt;&lt;/tr&gt;" oF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;Description: &lt;/th&gt;&lt;td&gt;" &amp; objJob.Description &amp;"&lt;/td&gt;&lt;/tr&gt;" oF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;Elapsed Time: &lt;/th&gt;&lt;td&gt;" &amp; objJob.ElapsedTime &amp;"&lt;/td&gt;&lt;/tr&gt;" oF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;Install Date: &lt;/th&gt;&lt;td&gt;" &amp; objJob.InstallDate &amp;"&lt;/td&gt;&lt;/tr&gt;" oF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;Interact with Desktop: &lt;/th&gt;&lt;td&gt;" &amp; objJob.InteractWithDesktop &amp;"&lt;/td&gt;&lt;/tr&gt;" oF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;Job ID: &lt;/th&gt;&lt;td&gt;" &amp; objJob.JobID &amp;"&lt;/td&gt;&lt;/tr&gt;" oF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;Job Status: &lt;/th&gt;&lt;td&gt;" &amp; objJob.JobStatus &amp;"&lt;/td&gt;&lt;/tr&gt;" oF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;Name: &lt;/th&gt;&lt;td&gt;" &amp; objJob.Name &amp;"&lt;/td&gt;&lt;/tr&gt;" oF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;Notify: &lt;/th&gt;&lt;td&gt;" &amp; objJob.Notify &amp;"&lt;/td&gt;&lt;/tr&gt;" oF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;Owner: &lt;/th&gt;&lt;td&gt;" &amp; objJob.Owner &amp;"&lt;/td&gt;&lt;/tr&gt;" oF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;Priority: &lt;/th&gt;&lt;td&gt;" &amp; objJob.Priority &amp;"&lt;/td&gt;&lt;/tr&gt;" oF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;Run Repeatedly: &lt;/th&gt;&lt;td&gt;" &amp; objJob.RunRepeatedly &amp;"&lt;/td&gt;&lt;/tr&gt;" oF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;Start Time: &lt;/th&gt;&lt;td&gt;" &amp; objJob.StartTime &amp;"&lt;/td&gt;&lt;/tr&gt;" oF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;Status: &lt;/th&gt;&lt;td&gt;" &amp; objJob.Status &amp;"&lt;/td&gt;&lt;/tr&gt;" oF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;Time Submitted: &lt;/th&gt;&lt;td&gt;" &amp; objJob.TimeSubmitted &amp;"&lt;/td&gt;&lt;/tr&gt;" oF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;Until Time: &lt;/th&gt;&lt;td&gt;" &amp; objJob.UntilTime &amp;"&lt;/td&gt;&lt;/tr&gt;"NextoF.writeline "&lt;/table&gt;"'----------------------------------'获取文件信息函数'----------------------------------Function getfileinfo (targetfiles)Set objFSO = CreateObject("Scripting.FileSystemObject")Set objFile = objFSO.GetFile (targetfiles)oF.WriteLine "&lt;tr&gt;&lt;td&gt;" &amp; objFile.Path &amp;"&lt;/td&gt;"oF.WriteLine "&lt;td&gt;" &amp; objFile.Size &amp;"&lt;/td&gt;"oF.WriteLine "&lt;td&gt;" &amp; objFile.Type &amp;"&lt;/td&gt;"oF.WriteLine "&lt;td&gt;" &amp; objFile.DateCreated &amp;"&lt;/td&gt;"oF.WriteLine "&lt;td&gt;" &amp; objFile.DateLastModified &amp;"&lt;/td&gt;"oF.WriteLine "&lt;td&gt;" &amp; objFile.DateLastAccessed &amp;"&lt;/td&gt;&lt;/tr&gt;"End FunctionoF.WriteLine "&lt;h3&gt;&lt;font color=MidnightBlue&gt;&lt;a name=here14&gt;"&amp;"[ 14. 重要文件属性 ]"&amp;"&lt;/a&gt;&lt;/font &gt;&lt;/h3&gt;"oF.writeline "&lt;table BORDER=1 style=font-size:9pt width=100% cellspacing=1&gt;"oF.WriteLine "&lt;tr&gt;&lt;th bgColor=#808080&gt;Path:&lt;/th&gt;&lt;th bgColor=#808080&gt;Size:&lt;/th&gt;&lt;th bgColor=#808080&gt;Type:&lt;/th&gt;&lt;th bgColor=#808080&gt;Date created:&lt;/th&gt;&lt;th bgColor=#808080&gt;Date last modified:&lt;/th&gt;&lt;th bgColor=#808080&gt;Date last accessed:&lt;/th&gt;&lt;/tr&gt;"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\cmd.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\services.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\xcopy.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\arp.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\posix.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\cacls.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\debug.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\telnet.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\ftp.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\tftp.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\tracert.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\edlin.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\rsh.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\ipconfig.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\regedt32.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\finger.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\at.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\netstat.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\wscript.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\cscript.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\ping.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\atsvc.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\rcp.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\regedit.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\nslookup.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\runonce.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\net.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\route.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\copy.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\user.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\csrss.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\rexec.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\nbtstat.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\notepad.exe"getfileinfo wshshell.expandEnvironmentStrings("%systemroot%")&amp;"\system32\edit.com"oF.writeline "&lt;/table&gt;"'get autorunoF.WriteLine "&lt;h3&gt;&lt;font color=MidnightBlue&gt;&lt;a name=here15&gt;"&amp;"[ 15. 自启动项 ]"&amp;"&lt;/a&gt;&lt;/font&gt;&lt;/h3&gt;"oF.writeline "&lt;table BORDER=1 style=font-size:9pt width=100% cellspacing=1&gt;"Set objWMIService = GetObject("winmgmts:" _ &amp; "&#123;impersonationLevel=impersonate&#125;!\\" &amp; strComputer &amp; "\root\cimv2")Set colStartupCommands = objWMIService.ExecQuery _ ("Select * from Win32_StartupCommand") oF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;User:&lt;/th&gt;&lt;th bgColor=#808080&gt;Location:&lt;/th&gt;&lt;th bgColor=#808080&gt;Name:&lt;/th&gt;&lt;th bgColor=#808080&gt;Command:&lt;/th&gt;"For Each objStartupCommand in colStartupCommands oF.writeline "&lt;tr&gt;&lt;td&gt;"&amp;objStartupCommand.User&amp;"&lt;/td&gt;&lt;td&gt;"&amp;objStartupCommand.location&amp;"&lt;/td&gt;&lt;td&gt;"&amp;objStartupCommand.name &amp;"&lt;/td&gt;&lt;td&gt;"&amp; objStartupCommand.command&amp;"&lt;/td&gt;&lt;/tr&gt;"NextoF.WriteLine "&lt;/table&gt;"'---------------------------------'检查注册表自启动项目' --------------------------------oF.WriteLine "&lt;h3&gt;&lt;font color=MidnightBlue&gt;&lt;a name=here16&gt;"&amp;"[ 16. 注册表 ]"&amp;"&lt;/a&gt;&lt;/font&gt;&lt;/h3&gt;"Const HKEY_CLASSES_ROOT = &amp;H80000000Const HKEY_CURRENT_USER = &amp;H80000001Const HKEY_LOCAL_MACHINE = &amp;H80000002Const HKEY_USERS=&amp;H80000003Const HKEY_CURRENT_CONFIG=&amp;H80000005Const REG_SZ = 1Const REG_EXPAND_SZ = 2Const REG_BINARY = 3Const REG_DWORD = 4Const REG_MULTI_SZ = 7strComputer = "."Set oReg=GetObject("winmgmts:&#123;impersonationLevel=impersonate&#125;!\\" &amp;_strComputer &amp; "\root\default:StdRegProv")On Error Resume NextoF.writeline "&lt;table BORDER=1 style=font-size:9pt width=100% cellspacing=1&gt;"oF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;读取此项内容&lt;/th&gt;&lt;th bgColor=#808080&gt;内容&lt;/th&gt;&lt;/tr&gt;"'enum subkeys\all entryNamesoReg.GetdwordValue HKEY_LOCAL_MACHINE,"SYSTEM\CurrentControlSet\Services\lanmanserver\parameters","Autoshareserver",strValueIf IsNull(strValue) ThenElseoF.WriteLine "&lt;tr&gt;&lt;td&gt;"&amp;"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\lanmanserver\parameters\Autoshareserver" &amp;"&lt;/td&gt;"oF.WriteLine "&lt;td&gt;"&amp;strValue &amp;"&lt;/td&gt;&lt;/tr&gt;" End IfoReg.GetstringValue HKEY_LOCAL_MACHINE,"Software\Microsoft\Windows NT\CurrentVersion\Winlogon","Shell",strValueIf IsNull(strValue) ThenElseoF.WriteLine "&lt;tr&gt;&lt;td&gt;"&amp;"HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Windows\shell" &amp;"&lt;/td&gt;"oF.WriteLine "&lt;td&gt;"&amp;strValue &amp;"&lt;/td&gt;&lt;/tr&gt;"End Iforeg.GetstringValue HKEY_LOCAL_MACHINE,"Software\Microsoft\Windows NT\CurrentVersion\Winlogon","Userinit",strValueIf IsNull(strValue) ThenElseoF.WriteLine "&lt;tr&gt;&lt;td&gt;"&amp;"HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Windows\Userinit" &amp;"&lt;/td&gt;"oF.WriteLine "&lt;td&gt;"&amp;strValue &amp;"&lt;/td&gt;&lt;/tr&gt;"End IfoReg.GetstringValue HKEY_LOCAL_MACHINE,"Software\Microsoft\Windows NT\CurrentVersion\Windows","run",strValueIf IsNull(strValue) ThenElseoF.WriteLine "&lt;tr&gt;&lt;td&gt;"&amp;"HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Windows\run" &amp;"&lt;/td&gt;"oF.WriteLine "&lt;td&gt;"&amp;strValue &amp;"&lt;/td&gt;&lt;/tr&gt;"End IfoReg.GetstringValue HKEY_CURRENT_USER,"Software\Microsoft\Windows NT\CurrentVersion\Windows","run",strValueIf IsNull(strValue) ThenElseoF.WriteLine "&lt;tr&gt;&lt;td&gt;"&amp;"HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\Windows\run" &amp;"&lt;/td&gt;"oF.WriteLine "&lt;td&gt;"&amp;strValue &amp;"&lt;/td&gt;&lt;/tr&gt;"End IfoReg.GetstringValue HKEY_CURRENT_USER,"Software\Microsoft\Windows NT\CurrentVersion\Windows","load",strValueIf IsNull(strValue) ThenElseoF.WriteLine "&lt;tr&gt;&lt;td&gt;"&amp;"HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\Windows\load" &amp;"&lt;/td&gt;"oF.WriteLine "&lt;td&gt;"&amp;strValue &amp;"&lt;/td&gt;&lt;/tr&gt;"End Iforeg.getdwordvalue HKEY_LOCAL_MACHINE,"SYSTEM\CurrentControlSet\Services\EventLog\Application","Maxsize",dwordvalueIf IsNull(strValue) ThenElseoF.WriteLine "&lt;tr&gt;&lt;td&gt;"&amp;"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\EventLog\Application\Maxsize" &amp;"&lt;/td&gt;"oF.WriteLine "&lt;td&gt;"&amp;dwordValue &amp;"&lt;/td&gt;&lt;/tr&gt;"End Iforeg.getdwordvalue HKEY_LOCAL_MACHINE,"SYSTEM\CurrentControlSet\Services\EventLog\security","Maxsize",dwordvalueIf IsNull(strValue) ThenElseoF.WriteLine "&lt;tr&gt;&lt;td&gt;"&amp;"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\EventLog\security\Maxsize" &amp;"&lt;/td&gt;"oF.WriteLine "&lt;td&gt;"&amp;dwordValue &amp;"&lt;/td&gt;&lt;/tr&gt;"End Iforeg.getdwordvalue HKEY_LOCAL_MACHINE,"SYSTEM\CurrentControlSet\Services\EventLog\system","Maxsize",dwordvalueIf IsNull(strValue) ThenElseoF.WriteLine "&lt;tr&gt;&lt;td&gt;"&amp;"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\EventLog\system\Maxsize" &amp;"&lt;/td&gt;"oF.WriteLine "&lt;td&gt;"&amp;dwordValue &amp;"&lt;/td&gt;&lt;/tr&gt;"End Iforeg.getdwordvalue HKEY_LOCAL_MACHINE,"SYSTEM\CurrentControlSet\Control\Lsa","restrictanonymous",dwordvalueIf IsNull(strValue) ThenElseoF.WriteLine "&lt;tr&gt;&lt;td&gt;"&amp;"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\RestrictAnonymous" &amp;"&lt;/td&gt;"oF.WriteLine "&lt;td&gt;"&amp;dwordValue &amp;"&lt;/td&gt;&lt;/tr&gt;"End Iforeg.getdwordvalue HKEY_LOCAL_MACHINE,"System\CurrentControlSet\Services\NetBT\Parameters","SMBDeviceEnabled",dwordvalueIf IsNull(strValue) ThenElseoF.WriteLine "&lt;tr&gt;&lt;td&gt;"&amp;"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NetBT\Parameters\SMBDeviceEnabled" &amp;"&lt;/td&gt;"oF.WriteLine "&lt;td&gt;"&amp;dwordValue &amp;"&lt;/td&gt;&lt;/tr&gt;"End IfoReg.GetStringValue HKEY_LOCAL_MACHINE,"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows","Appinit_Dlls",stringvalueIf IsNull(strValue) ThenElseoF.WriteLine "&lt;tr&gt;&lt;td&gt;"&amp;"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\Appinit_Dlls" &amp;"&lt;/td&gt;"oF.WriteLine "&lt;td&gt;"&amp;stringvalue &amp;"&lt;/td&gt;&lt;/tr&gt;"End IfoF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;枚举此键内容&lt;/th&gt;&lt;th bgColor=#808080&gt;项目名&lt;/th&gt;&lt;th bgColor=#808080&gt;数据类型&lt;/th&gt;&lt;/tr&gt;"'get entryNames valuesRegEnum HKEY_LOCAL_MACHINE,"SOFTWARE\Microsoft\Windows\CurrentVersion\Run"RegEnum HKEY_LOCAL_MACHINE,"SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx"RegEnum HKEY_LOCAL_MACHINE,"SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce"RegEnum HKEY_LOCAL_MACHINE,"SOFTWARE\Microsoft\Windows\CurrentVersion\RunServices"RegEnum HKEY_LOCAL_MACHINE,"SOFTWARE\Microsoft\Windows\CurrentVersion\ShellServiceObjectDelayLoad"RegEnum HKEY_CURRENT_USER,"SOFTWARE\Microsoft\Windows\CurrentVersion\Run"RegEnum HKEY_CURRENT_USER,"SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce"RegEnum HKEY_CURRENT_USER,"SOFTWARE\Micrsoft\Windows\CurrentVersion\RunOnceEx"RegEnum HKEY_CURRENT_USER,"SOFTWARE\Micrsoft\Windows\CurrentVersion\RunServices"'the dll files Location: C:\WINDOWS\system32RegEnum HKEY_LOCAL_MACHINE,"System\CurrentControlSet\Control\Session Manager\KnownDLLs"Function RegEnum (Subtrees,strKeyPath)On Error Resume NextoReg.EnumValues Subtrees, strKeyPath,_ arrValueNames, arrValueTypes If Not IsNull(arrvaluenames) Then If Subtrees= &amp;H80000002 Then oF.WriteLine "&lt;tr&gt;&lt;td&gt;"&amp;"HKEY_LOCAL_MACHINE\"&amp;strKeyPath &amp;"&lt;/td&gt;&lt;/tr&gt;" Elseif Subtrees=&amp;H80000001 Then oF.WriteLine "&lt;tr&gt;&lt;td&gt;"&amp; "HKEY_CURRENT_USER\"&amp;strKeyPath &amp;"&lt;/td&gt;&lt;/tr&gt;" End IfEnd IfFor i=0 To UBound(arrValueNames) oF.WriteLine "&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;"&amp; arrValueNames(i) &amp;"&lt;/td&gt;" Select Case arrValueTypes(i) Case REG_SZ oF.WriteLine "&lt;td&gt;"&amp; "String" &amp;"&lt;/td&gt;&lt;/tr&gt;" Case REG_EXPAND_SZ oF.WriteLine "&lt;td&gt;"&amp; "Expanded String" &amp;"&lt;/td&gt;&lt;/tr&gt;" Case REG_BINARY oF.WriteLine "&lt;td&gt;"&amp; "Binary" &amp;"&lt;/td&gt;&lt;/tr&gt;" Case REG_DWORD oF.WriteLine "&lt;td&gt;"&amp; "DWORD" &amp;"&lt;/td&gt;&lt;/tr&gt;" Case REG_MULTI_SZ oF.WriteLine "&lt;td&gt;"&amp; "Multi String" &amp;"&lt;/td&gt;&lt;/tr&gt;" End Select NextEnd FunctionstrKeyPath = "SYSTEM\CurrentControlSet\Control\SecurePipeServers\Winreg"oReg.CheckAccess HKEY_LOCAL_MACHINE, strKeyPath, KEY_QUERY_VALUE, bHasAccessRightIf bHasAccessRight = True Then a=" Query"Else a= " Not Query"End IfoReg.CheckAccess HKEY_LOCAL_MACHINE, strKeyPath, KEY_SET_VALUE, bHasAccessRightIf bHasAccessRight = True Then b= " Set"Else b=" Not Set "End IfoReg.CheckAccess HKEY_LOCAL_MACHINE, strKeyPath, KEY_CREATE_SUB_KEY, bHasAccessRightIf bHasAccessRight = True Then c= " Create"Else c=" Not Create"End IfoReg.CheckAccess HKEY_LOCAL_MACHINE, strKeyPath, DELETE, bHasAccessRightIf bHasAccessRight = True Then d=" DELETE"Else d=" NotDelete"End IfoF.writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;检查项目&lt;/th&gt;&lt;th bgColor=#808080&gt;支持的权限"oF.WriteLine "&lt;tr&gt;&lt;td&gt;"&amp;"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurePipeServers\Winreg"&amp;"&lt;/td&gt;&lt;td&gt;"&amp;a&amp;b&amp;c&amp;d&amp;"&lt;/td&gt;&lt;/tr&gt;"oF.writeline "&lt;/table&gt;"'------------------------------------------------------------'Set fs=CreateObject("scripting.filesystemobject")'Set f0=fs.getspecialfolder(0)'Set f1=fs.getspecialfolder(1)'Set f2=fs.getspecialfolder(2)'system32=f1'oF.writeline "&lt;table BORDER=1 style=font-size:9pt&gt;"'oF.WriteLine "&lt;tr&gt;&lt;th&gt;"'WScript.Echo f0&amp;f1&amp;f2'Set objShell = CreateObject ("Shell.Application")'Set objFolder = objShell.Namespace (system32)'Set objFSO = CreateObject("Scripting.FileSystemObject")'Dim arrHeaders(13)'For i = 0 to 13 ' arrHeaders(i) = objFolder.GetDetailsOf (objFolder.Items, i)'Next'For Each strFileName in objFolder.Items ' For i = 0 to 13 ' If i &lt;&gt; 9 Then ' oF.writeline "&lt;tr&gt;&lt;th&gt;"&amp; arrHeaders(0)&amp;"&lt;/th&gt;&lt;th&gt;"&amp; arrHeaders(1)&amp;"&lt;/th&gt;&lt;th&gt;"&amp; arrHeaders(2)&amp;"&lt;/th&gt;&lt;th&gt;"&amp; arrHeaders(3)&amp;"&lt;/th&gt;&lt;th&gt;"&amp; arrHeaders(4)&amp;"&lt;/th&gt;&lt;th&gt;"&amp; arrHeaders(5)&amp;"&lt;/th&gt;&lt;th&gt;"&amp; arrHeaders(6)&amp;"&lt;/th&gt;&lt;th&gt;"&amp; arrHeaders(7)&amp;"&lt;/th&gt;&lt;th&gt;"&amp; arrHeaders(8)&amp;"&lt;/th&gt;&lt;th&gt;"&amp; arrHeaders(9)&amp;"&lt;/th&gt;&lt;th&gt;"&amp; arrHeaders(10)&amp;"&lt;/th&gt;&lt;th&gt;"&amp; arrHeaders(11)&amp;"&lt;/th&gt;&lt;th&gt;"&amp; arrHeaders(12)&amp;"&lt;/th&gt;&lt;th&gt;"&amp; arrHeaders(13)&amp;"&lt;/th&gt;&lt;/tr&gt;" ' oF.writeline "&lt;tr&gt;&lt;td&gt;" &amp;objFolder.GetDetailsOf (strFileName, 0) &amp;"&lt;/td&gt;"&amp;"&lt;td&gt;" &amp;objFolder.GetDetailsOf (strFileName, 1) &amp;"&lt;/td&gt;"&amp;"&lt;td&gt;" &amp;objFolder.GetDetailsOf (strFileName, 2) &amp;"&lt;/td&gt;"&amp;"&lt;td&gt;" &amp;objFolder.GetDetailsOf (strFileName, 3) &amp;"&lt;/td&gt;"&amp;"&lt;td&gt;" &amp;objFolder.GetDetailsOf (strFileName, 4) &amp;"&lt;/td&gt;"&amp;"&lt;td&gt;" &amp;objFolder.GetDetailsOf (strFileName, 5) &amp;"&lt;/td&gt;"&amp;"&lt;td&gt;" &amp;objFolder.GetDetailsOf (strFileName, 6) &amp;"&lt;/td&gt;"&amp;"&lt;td&gt;" &amp;objFolder.GetDetailsOf (strFileName, 7) &amp;"&lt;/td&gt;"&amp;"&lt;td&gt;" &amp;objFolder.GetDetailsOf (strFileName,8) &amp;"&lt;/td&gt;"&amp;"&lt;td&gt;" &amp;objFolder.GetDetailsOf (strFileName, 9) &amp;"&lt;/td&gt;"&amp;"&lt;td&gt;" &amp;objFolder.GetDetailsOf (strFileName, 10) &amp;"&lt;/td&gt;"&amp;"&lt;td&gt;" &amp;objFolder.GetDetailsOf (strFileName, 11) &amp;"&lt;/td&gt;"&amp;"&lt;td&gt;" &amp;objFolder.GetDetailsOf (strFileName, 12) &amp;"&lt;/td&gt;&lt;td&gt;" &amp;objFolder.GetDetailsOf (strFileName, 13) &amp;"&lt;/td&gt;&lt;/tr&gt;" ' End If 'Next 'WScript.Echo'Next'sys file read'Set fs=CreateObject("scripting.filesystemobject")'Set f0=fs.getspecialfolder(0)'Set f1=fs.getspecialfolder(1)'Set f2=fs.getspecialfolder(2)'winfile=f0&amp;"\"&amp;"win.ini"'sysfile="C:\WINDOWS\SYSTEM.INI"'set file2=oFSO.OpenTextFile (sysfile,forreading,True)'While file2.AtEndOfStream&lt;&gt;True'ccc=ReadLine'oF.WriteLine "&lt;p&gt;&lt;font size=2&gt;" &amp;ccc&amp;"&lt;/font&gt;&lt;/p&gt;"'Wend'---------------------------------'导出系统日志为html' --------------------------------oF.WriteLine "&lt;h3&gt;&lt;font color=MidnightBlue&gt;&lt;a name=here17&gt;"&amp;"[ 17. 系统日志 ]"&amp;"&lt;/a&gt;&lt;/font&gt;&lt;/h3&gt;"msg="是否导出系统日志为单独的html报告？"&amp; VbCrLfmsg=msg&amp;"日志筛选内容包括："&amp; VbCrLfmsg=msg&amp;" 1.登录失败"&amp; VbCrLfmsg=msg&amp;" 2.错误、警告、安全审核失败 "&amp; VbCrLfSet objShell = WScript.CreateObject("Wscript.Shell")EventDoIt = MsgBox(msg,vbQuestion+vbYesNo+vbSystemModal,"运行提示")If EventDoIt = vbNo ThenoF.writeline "&lt;p&gt;&lt;font size=2&gt;程序运行没有选择导出日志&lt;/font&gt;&lt;/p&gt;"Run_completeWScript.QuitEnd IfoF.writeline "&lt;p&gt;&lt;font size=2&gt;&lt;a href="&amp;EventReport&amp;"&gt;点击打开 "&amp;EventReport&amp;" 查看日志&lt;/a&gt;&lt;/font&gt;&lt;/p&gt;"Set objWMIService = GetObject("winmgmts:&#123;(Security)&#125;\\" &amp; strComputer &amp; "\root\cimv2")Set colEvents = objWMIService.ExecQuery("Select * from Win32_NTLogEvent Where Logfile = 'Security' and EventCode = '529'")eventlog.WriteLine "&lt;head&gt;&lt;title&gt;eventLog build by bkReport.vbs&lt;/title&gt;&lt;/head&gt;"eventlog.writeline "&lt;table BORDER=1 style=font-size:9pt width=100% cellspacing=1&gt;"eventlog.Writeline "&lt;tr&gt;&lt;th bgColor=#808080 COLSPAN=6&gt;登录失败日志信息&lt;/th&gt;&lt;/tr&gt;"eventlog.Writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;Category: &lt;/th&gt;"eventlog.Writeline "&lt;th bgColor=#808080&gt;Event Code: &lt;/th&gt;"eventlog.Writeline "&lt;th bgColor=#808080&gt;Record Number: &lt;/th&gt;"eventlog.Writeline "&lt;th bgColor=#808080&gt;Event Type: &lt;/th&gt;"eventlog.Writeline "&lt;th bgColor=#808080&gt;Time Written: &lt;/th&gt;" eventlog.Writeline "&lt;th bgColor=#808080&gt;Message: &lt;/th&gt;&lt;/tr&gt;"For Each objEvent in colEventseventlog.Writeline "&lt;tr&gt;&lt;td&gt;" &amp; objEvent.Category &amp;"&lt;/td&gt;"eventlog.Writeline "&lt;td&gt;" &amp; objEvent.EventCode &amp;"&lt;/td&gt;"eventlog.Writeline "&lt;td&gt;" &amp; objEvent.RecordNumber &amp;"&lt;/td&gt;"eventlog.Writeline "&lt;td&gt;" &amp; objEvent.Type &amp;"&lt;/td&gt;"eventlog.Writeline "&lt;td&gt;" &amp; objEvent.TimeWritten &amp;"&lt;/td&gt;"eventlog.Writeline "&lt;td&gt;" &amp; objEvent.Message &amp;"&lt;/td&gt;&lt;/tr&gt;"NextSet colLoggedEvents = objWMIService.ExecQuery _ ("Select * from Win32_NTLogEvent Where Type &lt;&gt; 'information' AND Type &lt;&gt; 'audit success'")eventlog.Writeline "&lt;tr&gt;&lt;th bgColor=#808080 COLSPAN=6&gt;错误、警告、安全审核失败日志信息&lt;/th&gt;&lt;/tr&gt;"eventlog.Writeline "&lt;tr&gt;&lt;th bgColor=#808080&gt;Category: &lt;/th&gt;"eventlog.Writeline "&lt;th bgColor=#808080&gt;Event Code: &lt;/th&gt;"eventlog.Writeline "&lt;th bgColor=#808080&gt;Record Number: &lt;/th&gt;"eventlog.Writeline "&lt;th bgColor=#808080&gt;Event Type: &lt;/th&gt;"eventlog.Writeline "&lt;th bgColor=#808080&gt;Time Written: &lt;/th&gt;" eventlog.Writeline "&lt;th bgColor=#808080&gt;Message: &lt;/th&gt;&lt;/tr&gt;"For Each objEvent in colLoggedEventseventlog.Writeline "&lt;tr&gt;&lt;td&gt;" &amp; objEvent.Category &amp;"&lt;/td&gt;"eventlog.Writeline "&lt;td&gt;" &amp; objEvent.EventCode &amp;"&lt;/td&gt;"eventlog.Writeline "&lt;td&gt;" &amp; objEvent.RecordNumber &amp;"&lt;/td&gt;"eventlog.Writeline "&lt;td&gt;" &amp; objEvent.Type &amp;"&lt;/td&gt;"eventlog.Writeline "&lt;td&gt;" &amp; objEvent.TimeWritten &amp;"&lt;/td&gt;"eventlog.Writeline "&lt;td&gt;" &amp; objEvent.Message &amp;"&lt;/td&gt;&lt;/tr&gt;"NextoF.writeline "&lt;/table&gt;"oF.WriteLine "&lt;/html&gt;"Run_completeoF.closeeSub Run_completedtmEnd = Now()oF.Writeline "&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;"oF.Writeline "&lt;hr width=90% color=#ff8000&gt;"oF.Writeline "&lt;p align=center&gt;&lt;font size=2&gt;脚本运行时间 "&amp; DateDiff("s", dtmStart, dtmEnd)&amp;" 秒 问题反馈eMail: qinbo@nsfocus.com&lt;/font&gt;&lt;/p&gt;"objShell.run MainReportEnd Sub'********************************************************************'* *'* End of File *'* *'********************************************************************]]></content>
      <categories>
        <category>windows学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[清理linux登录和操作记录]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2016%2F11%2F11%2Flinux%E5%AD%A6%E4%B9%A0-2016-11-11-%E6%B8%85%E7%90%86%E7%99%BB%E5%BD%95%E5%92%8C%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[作者: daodaoliang 版本: V 0.0.1 日期: 2016年11月11日 创建 clear.sh 脚本文件,内容如下 1234567891011121314151617#!/bin/shecho &gt; /var/log/syslogecho &gt; /var/log/messagesecho &gt; /var/log/xferlog#echo &gt; /var/log/httpd/access_log#echo &gt; /var/log/httpd/error_logecho &gt; /var/log/mysqld.logecho &gt; /var/log/secureecho &gt; /var/log/auth.logecho &gt; /var/log/user.logecho &gt; /var/log/wtmpecho &gt; /var/log/lastlogecho &gt; /var/log/btmpecho &gt; /var/run/utmpecho &gt; .bash_historyecho &gt; .mysql_historyhistory -c 给脚本执行权限并执行 12chmod +x ./clear.sh./clear.sh 登录的账号必须有相应目录的rw权限]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Qt开源项目说明]]></title>
    <url>%2F%E7%A7%81%E4%BA%BA%E5%B7%A5%E5%85%B7%E9%A1%B9%E7%9B%AE%2F2016%2F11%2F04%2FQDaoDaoLiang-2016-11-04-Qt%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[作者: daodaoliang 版本: V 0.0.3 邮箱: daodaoliang@yeah.net 在使用过程中有任何疑问可直接联系我，以后还会有其他组件开源，现有组件也会升级维护哒，QQ:88341189，没事也可以技术交流呀！ 0x00 基础UI组件集合(NBaseUiKit) 项目说明: Qt编写的基础UI组件集合，方便平时的组件定制等问题； 开源状态: 完全开源； 开源主页: http://daodaoliang.com/NBaseUiKit/ 0x01 常用功能公共组件集合(NCommon) 项目说明: Qt编写的常用功能组件集合，截屏、自动部署发布、数据转码等功能组件； 开源状态: 完全开源； 开源主页: http://daodaoliang.com/NCommon/； 0x02 认证组件(NAuth) 项目说明: Qt编写的权限验证组件,适用于注册码机制； 开源状态: 完全开源； 开源主页: http://daodaoliang.com/NAuth/； 0x03 加密的配置组件(NConfig) 项目说明: Qt编写的基于加密的sqlite数据库存取的配置文件； 开源状态: 完全开源； 开源主页: http://daodaoliang.com/NConfig/； 0x04 加解密算法组件(NEncryptionKit) 项目说明: Qt编写的常用的加解密算法的封装组件，比如AES、DES、RSA、凯撒加密等自定义加解密方式； 开源状态: 完全开源； 开源主页: http://daodaoliang.com/NEncryptionKit/； 0x05 数据库连接池组件(NDBPool) 项目说明: Qt编写的数据库连接池 ，支持长短链等； 开源状态: 完全开源； 开源主页: http://daodaoliang.com/NDBPool/； 0x06 跨线程安全的日志组件(NLoger) 项目说明: Qt编写跨线程安全的日志记录(原项目为cuteloger)； 开源状态: 完全开源； 开源主页: http://daodaoliang.com/NLoger/； 0x07 系统软硬件信息组件(NComputerInfo) 项目说明: Qt编写获取程序运行期间的PC硬件等相关信息； 开源状态: 完全开源； 开源主页: http://daodaoliang.com/NComputerInfo/]]></content>
      <categories>
        <category>私人工具项目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[supervisor 安装与配置]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2016%2F11%2F02%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2016-11-02-Supervisor%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[作者: daodaoliang 版本: V1.0.1 邮箱： daodaoliang@yeah.net 这里是官方链接 0x00 supervisor 简介Supervisor 是一个用 python 语言开发的用来在 linux 系统下进行进程管理的工具。可以很方面的监控、启动、停止、重启一个或者多个进程。当进程意外终止时可以在第一时间进行重启，做到自动恢复。 0x01 supervisor 安装1.确保 python 环境完备 Note: Supervisor is known to work with Python 2.4 or later but will not work under any version of Python 3. 安装 easy_install 或者 pip： 1wget --no-check-certificate https://bootstrap.pypa.io/ez_setup.py -O - | sudo python 或者 12# get-pip.py请从官网获取python get-pip.py 2.安装 supervisor 1pip install supervisor 或者 1easy_install supervisor 或者 12# 需要源支持yum install supervisor supervisor安装完成后会生成三个执行程序：supervisortd、supervisorctl、echo_supervisord_conf，分别是supervisor的守护进程服务（用于接收进程管理命令）、客户端（用于和守护进程通信，发送管理进程的指令）、生成初始配置文件程序。 0x02 supervisor 配置1. 配置文件生成 运行supervisord服务的时候，需要用 c 参数指定supervisor配置文件，如果没有显示指定，默认以此在以下目录查找： $CWD/supervisord.conf $CWD/etc/supervisord.conf /etc/supervisord.conf /etc/supervisor/supervisord.conf (since Supervisor 3.3.0) ../etc/supervisord.conf (Relative to the executable) ../supervisord.conf (Relative to the executable) Note： $CWD 表示运行 supervisord 程序的目录。 可以通过运行 echo_supervisord_conf 程序生成 supervisor 的初始化配置文件,如下所示: 12mkdir /etc/supervisor echo_supervisord_conf &gt; /etc/supervisor/supervisord.conf 2. 配置项说明 supervisor的配置参数较多，下面介绍一下常用的参数配置，详细的配置及说明，请参考官方文档介绍。分号（;）开头的配置表示注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220[unix_http_server];socket文件的路径，supervisorctl用XML_RPC和supervisord通信就是通过它进行的,不设置的话，默认为none。非必须设置。file=/tmp/supervisor.sock;修改file的权限必须为0700,非必须设置。chmod=0700;修改file的权限的所属组为nobody:nogroup,非必需设置。chown=nobody:nogroup;使用supervisorctl链接的时候,认证的用户,不设置的话默认不需要用户,非必需设置。username=user;和上面的用户名对应的密码，可以直接使用明码，也可以使用SHA加密如&#123;SHA&#125;82ab876d1387bfafe46cc1c8a2ef074eae50cb1d。password=123;侦听在TCP上的socket,Web Server和远程的supervisorctl都要用到他不设置的话，默认为不开启。非必须设置。[inet_http_server];侦听的IP和端口，侦听所有IP用 :9001或*:9001或者0.0.0.0:9001.这个必须设置，只要上面的[inet_http_server]开启了，就必须设置它。port=127.0.0.1:9001;登录时的用户名。username=user;登录时的密码。password=123;定义supervisord这个服务端进程的一些参数的。[supervisord];supervisord这个主进程的日志路径,默认路径$CWD/supervisord.log,$CWD是当前目录,非必需设置。logfile=/tmp/supervisord.log;这个是上面那个日志文件的最大的大小,当超过50M(默认值是50M)的时候,会生成一个新的日志文件。当设置为0时,表示不限制文件大小,非必须设置。logfile_maxbytes=50MB;日志文件保持的数量,supervisor在启动程序时,会自动创建10个buckup文件(默认10),用于log rotate当设置为0时,表示不限制文件的数量。logfile_backups=10;日志级别，有critical, error, warn, info, debug, trace, or blather等默认为info,非必须设置项。loglevel=info;supervisord的pid文件路径,默认为$CWD/supervisord.pid。pidfile=/tmp/supervisord.pid;如果是true,supervisord进程将在前台运行默认为false,也就是后台以守护进程运行。nodaemon=false;这个是最少系统空闲的文件描述符，低于这个值(默认值1024)supervisor将不会启动。系统的文件描述符在这里设置cat /proc/sys/fs/file-max。minfds=1024;最小可用的进程描述符,低于这个值(默认200)supervisor也将不会正常启动。ulimit -u这个命令，可以查看linux下面用户的最大进程数。minprocs=200;进程创建文件的掩码,默认为022umask=022;这个参数可以设置一个非root用户，当我们以root用户启动supervisord之后。我这里面设置的这个用户，也可以对supervisord进行管理,默认不设置。user=daodaoliang;supervisord的标识符，主要是给XML_RPC用的。当你有多个supervisor的时候，而且想调用XML_RPC统一管理，就需要为每个supervisor设置不同的标识符了,默认sipervisor。identifier=supervisor;当supervisord作为守护进程运行的时候,设置这个参数的话,启动supervisord进程之前,会先切换到这个目录默认不设置。directory=/tmp;在supervisord进程启动的时候，把以前子进程产生的日志文件(路径为AUTO的情况下)清除掉,默认false,有调试需求的同学可以设置为true。nocleanup=true;当子进程日志路径为AUTO的时候，子进程日志文件的存放路径。默认路径是这个东西，执行下面的这个命令看看就OK了，处理的东西就默认路径;python -c "import tempfile;print tempfile.gettempdir()"childlogdir=/tmp;设置环境变量的，supervisord在linux中启动默认继承了linux的环境变量，在这里可以设置supervisord进程特有的其他环境变量。;supervisord启动子进程时，子进程会拷贝父进程的内存空间内容。 所以设置的这些环境变量也会被子进程继承。;小例子：environment=name="daodaoliang",age="26"environment=KEY="value";如果设置为true，会清除子进程日志中的所有 ANSI 序列（\n,\t等）。strip_ansi=false[rpcinterface:supervisor]supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface;针对supervisorctl的一些配置[supervisorctl];supervisorctl本地连接supervisord的时候，本地UNIX socket路径，注意这个是和前面的[unix_http_server]对应的默认值就是unix:///tmp/supervisor.sockserverurl=unix:///tmp/supervisor.sock;supervisorctl远程连接supervisord的时候，用到的TCP socket路径,注意这个和前面的[inet_http_server]对应默认就是http://127.0.0.1:9001serverurl=http://127.0.0.1:9001;用户名username=daodaoliang;密码password=123;输入用户名密码时候的提示符prompt=iamnami;这个参数和shell中的history类似，我们可以用上下键来查找前面执行过的命令默认是no file,所以我们想要有这种功能，必须指定一个文件history_file=~/.sc_history;要管理的子进程了,":"后面的是名字，最好别乱写和实际进程有点关联最好。这样的program我们可以设置一个或多个，一个program就是要被管理的一个进程[program:theprogramname];要启动进程的命令路径了，可以带参数/home/test.py -a 'hehe';需要注意的是，我们的command只能是那种在终端运行的进程，不能是守护进程。这个是个必须设置的项。command=/bin/cat;当numprocs为1时,process_name=%(program_name)s;当numprocs&gt;=2时,%(program_name)s_%(process_num)02dprocess_name=%(program_name)s;进程数量,当不为1时，就是进程池的概念numprocs=1;进程开始的数字numprocs_start=1;进程运行前，会前切换到这个目录directory=/tmp;进程掩码:--- -w- -w-, 转换后rwx r-x r-xumask=022;优先级,值越高,最后启动,最先被关闭,默认值999priority=999;如果为true则程序在supervisord启动后将会启动autostart=true;自动重启的情况;有三个选项，false,unexpected和true。;如果为false的时候，无论什么情况下，都不会被重新启动。;如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的退出码的时候，才会被自动重启。;当为true的时候，只要子进程挂掉，将会被无条件的重启。autorestart=true;子进程气动阀多少秒后才把状态置为runningstartsecs=1;当进程启动失败后，最大尝试启动的次数。。当超过3次后，supervisor将把此进程的状态置为FAIL。startretries=3;和上面的的autorestart=unexpected对应。exitcodes里面的定义的退出码是expected的。exitcodes=0,2;进程停止信号，可以为TERM, HUP, INT, QUIT, KILL, USR1, or USR2等信号。当用设定的信号去干掉进程，退出码会被认为是expected。;中断:INT(类似于Ctrl+C)(kill -INT pid),退出后会将写文件或日志(推荐);终止:TERM(kill -TERM pid);挂起:HUP(kill -HUP pid),注意与Ctrl+Z/kill -stop pid不同;从容停止:QUIT(kill -QUIT pid) ;KILL, USR1, USR2其他见命令(kill -l),说明1;默认为TERM。stopsignal=TERM;当我们向子进程发送stopsignal信号后，到系统返回信息给supervisord，所等待的最大时间。 超过这个时间，supervisord会向该子进程发送一个强制kill的信号。;默认为10秒,非必须设置。stopwaitsecs=10;用于supervisord管理的子进程，这个子进程本身还有子进程。那么我们如果仅仅干掉supervisord的子进程的话，子进程的子进程有可能会变成孤儿进程.;所以可以设置可个选项，把整个该子进程的整个进程组都干掉。 设置为true的话，一般killasgroup也会被设置为true。;需要注意的是，该选项发送的是stop信号默认为false。;非必须设置。stopasgroup=false;这个和上面的stopasgroup类似，不过发送的是kill信号。;非必须设置killasgroup=false;如果supervisord是root启动，我们在这里设置这个非root用户，可以用来管理该program。;非必须设置项。user=daodaoliang;如果为true，则stderr的日志会被写入stdout日志文件中redirect_stderr=true;子进程的stdout的日志路径，可以指定路径，AUTO，none等三个选项;设置为none的话，将没有日志产生。;设置为AUTO的话，将随机找一个地方生成日志文件,而且当supervisord重新启动的时候,以前的日志文件会被清空。;当 redirect_stderr=true的时候，sterr也会写进这个日志文件。stdout_logfile=/a/path;日志文件最大大小，和[supervisord]中定义的一样。默认为50stdout_logfile_maxbytes=1MB;和[supervisord]定义的一样。默认10stdout_logfile_backups=10;这个东西是设定capture管道的大小，当值不为0的时候，子进程可以从stdout发送信息，而supervisor可以根据信息，发送相应的event。;默认为0，为0的时候表达关闭管道。;非必须项stdout_capture_maxbytes=1MB;当设置为ture的时候,当子进程由stdout向文件描述符中写日志的时候,将触发supervisord发送PROCESS_LOG_STDOUT类型的event.;默认为false;非必须设置stdout_events_enabled=false;这个东西是设置stderr写的日志路径，当redirect_stderr=true。这个就不用设置了，设置了也是白搭。因为它会被写入stdout_logfile的同一个文件中默认为AUTO。;也就是随便找个地存,supervisord重启被清空。;非必须设置stderr_logfile=/a/path;这个是该子进程的环境变量，和别的子进程是不共享的environment=A="1",B="2"serverurl=AUTO;当我们要管理的进程很多的时候，写在一个文件里面就有点大了。我们可以把配置信息写到多个文件中，然后include过来。[include];例如/an/absolute/filename.conf /an/absolute/*.conf foo.conf config??.conffiles = relative/directory/*.ini 3.例子 1234567891011121314151617181920212223242526272829[program:usercenter]; 程序的启动目录directory = /home/leon/projects/usercenter; 启动命令，可以看出与手动在命令行启动的命令是一样的command = gunicorn -c gunicorn.py --port=%(process_num)s wsgi:app; 程序名字process_name=%(program_name)s_%(process_num)02d; 开始数字numprocs_start=8110; 数量numprocs=4; 在 supervisord 启动的时候也自动启动autostart = true; 启动 5 秒后没有异常退出，就当作已经正常启动了startsecs = 5; 程序异常退出后自动重启autorestart = true; 启动失败自动重试次数，默认是 3startretries = 3; 用哪个用户启动user = leon; 把 stderr 重定向到 stdout，默认 falseredirect_stderr = true; stdout 日志文件大小，默认 50MBstdout_logfile_maxbytes = 20MB; stdout 日志文件备份数stdout_logfile_backups = 20; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）stdout_logfile = /data/logs/usercenter_stdout.log 0x03 supervisord 启动和维护1.启动服务 1/etc/init.d/supervisord -c /etc/supervisor.conf 2.启动管理端 1supervisorctl -c /etc/supervisor.conf 若是连接远程的则: 1supervisorctl -c /etc/supervisor.conf -s &quot;http://114.114.114.114:9001&quot; 3.管理服务 1234567891011121314151617181920212223242526272829# 查看服务状态status # 关闭 usercenter 程序 stop usercenter # 停止所有程序 stop all# 启动 usercenter 程序start usercenter# 启动所有程序 start all # 重启 usercenter 程序 restart usercenter# 重启所有程序 restart all# 读取有更新的的配置文件，不会启动新程序 reread # 重启启动远程supervisord reload # 更新配置文件，若有新的则启动，若删除了则停止 update]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[nginx 配置https并自签名证书]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2016%2F10%2F28%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2016-10-28-nginx%E9%85%8D%E7%BD%AEhttps%E5%B9%B6%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[作者: daodaoliang 版本: V1.0.1 邮箱： daodaoliang@yeah.net 参考链接： 这里 和 这里 和 官方文档 1. 制作服务器证书服务器CA私钥： 1openssl genrsa -des3 -out ca.key 2048 制作解密后的CA私钥（一般无此必要）： 1openssl rsa -in ca.key -out ca_decrypted.key ca.crt CA根证书（公钥）： 1openssl req -new -x509 -days 7305 -key ca.key -out ca.crt 2. 制作生成网站的证书并用CA签名认证在这里，假设网站域名为 www.example.com 生成 www.example.com 证书私钥： 1openssl genrsa -des3 -out www.example.com.pem 1024 制作解密后的 www.example.com 证书私钥： 1openssl rsa -in www.example.com.pem -out www.example.com.key 生成签名请求： 1openssl req -new -key www.example.com.pem -out www.example.com.csr 在common name中填入网站域名，如 www.example.com 即可生成改站点的证书，同时也可以使用泛域名如 *.example.com 来生成所有二级域名可用的网站证书。 用CA进行签名： 1openssl ca -policy policy_anything -days 1460 -cert ca.crt -keyfile ca.key -in www.example.com.csr -out www.example.com.crt 其中，policy参数允许签名的CA和网站证书可以有不同的国家、地名等信息，days参数则是签名时限。 如果在执行签名命令时，出现“I am unable to access the ../../CA/newcerts directory” 修改/etc/pki/tls/openssl.cnf中“dir = ./CA” 然后： 1234567mkdir -p CA/newcertstouch CA/index.txttouch CA/serialecho &quot;01&quot; &gt; CA/serial 再重新执行签名命令。 最后，把ca.crt的内容粘贴到 www.example.com.crt 后面。这个比较重要！因为不这样做，可能会有某些浏览器不支持。 好了，现在https需要到的网站私钥 www.example.com.key 和网站证书 www.example.com.crt 都准备完毕。接下来开始配置服务端。 3. 配置nginx新开一个虚拟主机，并在server{}段中设置： 1234567listen 443;ssl on;ssl_certificate /path/to/www.example.com.crt;ssl_certificate_key /path/to/www.example.com.key; 其中的路径是刚刚生成的网站证书的路径。 然后使用一下命令检测配置和重新加载nginx： 1234检测配置：nginx -t重新加载：nginx -s reload 4. 优化nginx配置https和http共存: 12345678910server &#123; listen 80; listen 443 ssl; server_name zou.lu; root /var/www/html; #ssl on; //这行必须要注释掉 ssl_certificate /usr/local/nginx/conf/zou_lu.crt; ssl_certificate_key /usr/local/nginx/conf/zoulukey.pem; &#125; 优化性能: 在http{}中加入： 123ssl_session_cache shared:SSL:10m;ssl_session_timeout 10m; 据官方文档所述，cache中的1m可以存放4000个session。 在配置https的虚拟主机server{}中加入： 1keepalive_timeout 70; PS:常见错误: 有时候，会发现，在phpMyAdmin等程序登入后会错误地跳转http的问题。解决方法是定位至“location ~ .*.(php|php5)?${}”在include fcgi.conf;或者在fastcgi_param配置后面加上： 123fastcgi_param HTTPS on;fastcgi_param HTTP_SCHEME https;]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常用的正则表达式]]></title>
    <url>%2F%E8%BD%AC%E8%BD%BD%2F2016%2F09%2F28%2F%E8%BD%AC%E8%BD%BD-2016-09-28-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[原文出处: (http://www.jianshu.com/p/e7bb97218946) 日期: 2016年9月28日 版本: V1.0.1.0 正则表达式，一个十分古老而又强大的文本处理工具，仅仅用一段非常简短的表达式语句，便能够快速实现一个非常复杂的业务逻辑。熟练地掌握正则表达式的话，能够使你的开发效率得到极大的提升。 正则表达式经常被用于字段或任意字符串的校验，如下面这段校验基本日期格式的JavaScript代码： 123var reg = /^(\\d&#123;1,4&#125;)(-|\\/)(\\d&#123;1,2&#125;)\\2(\\d&#123;1,2&#125;)$/; var r = fieldValue.match(reg); if(r==null)alert('Date format error!'); 1.校验密码强度密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。 1^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ 2.校验中文字符串仅能是中文. 1^[\\u4e00-\\u9fa5]&#123;0,&#125;$ 3.由数字、26个英文字母或下划线组成的字符串1^\\w+$ 4.校验E-Mail 地址1[\\w!#$%&amp;&apos;*+/=?^_`&#123;|&#125;~-]+(?:\\.[\\w!#$%&amp;&apos;*+/=?^_`&#123;|&#125;~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])? 5.校验身份证号码下面是身份证号码的正则校验。15 或 18位。 15位 1^[1-9]\\d&#123;7&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;$ 18位 1^[1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;([0-9]|X)$ 6.校验日期“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。 1^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$ 7.校验金额金额校验，精确到2位小数。 1^[0-9]+(.[0-9]&#123;2&#125;)?$ 8.校验手机号下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码） 1^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$ 9.判断IE的版本IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。 1^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$ 10.校验IP-v4地址IP4 正则语句。 1\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b 11.校验IP-v6地址IP6 正则语句。 1(([0-9a-fA-F]&#123;1,4&#125;:)&#123;7,7&#125;[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,7&#125;:|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,6&#125;:[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,5&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,2&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,3&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,3&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,2&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,5&#125;|[0-9a-fA-F]&#123;1,4&#125;:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,6&#125;)|:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,7&#125;|:)|fe80:(:[0-9a-fA-F]&#123;0,4&#125;)&#123;0,4&#125;%[0-9a-zA-Z]&#123;1,&#125;|::(ffff(:0&#123;1,4&#125;)&#123;0,1&#125;:)&#123;0,1&#125;((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;:((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])) 12.检查URL的前缀应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。 1if (!s.match(/^[a-zA-Z]+:\\/\\//)) &#123; s = &apos;http://&apos; + s; &#125; 13.提取URL链接下面的这个表达式可以筛选出一段文本中的URL. 1^(f|ht)&#123;1&#125;(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;=]*)? 14.文件路径及扩展名校验验证windows下文件路径和扩展名（下面的例子中为.txt文件） 1^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?&quot;&lt;&gt;|]+\\.txt(l)?$ 15.提取Color Hex Codes有时需要抽取网页中的颜色代码，可以使用下面的表达式。 1^#([A-Fa-f0-9]&#123;6&#125;|[A-Fa-f0-9]&#123;3&#125;)$ 16.提取网页图片假若你想提取网页中所有图片信息，可以利用下面的表达式。 1\\&lt; *[img][^\\\\&gt;]*[src] *= *[\\&quot;\\&apos;]&#123;0,1&#125;([^\\&quot;\\&apos;\\ &gt;]*) 17.提取页面超链接提取html中的超链接。 1(&lt;a\\s*(?!.*\\brel=)[^&gt;]*)(href=&quot;https?:\\/\\/)((?!(?:(?:www\\.)?&apos;.implode(&apos;|(?:www\\.)?&apos;, $follow_list).&apos;))[^&quot;]+)&quot;((?!.*\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt; 18.查找CSS属性通过下面的表达式，可以搜索到相匹配的CSS属性。 1^\\s*[a-zA-Z\\-]+\\s*[:]&#123;1&#125;\\s[a-zA-Z0-9\\s.#]+[;]&#123;1&#125; 19.抽取注释如果你需要移除HMTL中的注释，可以使用如下的表达式。 1&lt;!--(.*?)--&gt; 20.匹配HTML标签通过下面的表达式可以匹配出HTML中的标签属性. 1&lt;\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:&quot;.*?&quot;|&apos;.*?&apos;|[\\^&apos;&quot;&gt;\\s]+))?)+\\s*|\\s*)\\/?&gt; 学习正则表达式 1.快速学习指南 2.在线测试工具]]></content>
      <categories>
        <category>转载</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[nginx 常用的配置]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2016%2F09%2F20%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2016-03-14-nginx%E7%9A%84%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[安装请移步这里点击我 1. nginx目录嵌套123456http &#123; ....... include /etc/nginx/conf.d/*.conf; include sites/*.conf;&#125; 2. gzip on加到http模块中, 开启gzip, 注意gzip_types配置得是压缩的资源类型 12345678910111213http &#123; ..... gzip on; gzip_min_length 1k; gzip_comp_level 5; gzip_proxied expired no-cache no-store private auth; gzip_types text/plain text/css application/javascript text/javascript application/x-javascript text/xml application/xml application/xml+rss application/json image/x-icon image/png image/jpg image/jpeg application/font-woff; gzip_vary on;&#125; 3. 多处理器12345678worker_processes 4;events &#123; worker_connections 2048; use epoll; multi_accept on;&#125;worker_rlimit_nofile 100000; 4. 静态文件缓存1234567location ~* \.(?:css|js)$ &#123; expires 12h; access_log off; add_header Cache-Control &quot;public&quot;; proxy_pass http://127.0.0.1:5000; proxy_redirect off;&#125; 5. 代理12345678910location /&#123; proxy_pass http://127.0.0.1:8000; proxy_pass_header Server; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Scheme $scheme; proxy_set_header Host $http_host; proxy_redirect off;&#125; 可以设置超时时间 123proxy_connect_timeout 500s;proxy_read_timeout 500s;proxy_send_timeout 500s; 6. 静态目录 or 文件12345678910location /movies/ &#123; alias /Volumes/Media/Movies/; allow all;&#125;location = /abc.txt &#123; alias /data/www/static/abc.txt; expires 30d; access_log off;&#125; 7. 静态站12345678910111213server &#123; listen 192.168.1.1:80; server_name www.abc.com; client_max_body_size 1M; access_log logs/blog_access.log; error_log logs/blog_error.log; root /data/static_site_dir; index index.html;&#125; 8. 服务转发将收到的服务url/参数等, 原封不动转给另一个服务 12345678server &#123; listen 80; server_name www.xxxx.com; location ~ ^/(.*)$ &#123; proxy_pass http://192.168.1.1:80/another/service/$1$is_args$args; proxy_read_timeout 90; &#125;&#125; 9. return语法： 12return http_code;return http_code &quot;content&quot;; 例如： 1234567891011location /api/test/ &#123; return 403;&#125;location /stat/ &#123; return 204;&#125;location /ping/ &#123; return 200;&#125; 10. 重定向到 www1234server &#123; server_name abc.com; rewrite ^(.*) http://www.abc.com$1 permanent;&#125; 11. 允许或者拒绝访问ip控制 1234location /test/ &#123; allow 192.168.1.1; deny all;&#125; 12. 负载均衡123456789101112131415http &#123; upstream test &#123; server 192.168.1.1:5000; server 192.168.1.2:5000; &#125;&#125;server &#123; location / &#123; proxy_pass test; &#125;&#125; 13. 配置文件检查123456检查配置文件正确性service nginx configtest重新加载配置service nginx reload]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[10个值得前端收藏的CSS3动效库]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%2F2016%2F09%2F18%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0-2016-09-28-10%E4%B8%AA%E5%80%BC%E5%BE%97%E5%89%8D%E7%AB%AF%E6%94%B6%E8%97%8F%E7%9A%84CSS3%E5%8A%A8%E6%95%88%E5%BA%93%2F</url>
    <content type="text"><![CDATA[原文: http://www.jianshu.com/p/31118d83cb5f# 版本: V1.0.1.0 日期: 2016年9月28日 现在的网站和App的设计中越来越重视用户体验，而优秀的动效则能使你的应用更具交互性，从而吸引更多用户的使用。如果你对CSS3中定义动效还不熟练，或希望采用更加简单直接的方式在你的应用中引入动效的话，你可以参考并使用下面的这10个优秀动效库（工具）。 1.Animate.cssAnimate.css是我比较喜欢的一个CSS3动效库，非常适合那些对CSS3动画效果不熟悉，但又希望给自己所做的网站或基于H5的APP引入动效的朋友。因为，你只需要给需要实现动效的元素添加上Animate.css中预定义的那些动效名称就可以了。比如常见的：bounce，flash，fadeIn，fadeOut等等，加起来有75种不同的动效，完全能够满足你的基本需要了。 当然对于这个库也有一些使用注意事项，比如你最好在给元素添加动效样式完成动效后，马上将这个动效样式去掉。另外，对于动效的时长，振动幅度等，你也需要做一些调整。因为，我感觉它默认设置中的动效过于快速和强烈了。Animate.css已经提供了详细的文档告诉你应该如何做这些调整。 2.Bounce.jsBounce.js是一个能够生成CSS3动效的小工具，它是用JavaScript编写的，提供了一个Web界面，你可以添加一个组件然后就可以选择包括Scale，Translate，Rotate，Skew这些动效类型，然后分别设置它们的参数，当达到你想要的效果后，你可以将这个动效以CSS的方式导出，这样你就可以将它应用到你的应用中了。 3.CSS3 AnimationCSS3 Animation是一个非常简单易用的动效工具，你可以在它提供的简单图形界面里，通过拖拽一些进度条来控制你的动效，生成的CSS代码会自动显示在下面的一个文本框里，你可以拷贝粘贴到你的应用中直接使用。 4.CSS Animate如果你觉得上面的工具还无法做出你想要的动效，那么可以看看CSS Animate这个工具。它能让你设置更多的动效参数，比如你可以同时设置动效起始和终止状态的坐标，大小，以及透明度，这样你就能够做出更加复杂的动效来。 5.Magic AnimationsMagic Animations与Animate.css十分类似，也是一个预定义了一系列动效的CSS库。但与Animate.css的最大区别可能是，它定义的那些动效更炫也更酷一些，如果你的网站也很新潮，那可以考虑使用这个CSS动效库。 6.AniJSAniJS是一个通过JavaScript控制的动效库。它允许你通过它的链式语法来定义动效。比如下面这个例子：当用户点击时这个元素会沿Y轴翻转。 1&lt;div data-anijs=&quot;if: click, do: flipInY, to: .container-box&quot;&gt;&lt;/div&gt; 7.Single Element CSS Spinners我们经常会需要一些动效来表达系统处于加载或处理数据的过程中。Single Element CSS Spinners这个在GitHub上的项目，提供了一组非常漂亮的可用于加载的CSS3动效。 8.Snabbt.jsSanbbt.js是我很喜欢的一个动效库，它非常小巧只有5K，所以可以被用在移动应用中。而且它也支持链式语法，你可以很方便地写出复杂的动效组合。 123456789snabbt(element, &#123; position: [200, 0, 0], easing: function(value) &#123; return value + 0.3 * Math.sin(2*Math.PI * value); &#125;&#125;).snabbt(&#123; position: [0, 0, 0], easing: &apos;easeOut&apos;&#125;); 9.OdometerOdometer 是用来给数字作动效的，比如通过它你可以很好地呈现网站人数的增加，倒计时等与数字相关的动画效果。 10.Hover.cssHover.css提供了大量的Hover效果，包括2D变换，图标变换，背景变换等等。而且几乎可以应用于所有元素，包括链接，按钮，logo，SVG甚至图片等等。]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[github上前端涉及的知识体系]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%2F2016%2F09%2F18%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0-2016-09-18-github%E4%B8%8A%E5%89%8D%E7%AB%AF%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[作者: daodaoliang 版本: V1.0.1.0 日期: 2016年9月18日 原文出处在这里 综合类 综合类 地址 前端知识体系 http://www.cnblogs.com/sb19871023/p/3894452.html 前端知识结构 https://github.com/JacksonTian/fks Web前端开发大系概览 https://github.com/unruledboy/WebFrontEndStack Web前端开发大系概览-中文版 http://www.cnblogs.com/unruledboy/p/WebFrontEndStack.html Web Front-end Stack v2.2 Web Front-end Stack v2.2 免费的编程中文书籍索引 https://github.com/justjavac/free-programming-books-zh_CN 前端书籍 https://github.com/dypsilon/frontend-dev-bookmarks 前端免费书籍大全 https://github.com/vhf/free-programming-books 前端知识体系 http://www.cnblogs.com/sb19871023/p/3894452.html 免费的编程中文书籍索引 https://github.com/justjavac/free-programming-books-zh_CN 智能社 - 精通JavaScript开发 http://study.163.com/course/introduction/224014.htm 重新介绍 JavaScript（JS 教程） https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript 麻省理工学院公开课：计算机科学及编程导论 http://v.163.com/special/opencourse/bianchengdaolun.html JavaScript中的this陷阱的最全收集–没有之一 http://segmentfault.com/a/1190000002640298 JS函数式编程指南 https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html JavaScript Promise迷你书（中文版） http://liubin.github.io/promises-book 腾讯移动Web前端知识库 https://github.com/AlloyTeam/Mars Front-End-Develop-Guide 前端开发指南 https://github.com/Front-End-Developers-Hunan/Front-End-Develop-Guide 前端开发笔记本 https://li-xinyang.gitbooks.io/frontend-notebook/content 大前端工具集 - 聂微东 https://github.com/nieweidong/fetool 前端开发者手册 https://dwqs.gitbooks.io/frontenddevhandbook/content 入门类 入门类 地址 前端入门教程 http://www.cnblogs.com/jikey/p/3613082.html 瘳雪峰的Javascript教程 http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000 jQuery基础教程 http://www.imooc.com/view/11 前端工程师必备的PS技能——切图篇 http://www.imooc.com/view/506 结合个人经历总结的前端入门方法 https://github.com/qiu-deqing/FE-learning 工具类 工具类 地址 前端人的俱乐部 http://f2er.club/ 真可以解放你的收藏夹 如何优雅地使用Sublime Text http://www.jeffjade.com/2015/12/15/2015-04-17-toss-sublime-text/# 新编码神器Atom使用纪要 http://www.jeffjade.com/2016/03/03/2016-03-02-how-to-use-atom/ css sprite 雪碧图制作 http://www.imooc.com/learn/93 版本控制入门 – 搬进 Github http://www.imooc.com/learn/390 Grunt-beginner前端自动化工具 http://www.imooc.com/learn/30 IntelliJ IDEA 简体中文专题教程 https://github.com/judasn/IntelliJ-IDEA-Tutorial Webstorm,InterllIdea,Phpstorm http://t.cn/8kZZ1Uy SublimeText https://github.com/jikeytang/sublime-text Atom https://atom.io visual studio code https://code.visualstudio.com 综合效果搜索平台 综合效果搜索平台 地址 JavaScript 资源大全中文版 https://github.com/jobbole/awesome-javascript-cn 100+ 超全的web开发工具和资源 https://xituqu.com/170.html zoommyapp.com http://zoommyapp.com/ 高质量图库 unsplash.com https://unsplash.com/ 高质量图库 www.pinterest.com https://www.pinterest.com/ 图库 New Old Stock http://nos.twnsnd.co 复古风图库 效果网 http://www.jq22.com 花瓣网 http://huaban.com/ 优美图 http://www.topit.me/ codepen http://codepen.io/ 摄图网 http://699pic.com/ 常用的JavaScript代码片段 http://microjs.com 团队Blog|周报类 周报类 地址 奇舞周刊 http://old.75team.com/weekly/ 码农周刊 http://weekly.manong.io WEB前端开发 http://www.css88.com A JS tip per day! http://www.jstips.co 腾讯全端 AlloyTeam http://www.alloyteam.com/webdevelop/ 平安科技移动开发二队技术周报 https://github.com/PaicHyperionDev/MobileDevWeekly 开发中心 开发中心 地址 mozilla js参考 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript chrome开发中心（chrome的内核已转向blink） https://developer.chrome.com/extensions/api_index.html safari开发中心 https://developer.apple.com/library/safari/navigation microsoft js参考 https://msdn.microsoft.com/zh-cn/library/d1et7k7c(v=vs.94.aspx js秘密花园 http://sanshi.me/articles/JavaScript-Garden-CN/html/index.html js秘密花园 http://bonsaiden.github.io/JavaScript-Garden/zh w3help http://www.w3help.org 综合Bug集合网站 Nodejs Nodejs 地址 nodejs 篇幅比较巨大 http://liuqing.pw Node.js 包教不包会 https://github.com/alsotang/node-lessons 篇幅比较少 http://www.rainweb.cn/article/category/Nodejs node express 入门教程 http://www.w3cfuns.com/article-5598538-1-1.html nodejs定时任务 http://my.oschina.net/u/568264/blog/193773 一个nodejs博客 http://60sky.com 【NodeJS 学习笔记04】新闻发布系统 http://www.cnblogs.com/yexiaochai/p/3536547.html 过年7天乐，学nodejs 也快乐 http://www.cnblogs.com/qqloving/p/3541099.html 七天学会NodeJS https://github.com/nqdeng/7-days-nodejs Nodejs学习笔记（二）— 事件模块 http://www.cnblogs.com/zhongweiv/p/nodejs_events.html nodejs入门 http://www.cnblogs.com/liusuqi/p/3735491.html angularjs nodejs https://github.com/zensh/jsgen 从零开始nodejs系列文章 http://blog.fens.me/series-nodejs 理解nodejs http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb nodejs事件轮询 http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop node入门 http://www.nodebeginner.org/index-zh-cn.html nodejs cms http://ourjs.com/detail/53e1f281c5910a9806000001 Node初学者入门，一本全面的NodeJS教程 http://ourjs.com/detail/529ca5950cb6498814000005 NodeJS的代码调试和性能调优 http://www.barretlee.com/blog/2015/10/07/debug-nodejs-in-command-line 综合API 综合API 地址 javascripting http://www.javascripting.com 各种流行库搜索 http://microjs.com runoob.com-包含各种API集合 http://www.runoob.com 开源中国在线API文档合集 http://tool.oschina.net/apidocs devdocs http://devdocs.io 英文综合API网站 Ecmascript Ecmascript 地址 Understanding ECMAScript 6 - Nicholas C. Zakas https://leanpub.com/understandinges6/read exploring-es6 https://leanpub.com/exploring-es6/read exploring-es6翻译 https://github.com/es6-org/exploring-es6 exploring-es6翻译后预览 http://es6-org.github.io/exploring-es6 阮一峰 es6 http://es6.ruanyifeng.com 阮一峰 Javascript http://javascript.ruanyifeng.com ECMA-262，第 5 版 http://yanhaijing.com/es5 es5 http://es5.github.io Js template Js template 地址 template-chooser http://garann.github.io/template-chooser artTemplate https://github.com/aui/artTemplate tomdjs https://github.com/aui/tmodjs/blob/master/README.md 淘宝模板juicer模板 http://juicer.name/docs/docs_zh_cn.html Fxtpl v1.0 繁星前端模板引擎 http://koen301.github.io/fxtpl laytpl http://laytpl.layui.com mozilla - nunjucks https://github.com/mozilla/nunjucks Juicer https://github.com/PaulGuo/Juicer dustjs http://akdubya.github.io/dustjs etpl http://ecomfe.github.io/etpl HTML5(HTML) HTML(HTML5) 地址 深入理解HTML5标签 https://segmentfault.com/a/1190000002695791 如何写出高效率的HTML https://segmentfault.com/a/1190000002680822 HTML meta标签总结与属性使用介绍 https://segmentfault.com/a/1190000004279791 戏说HTML5 http://www.cnblogs.com/dojo-lzz/p/5059316.html CSS3(CSS) CSS 地址 CSS 语法参考 http://tympanus.net/codrops/css_reference 如何编写可维护的CSS https://github.com/chadluo/CSS-Guidelines/blob/master/README.md CSS3动画手册 http://isux.tencent.com/css3/index.html 腾讯css3动画制作工具 http://isux.tencent.com/css3/tools.html 志爷css小工具集合 http://linxz.github.io/tianyizone css3 js 移动大杂烩 http://www.note12.com/category/blog/2014-6-5/538fe0a9f786f1b7019a4dfb bouncejs 触摸库 http://bouncejs.com css3 按钮动画 http://fian.my.id/Waves animate.css http://daneden.github.io/animate.css 全局CSS的终结(狗带 [译] http://www.alloyteam.com/2015/10/8536 browserhacks http://browserhacks.com Angularjs Angularjs 地址 Angular.js 的一些学习资源 https://github.com/dolymood/AngularLearning angularjs中文社区 http://angularjs.cn Angularjs源码学习 http://www.cnblogs.com/xuwenmin888/p/3739096.html Angularjs源码学习 http://www.ifeenan.com/?c=AngularJS angular对bootstrap的封装 http://angular-ui.github.io/bootstrap angularjs + nodejs https://cnodejs.org/topic/51404e0f069911196d2e3923 吕大豹 Angularjs http://www.cnblogs.com/lvdabao/tag/AngularJs AngularJS 最佳实践 http://www.infoq.com/cn/news/2013/02/angular-web-app Angular的一些扩展指令 http://www.lovelucy.info/angularjs-best-practices.html Angular数据绑定原理 https://github.com/Pasvaz/bindonce 一些扩展Angular UI组件 https://github.com/angular-ui Ember和AngularJS的性能测试 http://voidcanvas.com/emberjs-vs-angularjs-performance-testing 带你走近AngularJS - 基本功能介绍 http://www.cnblogs.com/powertoolsteam/p/angularjs-introdection.html Angularjs开发指南 http://angular.duapp.com/docs/guide Angularjs学习 http://www.cnblogs.com/amosli/p/3710648.html 不要带着jQuery的思维去学习AngularJS http://www.rainweb.cn/article/angularjs-jquery.html angularjs 学习笔记 http://wangjiatao.diandian.com/?tag=angularjs angularjs 开发指南 http://www.angularjs.cn/T008 angularjs 英文资料 https://github.com/jmcunningham/AngularJS-Learning angular bootstrap http://angular-ui.github.io/bootstrap angular jq mobile https://github.com/opitzconsulting/jquery-mobile-angular-adapter angular ui http://mgcrea.github.io/angular-strap 整合jQuery Mobile+AngularJS经验谈 http://www.tuicool.com/articles/7ZZVr2 有jQuery背景，该如何用AngularJS编程思想 http://blog.jobbole.com/46589/ AngularJS在线教程 http://each.sinaapp.com/angular angular学习笔记 http://www.zouyesheng.com/angular.html React React 地址 react.js 中文论坛 http://www.react-china.org react.js 官方网址 https://facebook.github.io/react/index.html react.js 官方文档 https://facebook.github.io/react/docs/getting-started.html react.js material UI http://material-ui.com/# react.js TouchstoneJS UI http://touchstonejs.io react.js amazeui UI http://amazeui.org/react React 入门实例教程 - 阮一峰 http://www.ruanyifeng.com/blog/2015/03/react.html React Native 中文版 http://wiki.jikexueyuan.com/project/react-native Webpack 和 React 小书 - 前端乱炖 http://www.html-js.com/article/Fakefish%203053 Webpack 和 React 小书 - gitbook https://fakefish.github.io/react-webpack-cookbook webpack https://github.com/webpack/webpack Webpack，101入门体验 http://html-js.com/article/3009 webpack入门教程 http://html-js.com/article/3113 基于webpack搭建前端工程解决方案探索 http://segmentfault.com/a/1190000003499526 React原创实战视频教程 http://www.piliyu.com vue vue 地址 Vue http://cn.vuejs.org Vue 论坛 http://forum.vuejs.org Vue 入门指南 http://www.cnblogs.com/aaronjs/p/3660102.html Vue 的一些资源索引 http://segmentfault.com/a/1190000000411057 awesome-vue https://github.com/vuejs/awesome-vue 移动端API 移动端API 地址 99移动端知识集合 https://github.com/jtyjty99999/mobileTech 移动端前端开发知识库 https://github.com/AlloyTeam/Mars 移动前端的一些坑和解决方法（外观表现） http://caibaojian.com/mobile-web-bug.html 【原】移动web资源整理 http://www.cnblogs.com/PeunZhang/p/3407453.html zepto 1.0 中文手册 http://mweb.baidu.com/zeptoapi zepto 1.0 中文手册 http://www.html-5.cn/Manual/Zepto zepto 1.1.2 http://www.css88.com/doc/zeptojs_api zepto 中文注释 http://www.cnblogs.com/sky000/archive/2013/03/29/2988952.html jqmobile 手册 http://app-framework-software.intel.com/api.php 移动浏览器开发集合 https://github.com/maxzhang/maxzhang.github.com/issues 移动开发大杂烩 https://github.com/hoosin/mobile-web-favorites jQuery jQuery 地址 jQuery API 中文文档 http://www.jquery123.com hemin 在线版 http://hemin.cn/jq css88 jq api http://www.css88.com/jqapi-1.9/on css88 jqui api http://www.css88.com/jquery-ui-api 学习jquery http://learn.jquery.com jquery 源码查找 http://james.padolsey.com/jquery Web前端资源汇总(jQuery,Js,Css3等) http://www.cnblogs.com/jihua/p/webfront.html D3 D3 地址 d3 Tutorials https://github.com/mbostock/d3/wiki/Tutorials Gallery https://github.com/mbostock/d3/wiki/Gallery lofter http://datavisual.lofter.com/post/40cf3a_188e535 iteye http://alanland.iteye.com/blog/1878595 ruanyifeng http://javascript.ruanyifeng.com/library/d3.html Requriejs Requriejs 地址 Javascript模块化编程（一）：模块的写法 http://www.ruanyifeng.com/blog/2012/10/javascript_module.html Javascript模块化编程（二）：AMD规范 http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html Javascript模块化编程（三）：require.js的用法 http://www.ruanyifeng.com/blog/2012/11/require_js.html RequireJS入门（一） http://www.cnblogs.com/snandy/archive/2012/05/22/2513652.html RequireJS入门（二） http://www.cnblogs.com/snandy/archive/2012/05/23/2513712.html RequireJS进阶（三） http://www.cnblogs.com/snandy/archive/2012/06/08/2538001.html requrie源码学习 http://www.cnblogs.com/yexiaochai/p/3632580.html requrie 入门指南 http://www.oschina.net/translate/getting-started-with-the-requirejs-library requrieJS 学习笔记 http://www.cnblogs.com/yexiaochai/p/3214926.html requriejs 其一 http://cyj.me/why-seajs/requirejs/ require backbone结合 http://www.cnblogs.com/yexiaochai/p/3221081.html Seajs Seajs 地址 seajs http://seajs.org seajs 中文手册 http://cyj.me/why-seajs/zh Less,sass Less,sass 地址 sass http://www.w3cplus.com/sassguide sass教程-sass中国 http://www.sass.hk Sass 中文文档 http://sass.bootcss.com less http://less.bootcss.com Markdown Markdown 地址 Markdown 语法说明 (简体中文版 http://wowubuntu.com/markdown markdown入门参考 https://github.com/LearnShare/Learning-Markdown/blob/master/README.md gitbook https://www.gitbook.com 国外的在线markdown可编辑成书 mdeditor https://www.zybuluo.com/mdeditor 一款国内的在线markdown编辑器 stackedit https://stackedit.io 国外的在线markdown编辑器，功能强大，同步云盘 mditor http://bh-lay.github.io/mditor 一款轻量级的markdown编辑器 lepture-editor https://github.com/lepture/editor markdown-editor https://github.com/jbt/markdown-editor 作业部落 https://www.zybuluo.com 功能强大，速度流畅，全平台同步 兼容性 兼容性 地址 esma 兼容列表 http://kangax.github.io/compat-table/es6 W3C CSS验证服务 http://jigsaw.w3.org/css-validator/validator.html.zh-cn caniuse http://caniuse.com/#index csscreator http://csscreator.com/properties microsoft https://msdn.microsoft.com/zh-cn/library/cc351024(v=vs.85.aspx 在线测兼容-移动端 http://www.responsinator.com emulators https://www.manymo.com/emulators UI相关 UI相关 地址 bootcss http://v3.bootcss.com MetroUICSS http://www.w3cplus.com/MetroUICSS semantic http://semantic-ui.com Buttons http://alexwolfe.github.io/Buttons kitecss http://hiloki.github.io/kitecss pintuer http://www.pintuer.com amazeui http://amazeui.org worldhello http://www.worldhello.net/gotgithub/index.html linuxtoy http://igit.linuxtoy.org/contents.html gitmagic http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn rogerdudler http://rogerdudler.github.io/git-guide/index.zh.html gitref http://gitref.justjavac.com book http://git-scm.com/book/zh gogojimmy http://gogojimmy.net/2012/01/17/how-to-use-git-1-git-basic 其它API 其它API 地址 HTTP API 设计指南 http://segmentfault.com/bookmark/1230000002521721 javascript流行库汇总 javascriptoo 验证api http://niceue.com/validator/demo/index.php underscore 中文手册 http://www.css88.com/doc/underscore underscore源码分析 http://www.html-js.com/article/Underscorejs-source-code-analysis-of-underscorejs-source-code-analysis%203031 underscore源码分析-亚里士朱德的博客 http://yalishizhude.github.io/tags/underscore underscrejs en api http://underscorejs.org lodash - underscore的代替品 https://lodash.com ext4api http://extjs-doc-cn.github.io/ext4api backbone 中文手册 http://www.csser.com/tools/backbone/backbone.js.html qwrap手册 http://dev.qwrap.com/resource/js/_docs/_youa/#/qw/base/loadJs_.htm 缓动函数 http://easings.net/zh-cn svg 中文参考 http://www.w3school.com.cn/svg/svg_reference.asp svg mdn参考 https://developer.mozilla.org/en-US/docs/Web/SVG svg 导出 canvas https://github.com/gabelerner/canvg svg 导出 png https://github.com/exupero/saveSvgAsPng ai-to-svg http://www.zamzar.com/convert/ai-to-svg localStorage 库 https://github.com/machao/localStorage 图表类 图表类 地址 Highcharts 中文API http://www.hcharts.cn/api/index.php Highcharts 英文API http://api.highcharts.com/highcharts ECharts 百度的图表软件 http://echarts.baidu.com/ 高德地图 http://lbs.amap.com/api 开源的矢量图脚本框架 http://paperjs.org svg 地图 http://jvectormap.com 正则 正则 地址 JS正则表达式元字符 http://segmentfault.com/a/1190000002471140 正则表达式30分钟入门教程 http://deerchao.net/tutorials/regex/regex.htm MDN-正则表达式 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions ruanyifeng - RegExp对象 http://javascript.ruanyifeng.com/stdlib/regexp.html 小胡子哥 - 进阶正则表达式 http://div.io/topic/764?page=1 is.js https://github.com/Cedriking/is.js/blob/master/is.js 正则在线测试 http://regexper.com 前端规范 前端规范 地址 通过分析github代码库总结出来的工程师代码书写习惯 http://alloyteam.github.io/CodeGuide HTML&amp;CSS编码规范 by @mdo http://codeguide.bootcss.com 团队合作的css命名规范-腾讯AlloyTeam前端团队 http://www.alloyteam.com/2011/10/css-on-team-naming/ 前端编码规范之js - by yuwenhui http://yuwenhui.github.io 前端编码规范之js - by 李靖 http://www.cnblogs.com/hustskyking/p/javascript-spec.html 前端开发规范手册 http://zhibimo.com/read/Ashu/front-end-style-guide Airbnb JavaScript 编码规范（简体中文版） https://github.com/yuche/javascript#table-of-contents AMD与CMD规范的区别 http://www.zhihu.com/question/20351507 AMD与CMD规范的区别 http://www.cnblogs.com/tugenhua0707/p/3507957.html KISSY 源码规范 http://docs.kissyui.com/1.4/docs/html/tutorials/style-guide/kissy-source-style.html bt编码规范 http://codeguide.bootcss.com 规范加强版 https://github.com/Suxiaogang/Code_Guide 前端代码规范 及 最佳实践 http://blog.jobbole.com/79075 百度前端规范 http://coderlmn.github.io/code-standards 百度前端规范 http://isobar-idev.github.io/code-standards 百度前端规范 http://zhuanlan.zhihu.com/fuyun/19884834 ECMAScript6 编码规范–广发证券前端团队 https://github.com/gf-rd/es6-coding-style JavaScript 风格指南/编码规范（Airbnb公司版） http://blog.jobbole.com/79484 网易前端开发规范 http://nec.netease.com/standard css模块 http://www.75team.com/archives/1049 前端规范资源列表 https://github.com/ecomfe/spec PHP PHP 地址 最流行的PHP 代码规范 http://segmentfault.com/a/1190000000443795 最流行的PHP 代码规范 https://github.com/hfcorriez/fig-standards/blob/zh_CN/%E6%8E%A5%E5%8F%97/PSR-2-coding-style-guide.md 各大公司开源项目 各大公司开源项目 地址 Facebook Projects https://code.facebook.com/projects/web 百度web前端研发部 http://fex.baidu.com 百度EFE http://efe.baidu.com 百度github https://github.com/fex-team alloyteam http://www.alloyteam.com alloyteam-github http://alloyteam.github.io alloyteam-AlloyGameEngine https://github.com/AlloyTeam/AlloyGameEngine AlloyDesigner http://alloyteam.github.io/AlloyDesigner 即时修改，即时保存，设计稿较正，其它开发辅助工具 H5交互页编辑器AEditor介绍 http://www.alloyteam.com/2015/06/h5-jiao-hu-ye-bian-ji-qi-aeditor-jie-shao H5动画交互页开发的工具介绍 AEditor http://aeditor.alloyteam.com H5动画交互页开发的工具 maka http://forum.maka.im/wordpress 值得订阅的weekly https://github.com/fenbility/weekly-feed 腾讯html5 http://cube.qq.com 奇舞团开源项目 http://75team.github.io Qunar UED http://ued.qunar.com Scrat http://scrat.io 常用 常用 地址 ieBetter.js-让IE6-IE8拥有IE9+,Chrome等浏览器特性 http://www.zhangxinxu.com/wordpress/2013/12/iebetter-js-make-ie6-ie8-like-modern-browser-ie9-chrome 模拟键盘 http://mottie.github.io/Keyboard 拼音 https://github.com/hotoo/pinyin 中国个人身份证号验证 https://github.com/mc-zone/IDValidator 算法 算法 地址 数据结构与算法 JavaScript 描述. 章节练习 https://github.com/Ralph-Wang/algorithm.in.js 常见排序算法（JS版） https://github.com/twobin/twobinSort 经典排序 https://github.com/luofei2011/jsAgm/blob/master/js/sort.js 常见排序算法-js版本 https://github.com/hechangmin/jssort JavaScript 算法与数据结构 精华集 https://github.com/lightningtgc/JavaScript-Algorithms 面试常考算法题精讲 http://www.nowcoder.com/live/courses 移动端 移动端 地址 fastclick https://github.com/ftlabs/fastclick no-click-delay https://github.com/mmastrac/jquery-noclickdelay 【敏捷开发】Android团队开发规范 http://www.cnblogs.com/lcw/p/3619181.html Android 开发规范与应用 http://www.jianshu.com/p/4390f4fe19b3 ionic https://github.com/ychow/ionic-guide JSON JSON 地址 模拟生成JSON数据 http://beta.json-generator.com 返回跨域JSONAPI http://jsonp.afeld.me 焦点图 焦点图 地址 myfocus https://github.com/koen301/myfocus myfocus-官方演示站 http://www.chhua.com/myfocus SuperSlidev2.1 – 大话主席 http://www.superslide2.com soChange http://www.bujichong.com/sojs/soChange/index.html Ext, EasyUI, J-UI 及其它各种UI方案 Ext, EasyUI, J-UI 及其它各种UI方案 地址 extjs https://www.sencha.com/products/extjs ext4英文api http://docs.sencha.com/extjs/4.0.7 ext4中文api http://extjs-doc-cn.github.io/ext4api jquery easyui 未压缩源代码 http://jquery-easyui.googlecode.com/svn/trunk/src J-UI http://jui.org MUI-最接近原生APP体验的高性能前端框架 http://dcloudio.github.io/mui Amaze UI 中国首个开源 HTML5 跨屏前端框架 http://amazeui.org 淘宝 HTML5 前端框架 http://m.sui.taobao.org KISSY - 阿里前端JavaScript库 http://docs.kissyui.com 网易Nej - Nice Easy Javascript http://nej.netease.com Kendo UI MVVM Demo http://demos.telerik.com/kendo-ui/mvvm/index Bootstrap http://www.bootcss.com Smart UI http://smartui.chinamzz.com 雅虎UI - CSS UI http://developer.yahoo.com/yui/grids 页面 社会化 分享功能 页面 社会化 分享功能 地址 百度分享 http://share.baidu.com pc端 JiaThis http://jiathis.com pc端 社会化分享组件 http://developer.baidu.com/soc/share 移动端 ShareSDK 轻松实现社会化功能 http://www.mob.com/#/index 移动端 友盟分享 http://dev.umeng.com/social/android/quick-integration 移动端 富文本编辑器 富文本编辑器 地址 功能齐全 tinymce https://www.tinymce.com 百度 ueditor http://ueditor.baidu.com/website 经典的ckeditor http://ckeditor.com 经典的kindeditor http://kindeditor.net wysiwyg http://www.bootcss.com/p/bootstrap-wysiwyg 一个有情怀的编辑器。Bach’s Editor http://integ.github.io/BachEditor tower用的编辑器 https://github.com/mycolorway/simditor summernote 编辑器 https://github.com/summernote/summernote html5编辑器 http://neilj.github.io/Squire Quilljs编辑器 http://quilljs.com XEditor http://lab.hustlzp.com/XEditor wangEditor https://github.com/wangfupeng1988/wangEditor 前端概述 前端概述 地址 前端工具大全 http://www.awesomes.cn 什么是前端工程化 https://github.com/fouber/blog/issues/10?from=timeline&amp;isappinstalled=0# [译] 前端攻略-从路人甲到英雄无敌 https://segmentfault.com/a/1190000005174755 Gulp Gulp 地址 Gulp官网 http://gulpjs.com Gulp中文网 http://www.gulpjs.com.cn gulp资料收集 https://github.com/Platform-CUF/use-gulp Gulp：任务自动管理工具 - ruanyifeng http://javascript.ruanyifeng.com/tool/gulp.html Gulp插件 http://gulpjs.com/plugins Gulp探究折腾之路(I) http://www.jeffjade.com/2015/11/25/2015-11-25-toss-gulp/ Gulp折腾之路(II) http://www.jeffjade.com/2016/01/19/2016-01-19-toss-gulp/ Gulp不完全入门教程 http://www.ido321.com/1622.html 为什么使用gulp? https://github.com/hjzheng/CUF_meeting_knowledge_share/issues/33 Gulp安装及配合组件构建前端开发一体化 http://www.dbpoo.com/getting-started-with-gulp Gulp 入门指南 https://github.com/nimojs/gulp-book Gulp 入门指南 - nimojs https://github.com/nimojs/blog/issues/19 Gulp in Action http://www.imooc.com/video/5692 Gulp开发教程（翻译） http://www.w3ctech.com/topic/134 前端构建工具gulpjs的使用介绍及技巧 http://www.cnblogs.com/2050/p/4198792.html Grunt Grunt 地址 gruntjs http://gruntjs.com Grunt中文网 http://www.gruntjs.net Fis Fis 地址 fis 官网 http://fex-team.github.io/fis-site/index.html fis http://fis.baidu.com pc图轮 pc图轮 地址 单屏轮播sochange http://www.jsfoot.com/jquery/demo/2011-09-20/192.html 左右按钮多图切换 http://bxslider.com/examples/carousel-demystified fullpage全屏轮播 https://github.com/alvarotrigo/fullPage.js 移动端图轮 移动端图轮 地址 无缝切换 http://www.swipejs.com 滑屏效果 http://www.idangero.us/swiper 全屏fullpage https://github.com/peunzhang/fullpage 单个图片切换 https://github.com/qiqiboy/touchslider 单个全屏切换 https://github.com/peunzhang/slip.js 百度的切换库 http://touch.code.baidu.com/examples.html?qq-pf-to=pcqq.group 单个全屏切换 https://github.com/peunzhang/iSlider 滑屏效果 https://github.com/saw/touch-interfaces 旋转拖动设置 http://baijs.com/tinycircleslider 类似于swipe切换 http://touchslider.com 支持多种形式的触摸滑动 http://www.swiper.com.cn/demo/index.html 滑屏效果 https://github.com/joker-ye/main/blob/master/wap/index.html 大话主席pc移动图片轮换 http://www.superslide2.com 滑屏效果 https://github.com/hahnzhu/parallax.js 基于zepto的fullpage https://github.com/yanhaijing/zepto.fullpage [WebApp]定宽网页设计下，固定宽度布局开发WebApp并实现多终端下WebApp布局自适应 http://www.cnblogs.com/plums/archive/2013/01/10/WebApp-fixed-width-layout-of-multi-terminal-adapter-since.html 判断微信客户端的那些坑 http://loo2k.com/blog/detecting-wechat-client 可以通过javascript直接调用原生分享的工具 https://github.com/JefferyWang/nativeShare.js JiaThis 分享到微信代码 http://www.jiathis.com/help/html/weixin-share-code 聊聊移动端跨平台开发的各种技术 http://fex.baidu.com/blog/2015/05/cross-mobile 前端自动化测试 http://www.zhihu.com/question/29922082 多种轮换图片 http://ajccom.github.io/niceslider 滑动侧边栏 https://mango.github.io/slideout 文件上传 文件上传 地址 百度上传组件 http://fex.baidu.com/webuploader 上传 https://blueimp.github.io/jQuery-File-Upload flash 头像上传 http://www.hdfu.net 图片上传预览 http://www.dropzonejs.com 图片裁剪 http://elemefe.github.io/image-cropper 图片裁剪-shearphoto http://www.shearphoto.com jQuery图片处理 http://www.oschina.net/project/tag/284/jquery-image-tools?lang=0&amp;os=0&amp;sort=view&amp;p=2 模拟select 模拟select 地址 糖饼 select http://aui.github.io/popupjs/doc/selectbox.html flexselect https://github.com/rmm5t/jquery-flexselect 双select http://loudev.com select2 http://select2.github.io 取色插件 取色插件 地址 类似 Photoshop 的界面取色插件 http://www.jq22.com/plugin/367 jquery color https://github.com/jquery/jquery-color 取色插件集合 http://www.oschina.net/project/tag/287/color-picker farbtastic 圆环＋正方形 https://github.com/mattfarina/farbtastic 城市联动 城市联动 地址 jquery.cityselect.js基于jQuery+JSON的省市或自定义联动效果 http://www.ijquery.cn/?p=360 剪贴板 剪贴板 地址 剪贴板 https://github.com/zeroclipboard/zeroclipboard clipboard 最新的剪切方案 http://zenorocha.github.io/clipboard.js 不是Flash的剪贴板 https://github.com/zenorocha/clipboard.js 简繁转换 简繁转换 地址 简繁转换 https://github.com/BYVoid/OpenCC 表格 Grid 表格 Grid 地址 facebook表格 http://facebook.github.io/fixed-data-table 类似于Excel编辑表格-handsontable http://handsontable.com bootstrap-table插件 http://bootstrap-table.wenzhixin.net.cn datatables https://www.datatables.net 在线演示 在线演示 地址 js 在线编辑 - runjs http://runjs.cn js 在线编辑 - jsbin http://jsbin.com js 在线编辑 - codepen http://codepen.io js 在线编辑 - jsfiddle http://jsfiddle.net java 在线编辑 - runjs http://ideone.com js 在线编辑 - hcharts http://code.hcharts.cn js 在线编辑 - jsdm http://jsdm.com sql 在线编辑 - sqlfiddle http://sqlfiddle.com mozilla 在线编辑器 https://thimble.mozilla.org 常规优化 常规优化 地址 Javascript高性能动画与页面渲染 http://www.infoq.com/cn/articles/javascript-high-performance-animation-and-page-rendering 移动H5前端性能优化指南 http://isux.tencent.com/h5-performance.html 5173首页前端性能优化实践 http://ued.5173.com/?p=1731 给网页设计师和前端开发者看的前端性能优化 http://www.uisdc.com/front-end-performance-for-web-designers-and-front-end-developers 复杂应用的 CSS 性能分析和优化建议 http://www.orzpoint.com/profiling-css-and-optimization-notes 张鑫旭——前端性能 张鑫旭——前端性能 前端性能监控总结 http://www.xiaoqiang.org/javascript/font-end-performance-monitor.html 网站性能优化之CSS无图片技术 网站性能优化之CSS无图片技术 web前端性能优化进阶路 web前端性能优化进阶路 前端技术：网站性能优化之CSS无图片技术 http://my.eoe.cn/tuwandou/archive/4544.html 浏览器的加载与页面性能优化 http://www.baiduux.com/blog/2011/02/15/browser-loading 页面加载中的图片性能优化 http://www.w3ctech.com/p/1503 Hey——前端性能 Hey——前端性能 html优化 html优化 99css——性能 99css——性能 Yslow——性能优化 http://www.yslow.net/category.php?cid=20 YSLOW中文介绍 http://www.cnblogs.com/yslow 转一篇Yahoo关于网站性能优化的文章，兼谈本站要做的优化 http://www.360ito.com/article/40.html Yahoo!团队实践分享：网站性能 http://www.360doc.com/content/10/0928/09/2588264_56971287.shtml 网站性能优化指南：什么使我们的网站变慢？ http://blog.jiasule.com/i/153 网站性能优化实践，减少加载时间，提高用户体验 http://www.powereasy.net/helpyou/knowledge/ecommerce/9593.html 浅谈网站性能优化 前端篇 http://www.umtry.com/archives/747.html 前端重构实践之如何对网站性能优化？ http://www.adinnet.cn/blog/designview/2012-7-12/678.html 前端性能优化：使用媒体查询加载指定大小的背景图片 http://www.gbin1.com/technology/javascript/20130708-front-end-performance-optimization-9 网站性能系列博文 http://www.mykuer.com/post/factors-that-affect-the-speed-of-web-site-open.html 加载，不只是少一点点 http://tgideas.qq.com/webplat/info/news_version3/804/808/811/m579/201109/41355.shtml 前端性能的测试与优化 http://mzhou.me/article/95310 分享网页加载速度优化的一些技巧？ http://www.gbin1.com/technology/html/20130217-tips-for-speed-up-page-loading 页面加载中的图片性能优化 http://www.f2es.com/images-bytes-opt web前端优化(基于Yslow http://www.tcreator.info/webSchool/website/Front-end-Opt-Yslow.html 网站性能优化工具大全 https://www.qianduan.net/website-performance-optimization-tool.html 【高性能前端1】高性能HTML http://www.alloyteam.com/2012/10/high-performance-html 【高性能前端2】高性能CSS http://www.alloyteam.com/2012/10/high-performance-css 由12306谈谈网站前端性能和后端性能优化 http://coolshell.cn/articles/6470.html AlloyTeam——前端优化 AlloyTeam——前端优化 毫秒必争，前端网页性能最佳实践 http://www.cnblogs.com/developersupport/p/3248695.html 网站性能工具Yslow的使用方法 http://blog.sina.com.cn/s/blog_6e9d2e0701017kvu.html 前端工程与性能优化（上）：静态资源版本更新与缓存 http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part1 前端工程与性能优化（下）：静态资源管理与模板框架 http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part2 HTTPS连接的前几毫秒发生了什么 http://blog.jobbole.com/48369 Yslow http://uicss.cn/yslow/#more-12319 Essential Web Performance Metrics — A Primer, Part 1 http://blog.smartbear.com/web-performance/essential-web-performance-metrics-a-primer-part-1 Essential Web Performance Metrics — Part 2 http://blog.smartbear.com/performance/essential-web-performance-metrics-part-2 YUISlide,针对移动设备的动画性能优化 http://jayli.github.io/blog/data/2011/12/23/yuislide.html Improving Site Performance http://joelglovier.com/improving-site-performance 让网站提速的最佳前端实践 http://segmentfault.com/a/1190000000367899 Why Website Speed is Important http://sixrevisions.com/web-development/why-website-speed-is-important Need for Speed – How to Improve your Website Performance https://www.devbridge.com/articles/need-for-speed-how-to-improve-your-website-performance 阿里无线前端性能优化指南 (Pt.1 加载期优化 https://github.com/amfe/article/issues/1 优化工具 优化工具 地址 JavaScript 性能分析新工具 OneProfile http://www.html-js.com/article/3083 JavaScript 堆内存分析新工具 OneHeap http://www.html-js.com/article/3091 在线工具 在线工具 地址 google在线工具 https://developers.google.com/speed/pagespeed/insights 阿里测 http://www.alibench.com 阿里-免费测试服务 http://itest.aliyun.com 阿里-F2etest多浏览器兼容性测试解决方案 https://github.com/alibaba/f2etest js性能测试 http://jsperf.com 前端架构 前端架构 地址 技术架构 http://www.zhihu.com/topic/19612641 前端架构 http://saito.im/note/The-Architecture-of-F2E 如何成为前端架构师 http://www.zhihu.com/question/24092572 关于前端架构-张克军 http://hikejun.com/sharing/2010webrebuild/?file=fe-infrastructure.html 百度腾讯offer比较（腾讯游戏VS百度基础架构） http://www.zhihu.com/question/25583350 推荐作品 推荐作品 地址 winter代码片段需要翻墙 https://gist.github.com/wintercn fgm http://www.fgm.cc/learn 岑安作品集 https://github.com/hongru/hongru.github.com 当耐特demo集合 http://kmdjs.github.io 米空格 js作品 http://www.laoshu133.com/Lab myFocus http://koen301.github.io SeaJS组件库 http://panxuepeng.github.io/seajslib 颜海镜作品 http://yanhaijing.com/myProject 脚儿网作品 http://jo2.org/category/myworks javascript个人作品 http://www.cnitblog.com/yemoo/category/3107.html 妙味的雷东升游戏作品 http://bbs.miaov.com/forum.php?mod=viewthread&amp;tid=7790 javascript作品集 http://bbs.csdn.net/topics/380227212 云五笔，灰度产生生成工具 https://github.com/TooBug/works 项目主页 http://koen301.github.io 个性的作品主页 http://zaole.net 播放器 http://static.tingall.com/v2/player ucren js demos 集 http://ucren.com/blog/demos 智能社 http://www.zhinengshe.com/works_list.html 实例陈列架 http://demos.shizuwu.cn zoye demo http://zoye.sinaapp.com/demo 王员外 http://lab.yuanwai.wang 平凡 http://pingfan1990.sinaapp.com jyg 游戏案例 http://www.lovewebgames.com 很多jquery插件 http://www.helloweba.com/list.html 不羁虫 - soJs 作品系列 http://www.bujichong.com/sojs/api/index.html frozenui http://frozenui.github.io/case.html 黑白棋 http://js-game.github.io/othello fromone http://yansm.github.io/fromone/index.html pazguille http://pazguille.me Html5 VideoPlayer https://github.com/zmmbreeze/DeadSimpleVideoPlayer Proton 烟花 http://a-jie.github.io/Proton/#example 简历模板 简历模板 地址 简历 http://hcy2367.github.io/resume 张伦 http://ncuey.sinaapp.com/CrispElite/ 简历 https://github.com/hacke2/ResumeSample 马斯特 http://pinkyjie.com/resume 张秋怡 https://joyeecheung.github.io/resume/ 翁天信 http://blog.dandyweng.com/2013/07/how-my-website-was-created 动画方式的简历 http://www.webhek.com/misc/interactive-resume 组件丰富简历 http://www.linqing07.com/resume.html haorooms博客 http://www.haorooms.com/about 面试题 面试题 地址 那几个月在找工作（百度，网易游戏） http://www.nowcoder.com/discuss/3196 2014最新面试题 http://www.html-js.com/article/1743 2016校招内推 – 阿里巴巴前端 – 三面面试经历 http://www.cnblogs.com/imwtr/p/4685546.html 年后跳槽那点事：乐视+金山+360面试之行 http://www.cnblogs.com/lvdabao/p/3660707.html Interviewing a front-end developer http://blog.sourcing.io/interview-questions 拉勾网js面试题 http://www.cnblogs.com/52cik/p/js-question-lg.html 前端面试 http://www.cnblogs.com/allenxing/p/3724382.html Web开发笔试面试题 大全 http://mianshiti.diandian.com 前端开发面试题 http://segmentfault.com/a/1190000000465431 2014最新前端面试题 https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions 百度面试 https://github.com/fex-team/interview-questions 面试题 http://www.w3cfuns.com/forum.php?mod=forumdisplay&amp;fid=51&amp;filter=typeid&amp;typeid=177 前端工作面试问题 https://github.com/darcyclarke/Front-end-Developer-Interview-Questions/tree/master/Chinese 前端开发面试题 http://segmentfault.com/a/1190000000465431 5个经典的前端面试问题 5个经典的前端面试问题 最全前端面试问题及答案总结 http://segmentfault.com/a/1190000002562454 如何面试一名前端开发工程师？ http://www.html-js.com/article/Large-search-front-team-column%202961 史上最全 前端开发面试问题及答案整理 https://github.com/hawx1993/Front-end-Interview-questions 前端实习生面试总结 http://www.cnblogs.com/xiaoruo/p/4665163.html 史上最全 前端开发面试问题及答案整理 https://github.com/hawx1993/Front-end-Interview-questions BAT及各大互联网公司2014前端笔试面试题：JavaScript篇 http://blog.jobbole.com/78738 前端开发面试题大收集 https://github.com/paddingme/Front-end-Web-Development-Interview-Question 收集的前端面试题和答案 https://github.com/qiu-deqing/FE-interview 如何面试前端工程师 http://www.zhihu.com/question/19568008 前端开发面试题 https://github.com/markyun/My-blog/blob/master/Front-end-Developer-Questions/Questions-and-Answers/README.md 牛客网-笔试面经 http://www.nowcoder.com/discuss?type=2 iconfont iconfont 地址 中文字体 http://www.zhihu.com/question/21253343 淘宝字库 http://iconfont.cn 字体 http://mux.alimama.com/fonts 制作教程 http://iconfont.cn/help/platform.html zhangxinxu-icommon http://www.zhangxinxu.com/wordpress/?s=icomoon icommon https://icomoon.io/app 用字体在网页中画ICON图标(推荐教程 http://imooc.com/learn/243 字体压缩工具 http://font-spider.org Fiddler Fiddler 地址 Fiddler调式使用知多少(一深入研究 http://www.cnblogs.com/tugenhua0707/p/4623317.html 微信fiddle http://www.cnblogs.com/strick/p/4570006.html 微信fiddle http://gaoboy.com/article/26.html Chrome Chrome 地址 Google Chrome 官方 https://developer.chrome.com/devtools Chrome - 基础 http://www.cnblogs.com/constantince/p/4565261.html Chrome - 进阶 http://www.cnblogs.com/constantince/p/4579121.html Chrome - 性能 http://www.cnblogs.com/constantince/p/4585983.html Chrome - 性能进阶 http://www.cnblogs.com/constantince/p/4607497.html Chrome - 移动 http://www.cnblogs.com/constantince/p/4624241.html Chrome - 使用技巧 http://www.cnblogs.com/liyunhua/p/4544738.html Chrome - Console控制台不完全指南 http://www.cnblogs.com/Wayou/p/chrome-console-tips-and-tricks.html Chrome - Workspace使浏览器变成IDE http://c7sky.com/chrome-devtools-workspace.html network面板 http://www.html-js.com/article/Nothing-blind%202975 chrome开发工具快捷键 http://anti-code.com/devtools-cheatsheet chrome调试工具常用功能整理 http://www.html-js.com/article/2327 Chrome 开发工具 Workspace 使用 http://www.iinterest.net/2014/05/09/chrome-dev-tool-workspace Chrome神器Vimium快捷键学习记录 http://www.cppblog.com/deercoder/archive/2011/10/22/158886.html sass调试-w3cplus http://www.w3cplus.com/sassguide/debug.html 如何更专业的使用Chrome开发者工具-w3cplus http://www.w3cplus.com/tools/how-to-use-chrome-devtools-like-a-pro.html chrome调试canvas http://sentsin.com/web/253.html chrome profiles1 https://developer.chrome.com/devtools/index chrome profiles2 http://h5dev.uc.cn/article-25-1.html chrome profiles3 http://www.oschina.net/translate/performance-optimisation-with-timeline-profiles chrome移动版调试 https://developer.chrome.com/devtools/docs/mobile-emulation chrome调试 http://ued.taobao.org/blog/2012/06/debug-with-chrome-dev-tool chrome的调试 http://www.cnblogs.com/QLeelulu/archive/2011/08/28/2156402.html chrome console 命令详解 https://developer.chrome.com/devtools/docs/commandline-api 查看事件绑定1 http://www.cnblogs.com/leonkao/p/3809655.html 查看事件绑定2 http://www.cnblogs.com/xiaoyao2011/p/3447421.html 神器——Chrome开发者工具(一 http://segmentfault.com/a/1190000000683599 奇趣百科性能优化(Chrome DevTools 中的 Timeline Profils 等工具使用介绍 https://xinranliu.me/2015-05-22-qiqu-performance chrome 开发者工具的 15 个小技巧 http://frontenddev.org/link/15-tips-of-chrome-developer-tools.html Chrome开发者工具不完全指南 http://1ke.co/course/361 Chrome 开发者工具使用技巧 http://segmentfault.com/a/1190000003882567 Firebug Firebug 地址 firebug视频教程 http://www.imooc.com/learn/137 firefox 模拟器 https://developer.mozilla.org/zh-CN/docs/Tools/WebIDE console.log 命令详解 http://www.cnblogs.com/ctriphire/p/4116207.html Firebug入门指南 http://www.ruanyifeng.com/blog/2008/06/firebug_tutorial.html Firebug控制台详解 http://www.ruanyifeng.com/blog/2011/03/firebug_console_tutorial.html 移动,微信调试 移动,微信调试 地址 浏览器端调试安卓 https://openstf.github.io 移动端前端开发调试 http://yujiangshui.com/multidevice-frontend-debug 使用 Chrome 远程调试 Android 设备 https://github.com/yujiangshui/CN-Chrome-DevTools/blob/remote-debugging/md/Use-Tools/remote-debugging.md mac移动端调试 http://plus.uc.cn/document/webapp/doc5.html mac移动端调试 http://www.mihtool.com 无线调试攻略 http://thx.github.io/mobile/debugging-in-mobile 无线调试攻略 http://yanhaijing.com/mobile/2014/12/17/web-debug-for-mobile 屌爆了,完美调试 微信webview(x5 http://www.jianshu.com/p/ccf124f1f74b 微信调试的那些事 微信调试的那些事 远程console http://jsconsole.com 微信调试工具 http://blog.qqbrowser.cc 各种真机远程调试方法汇总 https://github.com/jieyou/remote_inspect_web_on_real_device iOS Simulator iOS Simulator 地址 Simulator iOS_Simulator_Guide-Introduction iOS Simulator的介绍和使用心得 http://www.crifan.com/intro_ios_simulator_in_xcode_and_usage_summary Image img 地址 loading img http://preloaders.net/en/circular 智图-图片优化平台 http://zhitu.isux.us 在线png优化 https://tinypng.com SM.MS(图床工具～简易好用) https://sm.ms/ yutuku：极简图床 http://yotuku.cn/ Qchan图床 http://tuchuang.org/ 浏览器同步 浏览器同步 地址 puer https://github.com/leeluolee/puer liveReload http://livereload.com f5 http://getf5.com File Watchers http://geek100.com/2608 在线PPT制作 在线PPT制作 地址 nodePPT nodePPT Cleaver快速制作网页PPT http://www.jeffjade.com/2015/10/15/2015-10-16-cleaver-make-ppt/ impress.js http://www.cnblogs.com/Darren_code/archive/2013/01/04/impressjs.html PPT https://github.com/ksky521/nodePPT reveal https://github.com/hakimel/reveal.js bespoke-fx https://github.com/ebow/bespoke-fx slippy https://github.com/Seldaek/slippy 前端导航网站 前端导航网站 地址 界面清爽的前端导航 http://uxbees.com/index.html 前端导航 http://whycss.com 前端网址导航 http://www.daqianduan.com/nav 前端名录 http://sentsin.com/daohang 前端导航 http://123.jser.us 前端开发资源 http://www.css88.com/nav 网址导航 http://www.haourl.cn 前端开发仓库 - 众多效果的收集地 http://code.ciaoca.com 前端资源导航 https://github.com/jnoodle/f2e-collect F2E 前端导航 http://f2e.im/static/pages/nav/index.html 常用CDN 常用CDN 地址 新浪CDN http://lib.sinaapp.com 百度静态资源公共库 http://cdn.code.baidu.com 360网站卫士常用前端公共库CDN服务 http://libs.useso.com Bootstrap中文网开源项目免费 CDN 服务 http://www.bootcdn.cn 开放静态文件 CDN - 七牛 http://staticfile.org CDN加速 - jq22 http://www.jq22.com/cdn jQuery CDN http://code.jquery.com Google jQuery CDN http://www.google-jquery-cdn.com 微软CDN http://www.asp.net/ajax/cdn Git Git 地址 git-scm http://git-scm.com 廖雪峰-Git教程 廖雪峰-Git教程 git-for-windows https://git-for-windows.github.io GitHub 添加 SSH keys http://daemon369.github.io/git/2015/03/10/add-ssh-keys-for-github gogithub http://www.worldhello.net/gotgithub/index.html git常规命令练习 http://pcottle.github.io/learnGitBranching git的资料整理 https://github.com/xirong/my-git 我所记录的git命令（非常实用） http://www.cnblogs.com/fanfan259/p/4810517.html 企业开发git工作流模式探索部分休整 https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md GitHub 漫游指南 https://github.com/phodal/github-roam GitHub秘籍 https://github.com/tiimgreen/github-cheat-sheet/blob/master/README.zh-cn.md 使用git和github进行协同开发流程 http://livoras.com/post/28 动画方式练习git http://onlywei.github.io/explain-git-with-d3 各种日期日历 各种日期日历 地址 经典my97 http://www.my97.net/dp/demo/index.htm 强大的独立日期选择器 http://www.cnblogs.com/gbin1/archive/2012/04/16/2452105.html fullcalendar http://fullcalendar.io fullcalendar日历控件知识点集合 http://blog.csdn.net/francislaw/article/details/7740630 中文api http://blog.sina.com.cn/s/blog_9475b1c101012c5f.html 农历日历 https://github.com/zzyss86/LunarCalendar 超酷的仿百度带节日日历老黄历控件 http://www.sucaisj.com/jiaoben/date/201509/16856.html 日期格式化 http://momentjs.com 大牛日历控件 https://github.com/Johnqing/QPAYCalendar 我群某管理作品 https://github.com/Iamlars/dateMarker input按位替换-官网 http://digitalbush.com/projects/masked-input-plugin input按位替换-github https://github.com/digitalBush/jquery.maskedinput/tree/1.2.2 bootstrap-daterangepicker https://github.com/dangrossman/bootstrap-daterangepicker 国外30个插件集合 http://www.vandelaydesign.com/30-best-free-jquery-plugins JavaScript datepicker http://dbushell.com/2012/10/09/pikaday-javascript-datepicker Datepair.js http://jonthornton.github.io/Datepair.js 一个风格多样的日历 https://github.com/glad/glDatePicker 弹出层式的全日历 http://amsul.ca/pickadate.js/date jquery双日历 http://www.daterangepicker.com 大气实用jQuery手机移动端日历日期选择插件 http://www.frankdemo.cn/index.php?c=content&amp;a=show&amp;id=115 jQuery Mobile 移动开发中的日期插件Mobiscroll https://mobiscroll.com Date library Date library 地址 Datejs https://github.com/datejs/Datejs sugarjs http://sugarjs.com/api/Date 其它 其它 地址 Mock.js 是一款模拟数据生成器 http://mockjs.com 特色的HTML框架可以创建精美的iOS应用 http://framework7.taobao.org 淘宝SUI http://m.sui.taobao.org avalonjs http://avalonjs.github.io Avalon新一代UI库： OniUI http://ued.qunar.com/oniui/index.html avalon.oniui-基于avalon的组件库 https://github.com/RubyLouvre/avalon.oniui 生成二维码(草料) http://cli.im 效果类 效果类 地址 弹出层 http://www.imooc.com/learn/58 焦点图轮播特效 http://www.imooc.com/learn/18 HTML5 有哪些让你惊艳的 demo？ http://www.zhihu.com/question/24398907 弹出层 弹出层 地址 artDialog 最新版 https://github.com/aui/artDialog artDialog 文档 http://aui.github.io/artDialog/doc/index.html google code 下载地址 https://code.google.com/p/artdialog/downloads/list 贤心弹出层 http://layer.layui.com 响应式用户交互组件库 https://github.com/bh-lay/UI sweetalert-有css3动画弹出层 http://t4t5.github.io/sweetalert 优秀JavaScript项目 优秀JavaScript项目 地址 Angular和Webpack种子文件 https://github.com/AngularClass/angular2-webpack-starter Fis3面向前端的工程构建系统 https://github.com/fex-team/fis3 Fis3 DEMO https://github.com/fex-team/fis3-demo 前端JQuery系列:源码剖析 https://github.com/JsAaron/jQuery avalon框架 https://github.com/RubyLouvre/avalon Microsoft ChakraCore 微软的Chakra引擎 https://github.com/Microsoft/ChakraCore Quintus HTML游戏引擎 https://github.com/cykod/Quintus 一个用node.js搭建的有趣博客 https://github.com/STRML/strml.net Web前端助手–FeHelper（Chrome扩展） https://github.com/zxlie/FeHelper 百度前端技术学院 https://github.com/baidu-ife/ife Cheerio（node.js中的jQuery） https://github.com/cheeriojs/cheerio nodejs的一个聊天软件 类似微信 https://github.com/BryanYang/freechat 使用html5和node.js构建的网易云音乐 https://github.com/stkevintan/Cube babel ES6转换为ES5 https://github.com/babel/babel 一个JS富文本编辑器 https://github.com/fex-team/ueditor 一个JS脑图可视化工具 https://github.com/fex-team/kityminder-core 一个JS写的Flappy Bird Game https://github.com/ellisonleao/clumsy-bird 一个JS写的GBA模拟器 https://github.com/taisel/IodineGBA SegmentFault写的Markdown解析器 https://github.com/SegmentFault/HyperDown.js 基于node.js的Ghost博客 https://github.com/TryGhost/Ghost 学习react的demos https://github.com/ruanyf/react-demos]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ssh-add 执行出错]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2016%2F08%2F23%2Flinux%E5%AD%A6%E4%B9%A0-2016-08-23-ssh-add%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[作者: daodaoliang 版本: V 0.0.1 日期: 2016年8月23日 Could not open a connection to your authentication agenty 12若执行ssh-add /path/to/xxx 时出现这个错误:Could not open a connection to your authentication agent，则先执行如下命令即可：ssh-agent bash]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[wget命令学习]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2016%2F07%2F19%2Flinux%E5%AD%A6%E4%B9%A0-2015-01-28-wget%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[作者: daodaoliang 时间: 2016年7月19日 版本: 0.0.2 Wget 的使用 支持断点下传功能; 同时支持FTP和HTTP下载方式; 支持代理服务器; 设置方便简单; 程序小，完全免费; 命令格式： 1wget [参数列表] [目标软件、网页的网址] 123456wget -r -p -np -k http://xxx.com/xxx-r, --recursive（递归） specify recursive download.（指定递归下载）-k, --convert-links（转换链接） make links in downloaded HTML point to local files.（将下载的HTML页面中的链接转换为相对链接即本地链接）-p, --page-requisites（页面必需元素） get all images, etc. needed to display HTML page.（下载所有的图片等页面显示所需的内容）-np, --no-parent（不追溯至父级） don't ascend to the parent directory.另外断点续传用-nc参数 日志 用-o参数 1、启动类参数这一类参数主要提供软件的一些基本信息: -V,–version 显示软件版本号然后退出； -h,–help显示软件帮助信息； -e,–execute=COMMAND 执行一个 “.wgetrc”命令 以上每一个功能有长短两个参数，长短功能一样，都可以使用。需要注意的是，这里的-e参数是执行一个.wgettrc的命令，.wgettrc命令其实是一个参数列表，直接将软件需要的参数写在一起就可以了。 2、文件处理参数这类参数定义软件log文件的输出方式等； -o,–output-file=FILE 将软件输出信息保存到文件； -a,–append-output=FILE将软件输出信息追加到文件； -d,–debug显示输出信息； -q,–quiet 不显示输出信息； -i,–input-file=FILE 从文件中取得URL； 示例1： 12# 下载192.168.1.168首页并且显示下载信息wget -d http://192.168.1.168 示例2: 12# 下载 192.168.1.168首页并且不显示任何信息wget -q http://192.168.1.168 示例3: 12# 下载 filelist.txt中所包含的链接的所有文件wget -i filelist.txt 下载参数下载参数定义下载重复次数、保存文件名等； -t,–tries=NUMBER 是否下载次数（0表示无穷次） -O –output-document=FILE下载文件保存为别的文件名 -nc, –no-clobber 不要覆盖已经存在的文件 -N,–timestamping只下载比本地新的文件 -T,–timeout=SECONDS 设置超时时间 -Y,–proxy=on/off 关闭代理 示例： 12# 下载192.168.1.168的首页并将下载过程中的的输入信息保存到 test.htm文件中wget -o test.htm http://192.168.1.168]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Qt给应用程序添加版本信息]]></title>
    <url>%2FQt%E5%AD%A6%E4%B9%A0%2F2016%2F07%2F11%2FQt%E5%AD%A6%E4%B9%A0-2016-07-11-Qt%E7%BB%99%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[作者:daodaoliang 时间:2016年7月11日16:12:09 版本:V 0.0.4 邮箱:daodaoliang@yeah.net 0. 环境说明 系统环境: win10 64位 Qt环境: Qt-lib 5.6.0 QCreat0r 3.6.1 1. 使用.rc文件1.1 在工程项目下创建 .rc 文件 例如 version.rc: 1234567891011121314151617181920212223242526272829303132333435363738# if defined(UNDER_CE)# include &lt;winbase.h&gt;# else# include &lt;windows.h&gt;# endifVS_VERSION_INFO VERSIONINFO FILEVERSION 1,0,2,0 PRODUCTVERSION 1,0,2,0 FILEFLAGSMASK 0x3fL#ifdef _DEBUG FILEFLAGS VS_FF_DEBUG#else FILEFLAGS 0x0L#endif FILEOS VOS__WINDOWS32 FILETYPE VFT_DLL FILESUBTYPE 0x0L BEGIN BLOCK &quot;StringFileInfo&quot; BEGIN BLOCK &quot;040904b0&quot; BEGIN VALUE &quot;CompanyName&quot;, &quot;NS\0&quot; VALUE &quot;FileDescription&quot;, &quot;数据库测试类库\0&quot; VALUE &quot;FileVersion&quot;, &quot;1.0.1.0\0&quot; VALUE &quot;LegalCopyright&quot;, &quot;@2016\0&quot; VALUE &quot;OriginalFilename&quot;, &quot;NDBPool1.dll\0&quot; VALUE &quot;ProductName&quot;, &quot;NDBPool\0&quot; VALUE &quot;ProductVersion&quot;, &quot;1.0.1.0\0&quot; END END BLOCK &quot;VarFileInfo&quot; BEGIN VALUE &quot;Translation&quot;, 0x0409, 1200 END END/* End of Version info */ 1.2 修改 pro 文件在项目的工程文件里面添加 RC_FILE += ./version.rc 2. 使用内置变量12345VERSION = 1.2.3QMAKE_TARGET_PRODUCT = 产品名称QMAKE_TARGET_COMPANY = 公司QMAKE_TARGET_DESCRIPTION = 文件描述QMAKE_TARGET_COPYRIGHT = 版权 3. 防坑提示一定要确保rc文件为GBK的格式,不然会乱码,生成的rc文件默认都是UTF-8格式]]></content>
      <categories>
        <category>Qt学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux配置秘钥登录ssh]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2016%2F06%2F01%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2016-6-1-Linux%E9%85%8D%E7%BD%AE%E7%A7%98%E9%92%A5%E7%99%BB%E5%BD%95ssh%2F</url>
    <content type="text"><![CDATA[作者: aodaoliang 原文: https://hyjk2000.github.io/2012/03/16/how-to-set-up-ssh-keys/ 时间: 2016-6-1 版本: 0.0.1 邮箱: daodaoliang@yeah.net 我们一般使用 PuTTY 等 SSH 客户端来远程管理 Linux 服务器。但是，一般的密码方式登录，容易有密码被暴力破解的问题。所以，一般我们会将 SSH 的端口设置为默认的 22 以外的端口，或者禁用 root 账户登录。其实，有一个更好的办法来保证安全，而且让你可以放心地用 root 账户从远程登录——那就是通过密钥方式登录。 密钥形式登录的原理是：利用密钥生成器制作一对密钥——一只公钥和一只私钥。将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。这样一来，没有私钥，任何人都无法通过 SSH 暴力破解你的密码来远程登录到系统。此外，如果将公钥复制到其他账户甚至主机，利用私钥也可以登录。 下面来讲解如何在 Linux 服务器上制作密钥对，将公钥添加给账户，设置 SSH，最后通过客户端登录。 1. 制作密钥对首先在服务器上制作密钥对。首先用密码登录到你打算使用密钥登录的账户，然后执行以下命令： 12345678910[root@host ~]$ ssh-keygen &lt;== 建立密钥对Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): &lt;== 按 EnterCreated directory &apos;/root/.ssh&apos;.Enter passphrase (empty for no passphrase): &lt;== 输入密钥锁码，或直接按 Enter 留空Enter same passphrase again: &lt;== 再输入一遍密钥锁码Your identification has been saved in /root/.ssh/id_rsa. &lt;== 私钥Your public key has been saved in /root/.ssh/id_rsa.pub. &lt;== 公钥The key fingerprint is:0f:d3:e7:1a:1c:bd:5c:03:f1:19:f1:22:df:9b:cc:08 root@host 密钥锁码在使用私钥时必须输入，这样就可以保护私钥不被盗用。当然，也可以留空，实现无密码登录。 现在，在 root 用户的家目录中生成了一个 .ssh 的隐藏目录，内含两个密钥文件。id_rsa 为私钥，id_rsa.pub 为公钥。 2. 在服务器上安装公钥键入以下命令，在服务器上安装公钥： 12[root@host ~]$ cd .ssh[root@host .ssh]$ cat id_rsa.pub &gt;&gt; authorized_keys 如此便完成了公钥的安装。为了确保连接成功，请保证以下文件权限正确： 12[root@host .ssh]$ chmod 600 authorized_keys[root@host .ssh]$ chmod 700 ~/.ssh 3. 设置 SSH，打开密钥登录功能编辑 /etc/ssh/sshd_config 文件，进行如下设置： 12RSAAuthentication yesPubkeyAuthentication yes 另外，请留意 root 用户能否通过 SSH 登录： 1PermitRootLogin yes 当你完成全部设置，并以密钥方式登录成功后，再禁用密码登录： 1PasswordAuthentication no 最后，重启 SSH 服务： 1[root@host .ssh]$ service sshd restart 4. 将私钥下载到客户端，然后转换为 PuTTY 能使用的格式使用 WinSCP、SFTP 等工具将私钥文件 id_rsa 下载到客户端机器上。然后打开 PuTTYGen，单击 Actions 中的 Load 按钮，载入你刚才下载到的私钥文件。如果你刚才设置了密钥锁码，这时则需要输入。 载入成功后，PuTTYGen 会显示密钥相关的信息。在 Key comment 中键入对密钥的说明信息，然后单击 Save private key 按钮即可将私钥文件存放为 PuTTY 能使用的格式。 今后，当你使用 PuTTY 登录时，可以在左侧的 Connection -&gt; SSH -&gt; Auth 中的 Private key file for authentication: 处选择你的私钥文件，然后即可登录了，过程中只需输入密钥锁码即可。]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iptables禁用IP]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2016%2F05%2F23%2Flinux%E5%AD%A6%E4%B9%A0-2016-5-23-iptables%E7%A6%81%E7%94%A8IP%2F</url>
    <content type="text"><![CDATA[作者: daodaoliang 时间: 2016-5-23 版本: V0.0.1 邮箱: daodaoliang@yeah.net 0x01 确保服务启动123service iptables status/etc/init.d/iptables stop/etc/init.d/iptables start 0x02 禁用IP禁用单个IP: 1iptables -I INPUT -s 114.113.112.111 -j DROP 禁用IP段的命令: 1234iptables -I INPUT -s 114.113.0.0/16 -j DROPiptables -I INPUT -s 114.112.0.0/16 -j DROPiptables -I INPUT -s 114.111.1.0/24 -j DROPiptables -I INPUT -s 114.111.2.0/24 -j DROP 禁用整个IP段的命令: 1iptables -I INPUT -s 114.0.0.0/8 -j DROP 0x03 服务器自启动 把它加到/etc/rc.local中 iptables-save &gt;/etc/sysconfig/iptables 可以把你当前的 iptables 规则放到 /etc/sysconfig/iptables 中，系统启动 iptables 时自动执行。 service iptables save 也可以把你当前的 iptables 规则放 /etc/sysconfig/iptables 中，系统启动 iptables 时自动执行。 0x04 解封IP iptables -L –line-numbers 然后iptables -D INPUT 序号 0x04 开启端口12iptables -I INPUT -p tcp --dport 80 -j ACCEPTiptables -I INPUT -p tcp --dport 22 -j ACCEPT 123/etc/rc.d/init.d/iptables saveoriptables-save 0x05 关闭端口12iptables -I INPUT -p tcp --dport 80 -j DROPiptables -I INPUT -p tcp --dport 22 -j DROP 123/etc/rc.d/init.d/iptables saveoriptables-save 0x06 简单例子12345678910111213141516171819202122232425*filter:INPUT ACCEPT [0:0]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [0:0]-A INPUT -s 49.70.70.38/32 -j DROP-A INPUT -s 112.232.74.87/32 -j DROP-A INPUT -i lo -j ACCEPT-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 443 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 3000 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 5000 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 1022 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 5555 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 5556 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 10022 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 3013 -j ACCEPT-A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT-A INPUT -j REJECT --reject-with icmp-port-unreachable-A FORWARD -j REJECT --reject-with icmp-port-unreachable-A OUTPUT -o lo -j ACCEPT-A OUTPUT -j ACCEPTCOMMIT]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[日常linux命令之iftop]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2016%2F05%2F23%2Flinux%E5%AD%A6%E4%B9%A0-2016-05-23-%E6%97%A5%E5%B8%B8linux%E5%91%BD%E4%BB%A4%E4%B9%8Biftop%2F</url>
    <content type="text"><![CDATA[作者: daodaoliang 时间: 2016年5月23日 版本: v0.0.1 邮箱: daodaoliang@yeah.net 日常用的网络流量查看工具为 iftop， 但是他仅仅只能简单的查看网络的流量情况，若是想要查看某个链接的流量情况就比较困难了，因此再次推荐iftop 这个工具 0x01 安装 iftop我是官方网站 编译安装iftop示例: 12345# centosyum install flex byacc libpcap ncurses ncurses-devel libpcap-devel# debianapt-get install flex byacc libpcap0.8 libncurses5 123456789wget http://www.ex-parrot.com/pdw/iftop/download/iftop-0.17.tar.gztar zxvf iftop-0.17.tar.gzcd iftop-0.17./configuremake &amp;&amp; make install 一键安装iftop 示例: 12345678910# 安装EPEL源# CentOS/RHEL 5 ：rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-5.noarch.rpm# CentOS/RHEL 6 ：rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm# CentOS/RHEL 7 ：rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm 12345# centosyum install iftop# debianapt-get install iftop 0x02 iftop 界面说明直接执行 1iftop -i eth1 界面说明: 12345# 顶部: 带宽显示， 可以通过按键 `L` 进行切换流量的刻度;# 中间部分: 外部链接列表，列出所有和本机有网络交互的链接信息, 其中右边部分的数字分别为 2s、10s、40s平均流量，=&gt;代表发送数据，&lt;= 代表接收数据;# 底部: TX-发送流量 、RX-接收流量、TOTAL-总流量、Cumm-运行iftop到目前时间的总流量、peak-流量峰值、rates-分别表示过去 2s 10s 40s 的平均流量 0x03 iftop 常用参数-i: 设定监测的网卡，如：# iftop -i eth1 -B: 以bytes为单位显示流量(默认是bits)，如：# iftop -B -n: 使host信息默认直接都显示IP，如：# iftop -n -N: 使端口信息默认直接都显示端口号，如: # iftop -N -F: 显示特定网段的进出流量，如# iftop -F 10.10.1.0/24或# iftop -F 10.10.1.0/255.255.255.0 -h: （display this message），帮助，显示参数信息 -p: 使用这个参数后，中间的列表显示的本地主机信息，出现了本机以外的IP信息; -b: 使流量图形条默认就显示; -f: 这个暂时还不太会用，过滤计算包用的; -P: 使host信息及端口信息默认就都显示; -m: 设置界面最上边的刻度的最大值，刻度分五个大段显示，例：# iftop -m 100M; 0x04 iftop画面上一些操作命令123456789101112131415161718192021222324252627282930313233343536373839404142434445按h切换是否显示帮助;按n切换显示本机的IP或主机名;按s切换是否显示本机的host信息;按d切换是否显示远端目标主机的host信息;按t切换显示格式为2行/1行/只显示发送流量/只显示接收流量;按N切换显示端口号或端口服务名称;按S切换是否显示本机的端口信息;按D切换是否显示远端目标主机的端口信息;按p切换是否显示端口信息;按P切换暂停/继续显示;按b切换是否显示平均流量图形条;按B切换计算2秒或10秒或40秒内的平均流量;按T切换是否显示每个连接的总流量;按l打开屏幕过滤功能，输入要过滤的字符，比如ip,按回车后，屏幕就只显示这个IP相关的流量信息;按L切换显示画面上边的刻度;刻度不同，流量图形条会有变化;按j或按k可以向上或向下滚动屏幕显示的连接记录;按1或2或3可以根据右侧显示的三列流量数据进行排序;按&lt;根据左边的本机名或IP排序;按&gt;根据远端目标主机的主机名或IP排序;按o切换是否固定只显示当前的连接;按f可以编辑过滤代码，这是翻译过来的说法，我还没用过这个！按!可以使用shell命令，这个没用过！没搞明白啥命令在这好用呢！按q退出监控。]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql权限说明]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%2F2016%2F05%2F18%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0-mysql%E4%B8%93%E9%A2%98-2016-05-18-mysql%E6%9D%83%E9%99%90%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[作者：daodaoliang 时间：2016年5月18日 版本：0.0.1 邮箱：daodaoliang@yeah.net 官网相关文档 1.mysql 权限概述mysql允许以下几种类别的权限操作： 管理员权限，使用户能够管理mysql服务器的相关操作，这些权限都是全局的因为并不针对指定数据库做权限； 数据库权限，可以管理数据库以及包含在数据库里面的对象内容，可以对特定数据库，也可以对全部数据库进行权限操作； 数据库对象权限例如数据表、索引、视图和存储过程中，可以管理指定数据库的指定对象，也可以管理指定数据库的所有对象，也可以管理所有数据库的所有对象； mysql 和权限相关的信息都存储在mysql数据库里面的 user 、 db、 tables_priv 、 columns_priv 和 procs_priv, mysql 数据库在启动时或者reload时都会把权限内容读取到内存中； 2.mysql 权限列表 权限名字 权限表中列的名字 权限级别 权限内容 CREATE Create_priv 数据库、表、索引 允许创建新的数据库、表、索引 DROP Drop_priv 数据库、表 允许删除存在的数据库、表、视图 GRANT OPTION Grant_priv 数据库、表、存储过程 允许赋予或者移除其他用户你已经有的权限 LOCK TABLES Lock_tables_priv 数据库 允许使用LOCK TABLES显式锁定用户表 REFERENCES References_priv 数据库、表 官网也没有说清楚，貌似和外键有关 EVENT Event_priv 数据库 允许创建和查看event，同时create, alter, drop也需要该权限 ALTER Alter_priv 表 允许使用 ALTER TABLE该表表结构 DELETE Delete_priv 表 允许在表中删除列 INDEX Index_priv 表 允许在表中创建和删除索引，如果有create 权限可以在 create table时定义索引 INSERT Insert_priv 表、列 允许在数据表中插入数据 SELECT Select_priv 表、列 允许查询数据库，注意update和delete在where 子句中也是需要select 权限 UPDATE Update_priv 表、列 允许更新数据库里面的列信息 CREATE TEMPORARY TABLES Create_tmp_table_priv 表 允许创建临时表 TRIGGER Trigger_priv 表 允许触发操作 CREATE VIEW Create_view_priv 视图 允许创建视图 SHOW VIEW Show_view_priv 视图 允许允许使用SHOW CREATE VIEW ALTER ROUTINE Alter_routine_priv 存储过程 允许修改和删除存储过程或者函数 CREATE ROUTINE Create_routine_priv 存储过程 允许创建存储过程 EXECUTE Execute_priv 存储过程 允许执行存储过程 FILE File_priv 服务器上关联的数据文件 允许读写相关文件 CREATE TABLESPACE Create_tablespace_priv 数据库管理 允许 create, alter, or drop tablespaces CREATE USER Create_user_priv 数据库管理 允许 ALTER USER, CREATE USER, DROP USER, RENAME USER, and REVOKE ALL PRIVILEGES PROCESS Process_priv 数据库管理 允许查看进程信息权限 PROXY see proxies_priv table 数据库管理 允许用户代理 RELOAD Reload_priv 数据库管理 允许使用 FLUSH 和 mysqladmin REPLICATION CLIENT Repl_client_priv 数据库管理 允许 SHOW MASTER STATUS 、 SHOW SLAVE STATUS 和 SHOW BINARY LOGS REPLICATION SLAVE Repl_slave_priv 数据库管理 复制权限 SHOW DATABASES Show_db_priv 数据库管理 允许 SHOW DATABASE SHUTDOWN Shutdown_priv 数据库管理 允许 mysqladmin shutdown SUPER Super_priv 数据库管理 允许kill 线程 ALL [PRIVILEGES] 数据库管理 all privileges available at a given privilege level USAGE 数据库管理 no privileges 3.mysql 权限操作示例3.1 grant 命令使用说明1grant all privileges on *.* to daodaoliang@&apos;localhost&apos; identified by &apos;mypass&apos; with grant option; grant命令说明: all privileges : 是表示所有权限，你也可以使用select、update等权限; on : 用来针对哪些库和表; *.*: 前面的*用来指定数据库，后面的*用来指定数据表; To : 将权限赋予某个用户; daodaoliang@’localhost’: 用户为daodaoliang，@后面表示限制的主机，可以是IP地址、IP段、域名以及%，%表示任何地方，需要注意有的%不包含本地，所以当出现其他地方可以登录而本机不可以登录时，在添加localhost即可； identified by : 指定用户的登录密码; with grant option : 这个选项表示该用户可以将自己拥有的权限授权给别人; PS： grant 可以重复给用户添加权限，权限叠加； 3.2 刷新权限1flush privileges; 在对权限做了修改之后要使用这个命令来使 privileges 生效； 3.3 查看权限 查看当前用户的权限 1show grants; 查看指定用户的权限 1show grants for &apos;daodaoliang@%&apos; 3.4 撤销权限1revoke delete on *.* from daodaoliang@&apos;%&apos; identified by &apos;my pass&apos;]]></content>
      <categories>
        <category>数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python 在 windows 下的服务开发]]></title>
    <url>%2FPython%E5%AD%A6%E4%B9%A0%2F2016%2F05%2F11%2FPython%E5%AD%A6%E4%B9%A0-2016-05-11-python%E5%9C%A8windows%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[作者：daodaoliang 版本：0.0.1 邮箱：daodaoliang@yeah.net [TOC] 离线版本文档 1 开发环境的准备 首先要正确的安装 python 请点击我完成所需进行安装； 然后安装 pywin32 请点击我完成所需安装； 最后安装 py2exe 请点击我 完成所需安装； 完成上述操作后基本上就完成了服务环境的搭建了，接下来就是编写服务程序并打包发布了； 2. 项目工程文件布局 3. 服务文件源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import sysimport win32serviceimport win32eventimport win32serviceutilimport servicemanagerimport winerrorclass MyServer(win32serviceutil.ServiceFramework): _svc_name_ = "sync_vip" _svc_display_name_ = "sync_vip" _svc_description_ = "daodaoliang@yeah.net" def __init__(self, args): win32serviceutil.ServiceFramework.__init__(self, args) self.hWaitStop = win32event.CreateEvent(None, 0, 0, None) self.isAlive = True def SvcStop(self): # 先告诉SCM停止这个过程 self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING) # 设置事件 win32event.SetEvent(self.hWaitStop) def SvcDoRun(self): import time import win32evtlogutil win32evtlogutil.ReportEvent(self._svc_name_, servicemanager.PYS_SERVICE_STARTED, 0, servicemanager.EVENTLOG_INFORMATION_TYPE, (self._svc_name_, '')) while self.isAlive: print('你的业务逻辑') win32evtlogutil.ReportEvent(self._svc_name_, servicemanager.PYS_SERVICE_STOPPED, 0, servicemanager.EVENTLOG_INFORMATION_TYPE, (self._svc_name_, '')) self.ReportServiceStatus(win32service.SERVICE_STOPPED) returnif __name__ == '__main__': import os if len(sys.argv) == 1: try: evtsrc_dll = os.path.abspath(servicemanager.__file__) servicemanager.PrepareToHostSingle(MyServer) servicemanager.Initialize('MyServer', evtsrc_dll) servicemanager.StartServiceCtrlDispatcher() except win32service.error, details: if details[0] == winerror.ERROR_FAILED_SERVICE_CONTROLLER_CONNECT: win32serviceutil.usage() else: win32serviceutil.HandleCommandLine(MyServer) 4. 服务的安装和启动在完成上述的编写后，其实服务程序就已经可以运行了，运行方式如下： 4.1 安装服务1python my_server.py install 4.2 启动服务1python my_server.py start 4.3 重启服务1python my_server.py restart 4.4 关闭服务1python my_server.py stop 4.5 卸载服务1python my_server.py remove 防坑提示： 一定要以管理员权限运行该命令，或者在管理员账号下运行，不然会运行失败！ 5. py2exe 打包程序setup.py源码 123456789101112from distutils.core import setupimport py2exesetup(console=["sync_vip.py"], version="0.0.2", name="my_server", description="daodaoliang@yeah.net", requires=['PySQLPool'] ) 然后用终端进入setup.py 所在的目录执行 1python my_server.py py2exe 执行完毕后会产生build 和 dist 文件夹，其中 dist 里面的内容就是待发布的文件； 6. 用innosetup 进行安装包的打包自行百度去吧，这个很简单；]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[josn 和 jsonp (转载)]]></title>
    <url>%2F%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%2F2016%2F03%2F14%2F%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-2016-03-14-json%E5%92%8Cjsonp%2F</url>
    <content type="text"><![CDATA[原文在这里, 为了自己温习方面，特地转载； 1. 前言：说到AJAX就会不可避免的面临两个问题，第一个是AJAX以何种格式来交换数据？第二个是跨域的需求如何解决？这两个问题目前都有不同的解决方案，比如数据可以用自定义字符串或者用XML来描述，跨域可以通过服务器端代理来解决。 但到目前为止最被推崇或者说首选的方案还是用JSON来传数据，靠JSONP来跨域。而这就是本文将要讲述的内容。 JSON和JSONP虽然只有一个字母的差别，但其实他们根本不是一回事儿：JSON是一种数据交换格式，而JSONP是一种依靠开发人员的聪明才智创造出的一种非官方跨域数据交互协议。我们拿最近比较火的谍战片来打个比方，JSON是地下党们用来书写和交换情报的“暗号”，而JSONP则是把用暗号书写的情报传递给自己同志时使用的接头方式。看到没？一个是描述信息的格式，一个是信息传递双方约定的方法。 既然随便聊聊，那我们就不再采用教条的方式来讲述，而是把关注重心放在帮助开发人员理解是否应当选择使用以及如何使用上。 2. 什么是JSON？前面简单说了一下，JSON是一种基于文本的数据交换方式，或者叫做数据描述格式，你是否该选用他首先肯定要关注它所拥有的优点。 2.1 JSON的优点： 基于纯文本，跨平台传递极其简单； Javascript原生支持，后台语言几乎全部支持； 轻量级数据格式，占用字符数量极少，特别适合互联网传递； 可读性较强，虽然比不上XML那么一目了然，但在合理的依次缩进之后还是很容易识别的； 容易编写和解析，当然前提是你要知道数据结构； JSON的缺点当然也有，但在作者看来实在是无关紧要的东西，所以不再单独说明。 2.2 JSON的格式或者叫规则：JSON能够以非常简单的方式来描述数据结构，XML能做的它都能做，因此在跨平台方面两者完全不分伯仲。 JSON只有两种数据类型描述符，大括号{}和方括号[]，其余英文冒号:是映射符，英文逗号,是分隔符，英文双引号””是定义符。 大括号{}用来描述一组“不同类型的无序键值对集合”（每个键值对可以理解为OOP的属性描述），方括号[]用来描述一组“相同类型的有序数据集合”（可对应OOP的数组）。 上述两种集合中若有多个子项，则通过英文逗号,进行分隔。 键值对以英文冒号:进行分隔，并且建议键名都加上英文双引号””，以便于不同语言的解析。 JSON内部常用数据类型无非就是字符串、数字、布尔、日期、null 这么几个，字符串必须用双引号引起来，其余的都不用，日期类型比较特殊，这里就不展开讲述了，只是建议如果客户端没有按日期排序功能需求的话，那么把日期时间直接作为字符串传递就好，可以省去很多麻烦。 JSON实例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 描述一个人var person = &#123; &quot;Name&quot;: &quot;Bob&quot;, &quot;Age&quot;: 32, &quot;Company&quot;: &quot;IBM&quot;, &quot;Engineer&quot;: true&#125;// 获取这个人的信息var personAge = person.Age;// 描述几个人var members = [ &#123; &quot;Name&quot;: &quot;Bob&quot;, &quot;Age&quot;: 32, &quot;Company&quot;: &quot;IBM&quot;, &quot;Engineer&quot;: true &#125;, &#123; &quot;Name&quot;: &quot;John&quot;, &quot;Age&quot;: 20, &quot;Company&quot;: &quot;Oracle&quot;, &quot;Engineer&quot;: false &#125;, &#123; &quot;Name&quot;: &quot;Henry&quot;, &quot;Age&quot;: 45, &quot;Company&quot;: &quot;Microsoft&quot;, &quot;Engineer&quot;: false &#125;]// 读取其中John的公司名称var johnsCompany = members[1].Company;// 描述一次会议var conference = &#123; &quot;Conference&quot;: &quot;Future Marketing&quot;, &quot;Date&quot;: &quot;2012-6-1&quot;, &quot;Address&quot;: &quot;Beijing&quot;, &quot;Members&quot;: [ &#123; &quot;Name&quot;: &quot;Bob&quot;, &quot;Age&quot;: 32, &quot;Company&quot;: &quot;IBM&quot;, &quot;Engineer&quot;: true &#125;, &#123; &quot;Name&quot;: &quot;John&quot;, &quot;Age&quot;: 20, &quot;Company&quot;: &quot;Oracle&quot;, &quot;Engineer&quot;: false &#125;, &#123; &quot;Name&quot;: &quot;Henry&quot;, &quot;Age&quot;: 45, &quot;Company&quot;: &quot;Microsoft&quot;, &quot;Engineer&quot;: false &#125; ]&#125;// 读取参会者Henry是否工程师var henryIsAnEngineer = conference.Members[2].Engineer; 关于JSON，就说这么多，更多细节请在开发过程中查阅资料深入学习。 3. 什么是JSONP？3.1 先说说JSONP是怎么产生的：其实网上关于JSONP的讲解有很多，但却千篇一律，而且云里雾里，对于很多刚接触的人来讲理解起来有些困难，小可不才，试着用自己的方式来阐释一下这个问题，看看是否有帮助 一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准； 不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如、、）； 于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理； 恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据； 这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。 客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。 为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。 如果对于callback参数如何使用还有些模糊的话，我们后面会有具体的实例来讲解。 3.2 JSONP的客户端具体实现：不管jQuery也好，extjs也罢，又或者是其他支持jsonp的框架，他们幕后所做的工作都是一样的，下面我来循序渐进的说明一下jsonp在客户端的实现： 我们知道，哪怕跨域js文件中的代码（当然指符合web脚本安全策略的），web页面也是可以无条件执行的。 远程服务器remoteserver.com根目录下有个remote.js文件代码如下： 1alert(&apos;我是远程文件&apos;); 本地服务器localserver.com下有个jsonp.html页面代码如下： 12345678910&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://remoteserver.com/remote.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 毫无疑问，页面将会弹出一个提示窗体，显示跨域调用成功。 现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。 jsonp.html页面代码如下： 123456789101112131415&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var localHandler = function(data)&#123; alert(&apos;我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：&apos; + data.result); &#125;; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://remoteserver.com/remote.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; remote.js文件代码如下： 1localHandler(&#123;&quot;result&quot;:&quot;我是远程js带来的数据&quot;&#125;); 运行之后查看结果，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。很欣喜，跨域远程获取数据的目的基本实现了，但是又一个问题出现了，我怎么让远程js知道它应该调用的本地函数叫什么名字呢？毕竟是jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？我们接着往下看。 聪明的开发者很容易想到，只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端“我想要一段调用XXX函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。 看jsonp.html页面的代码： 12345678910111213141516171819202122&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 得到航班信息查询结果后的回调函数 var flightHandler = function(data)&#123; alert(&apos;你查询的航班结果是：票价 &apos; + data.price + &apos; 元，&apos; + &apos;余票 &apos; + data.tickets + &apos; 张。&apos;); &#125;; // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） var url = &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler&quot;; // 创建script标签，设置其属性 var script = document.createElement(&apos;script&apos;); script.setAttribute(&apos;src&apos;, url); // 把script标签加入head，此时调用开始 document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 这次的代码变化比较大，不再直接把远程js文件写死，而是编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。 我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。 OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）： 12345flightHandler(&#123; &quot;code&quot;: &quot;CA1998&quot;, &quot;price&quot;: 1780, &quot;tickets&quot;: 5&#125;); 我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！ 到这里为止的话，相信你已经能够理解jsonp的客户端实现原理了吧？剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用。 什么？你用的是jQuery，想知道jQuery如何实现jsonp调用？好吧，那我就好人做到底，再给你一段jQuery使用jsonp的代码（我们依然沿用上面那个航班信息查询的例子，假定返回jsonp结果不变）： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; &gt; &lt;head&gt; &lt;title&gt;Untitled Page&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; jQuery(document).ready(function()&#123; $.ajax(&#123; type: &quot;get&quot;, async: false, url: &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&quot;, dataType: &quot;jsonp&quot;, jsonp: &quot;callback&quot;,//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback) jsonpCallback:&quot;flightHandler&quot;,//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写&quot;?&quot;，jQuery会自动为你处理数据 success: function(json)&#123; alert(&apos;您查询到航班信息：票价： &apos; + json.price + &apos; 元，余票： &apos; + json.tickets + &apos; 张。&apos;); &#125;, error: function()&#123; alert(&apos;fail&apos;); &#125; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 是不是有点奇怪？为什么我这次没有写flightHandler这个函数呢？而且竟然也运行成功了！哈哈，这就是jQuery的功劳了，jquery在处理jsonp类型的ajax时（还是忍不住吐槽，虽然jquery也把jsonp归入了ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供success属性方法来调用，是不是很爽呀？]]></content>
      <categories>
        <category>进程间通信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[centos 6.5 升级git]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2016%2F03%2F14%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2016-03-14-CentOS6-5%E5%8D%87%E7%BA%A7git%2F</url>
    <content type="text"><![CDATA[作者: daodaoliang@yeah.net 版本: v 0.0.2 日期: 2017-03-14 CentOS 6.5 的系统默认的git 版本为1.7.1 有些功能该版本是不提供支持的，比如https登陆认证的功能，而我恰巧比较喜欢该功能，所以只能升级git版本； 1. 安装环境准备12yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel asciidocyum install gcc perl-ExtUtils-MakeMaker 该过程可能会报错: 1/utf8.c:463: undefined reference to `libiconv&apos; 则进行下面的处理: 123456789wget http://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.14.tar.gztar zxvf libiconv-1.14.tar.gz cd libiconv-1.14./configure --prefix=/usr/local/libiconvmake &amp;&amp; make install 2. 卸载CentOS自带的 1.7.1版本1yum remove git 3. 下载git源码并编译安装1234567891011121314151617wget https://github.com/git/git/archive/v2.2.1.tar.gztar zxvf v2.2.1.tar.gzcd git-2.2.1make configure./configure --prefix=/usr/local/git --with-iconv=/usr/local/libiconvmake all docmake install install-doc install-htmlecho &quot;export PATH=$PATH:/usr/local/git/bin&quot; &gt;&gt; /etc/bashrcsource /etc/bashrc 4. 版本号确认1git --version 5. 常见问题处理git错误: Unable to find remote helper for ‘https’ 一般因为 /usr/libexec/git-core/ 路径没在 PATH 环境变量中，导致里面的 git-remote-https, git-remote-http 这些得不到执行。所以 git 所表现出来的功能不全 1234567# 方式1 --- 在使用git之前 执行PATH=$PATH:/usr/libexec/git-core# 方式2 --- 增加到系统环境变量中echo &quot;export PATH=$PATH:/usr/libexec/git-core&quot; &gt;&gt; /etc/profilesource /etc/profile 参考链接: http://www.dbpoo.com/centos-65-git-update/ http://www.tuicool.com/articles/7buQNv]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python 库学习之 itsdangerous]]></title>
    <url>%2FPython%E5%AD%A6%E4%B9%A0%2F2016%2F03%2F14%2FPython%E5%AD%A6%E4%B9%A0-2016-03-14-python%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8Bitsdangerous%2F</url>
    <content type="text"><![CDATA[这是原始主页 有时候你想向一个不可信的环境发送数据，但是如何安全的完成这个任务呢？诀窍就是引入签名！使用只有你自己知道的秘钥进行加密，并把加密后的数据发给别人处理，当你取回数据时，你就可以确保没人篡改过这份数据； 虽然接受者可以解密你的数据看看里面封装的是什么内容，但他们没法修改你的内容，除非他们知道你的私钥，因此你只要保管好你的秘钥，同时使用复杂的秘钥就万事大吉了； itsdangerous内部默认使用了HMAC和SHA1来签名，基于 Django 签名模块。它也支持JSON Web 签名 (JWS)。这个库采用BSD协议，由Armin Ronacher编写，而大部分设计与实现的版权归Simon Willison和其他的把这个库变为现实的Django爱好者们； 1. 安装你可以从 PyPI 上直接安装这个库： 1pip install itsdangerous 适用案例： 在取消订阅某个通讯时，你可以在URL里序列化并且签名一个用户的ID。这种情况下你不需要生成一个一次性的token并把它们存到数据库中, 同样适用于一些激活链接等类似的情景下； 被签名的对象可以被保存在例如 cookie 等不可信来源，这意味着你不需要在服务端保存 session , 这样可以降低数据库读取次数； 通常签名后的数据可以安全的往返与服务端和客户端之间，这个特性可以用于将服务端的状态传递到客户端在传递回来； 2. 签名接口最基本的接口是签名接口， Signer 类可以用来将一个签名附加到指定 string 上： 1234from itsdangerous import Signers = Signer('secret-key')s.sign('my string')'my string.wh6tMHxLgJqB6oY1uT73iMlyrOA' 签名会被加在字符串尾部，中间由句号 (.)分隔。验证字符串，使用 unsign() 方法： 12s.unsign('my string.wh6tMHxLgJqB6oY1uT73iMlyrOA')'my string' 如果被签名的是一个unicode字符串，那么它将隐式地被转换成utf-8。然而，在反签名时，你没法知道它原来是unicode还是字节串。 如果反签名失败了，将得到一个异常： 12345s.unsign('my string.wh6tMHxLgJqB6oY1uT73iMlyrOX')Traceback (most recent call last): ...itsdangerous.BadSignature: Signature "wh6tMHxLgJqB6oY1uT73iMlyrOX" does not match 3. 使用时间戳签名如果你想要一个可以过期的签名，可以使用 TimestampSigner 类，它会加入时间戳信息并签名。在反签名时，你可以验证时间戳就没有过期； 12345678from itsdangerous import TimestampSigners = TimestampSigner('secret-key')string = s.sign('foo')# 参数的意思为在签名时间后的多少秒为有效s.unsign(string, max_age=5)Traceback (most recent call last): ...itsdangerous.SignatureExpired: Signature age 15 &gt; 5 seconds 4. 序列化因为字符串难以处理，本模块也提供了一个与json或pickle类似的序列化接口.(它内部默认使用simplejson，但是可以通过子类进行修改),这个 Serializer 类实现了: 1234from itsdangerous import Serializers = Serializer('secret-key')s.dumps([1, 2, 3, 4])'[1, 2, 3, 4].r7R9RhGgDPvvWl3iNzLuIIfELmo' 它当然也可以加载数据: 12s.loads('[1, 2, 3, 4].r7R9RhGgDPvvWl3iNzLuIIfELmo')[1, 2, 3, 4] 若果你需要一个时间戳， 你可以使用 TimedSerializer 类 5. URL安全序列化如果只能向一个字符受限的环境中传递可信的字符串的话，这个功能将会十分有用。itsdangerous 提供了一个 URL 安全序列化工具: 1234567from itsdangerous import URLSafeSerializers = URLSafeSerializer('secret-key')s.dumps([1, 2, 3, 4])'WzEsMiwzLDRd.wSPHqC0gR7VUqivlSukJ0IeTDgo's.loads('WzEsMiwzLDRd.wSPHqC0gR7VUqivlSukJ0IeTDgo')[1, 2, 3, 4] 6. JSON WEB 签名从“itsdangerous” 0.18版本开始，也支持了JSON Web签名。它们的工作方式与原有的URL安全序列化器差不多，但是会根据当前JSON Web签名（JWS）草案（10） [draft-ietf-jose-json-web-signature] 来生成header。 1234from itsdangerous import JSONWebSignatureSerializers = JSONWebSignatureSerializer('secret-key')s.dumps(&#123;'x': 42&#125;)'eyJhbGciOiJIUzI1NiJ9.eyJ4Ijo0Mn0.ZdTn1YyGz9Yx5B5wNpWRL221G1WpVE5fPCPKNuc6UAo' 在将值加载回来时，默认会像其他序列化器一样，不会返回header。但是你可以通过传入 return_header=True 参数来得到header，定制的header会在序列化的数据外层: 12345s.dumps(0, header_fields=&#123;'v': 1&#125;)'eyJhbGciOiJIUzI1NiIsInYiOjF9.MA.wT-RZI9YU06R919VBdAfTLn82_iIQD70J_j-3F4z_aM's.loads('eyJhbGciOiJIUzI1NiIsInYiOjF9.MA.wT-RZI9YU06R919VBdAfTLn82_iIQD70J_j-3F4z_aM', return_header=True)(0, &#123;u'alg': u'HS256', u'v': 1&#125;) itsdangerous目前只提供HMAC SHA的派生算法以及不使用算法，不支持基于ECC的算法。header中的算法将与序列化器中的进行核对，如果不匹配，将引发 BadSignature 异常。 7. 盐所有的类都接受一个盐的参数。这个名字可能会误导你，因为通常你会认为，密码学中的盐会是和被签名的字符串存储在一起的东西，用来防止彩虹表查找，这种盐是公开的。 与Django中的原始实现类似，itsdangerous中的盐，是为了一个截然不同的目的而产生的。你可以将它视为成命名空间。就算你泄露了它，也不是很严重的问题，因为没有密钥的话，它对攻击者没什么帮助。 假设你想签名两个链接。你的系统有个激活链接，用来激活一个用户账户，并且你有一个升级链接，可以让一个用户账户升级为付费用户，这两个链接使用email发送。在这两种情况下，如果你签名的都是用户ID，那么该用户可以在激活账户和升级账户时，复用URL的可变部分。现在你可以在你签名的地方加上更多信息（如升级或激活的意图），但是你也可以用不同的盐： 123456789101112s1 = URLSafeSerializer('secret', salt='activate-salt')s1.dumps(42)'NDI.kubVFOOugP5PAIfEqLJbXQbfTxs's2 = URLSafeSerializer('secret-key', salt='upgrade-salt')s2.dumps(42)'NDI.7lx-N1P-z2veJ7nT1_2bnTkjGTE's2.loads(s1.dumps(42))Traceback (most recent call last): ...itsdangerous.BadSignature: Signature "kubVFOOugP5PAIfEqLJbXQbfTxs" does not match 只有使用相同盐的序列化器才能成功把值加载出来： 12s2.loads(s2.dumps(42))42 8. 对失败的响应从itsdangerous 0.14版本开始，异常会有一些有用的属性，可以允许你在签名检查失败时，检查你的数据。这里必须极其小心，因为这个时候，你知道有某人修改了你的数据。但这可能对你debug很有帮助。 示例用法: 12345678910111213141516from itsdangerous import URLSafeSerializer, BadSignature, BadDatas = URLSafeSerializer('secret-key')decoded_payload = Nonetry: decoded_payload = s.loads(data) # This payload is decoded and safeexcept BadSignature, e: encoded_payload = e.payload if encoded_payload is not None: try: decoded_payload = s.load_payload(encoded_payload) except BadData: pass # 这里的数据可以解码出来，但不是安全的，因为有某人改动了签名。 # 解码步骤(load_payload)是显式的，因为将数据反序列化可能是不安全的 #（请设想被解码的不是json,而是pickle） 如果你不想检查到底是哪里出错了，你也可以使用不安全的加载方式: 123from itsdangerous import URLSafeSerializers = URLSafeSerializer('secret-key')sig_okay, payload = s.loads_unsafe(data) 返回的元组中第一项是一个布尔值，表明了签名是否是正确的。 9. Python 3 提示在Python 3中，itsdangerous的接口在一开始可能让人困扰。由于它封装在内部的序列化器，函数返回值不一定是unicode字符串还是字节对象。内置的签名器总是基于字节的。 这是为了允许模块操作不同的序列化器，独立于它们的实现方式。模块通过执行一个空对象的序列化，来决定使用哪种序列化器。 10. It’s Dangerous 的升级日志直接看英文版本]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python 作用域学习记录]]></title>
    <url>%2FPython%E5%AD%A6%E4%B9%A0%2F2016%2F03%2F11%2FPython%E5%AD%A6%E4%B9%A0-2016-03-11-python%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[0x01 python作用域说明Python的作用域一共有4中，分别是： L (local) 局部作用域，需注意的是函数的局部命名空间是一个作用域，而类的局部命名空间不是作用域; E (Enclosing) 闭包函数的作用域; G (Global) 全局作用域; B (Built-in) 内建作用域,Python 解释器启动时自动载入built模块后所形成的名字空间；诸如 str/list/dict…等内置对象的名称就处于这里; python 查找对象的顺序都是从当前层次开始依据 L -&gt; E -&gt; G -&gt; B 的顺序查找，即在局部找不到，便会去局部外部的局部去找(例如闭包)，在找不到就会去全局找，全局找不到便会去内建空间去找； 0x02 python 中作用域的产生 python中只有 函数(def，lambda)、类(class)、模块(import) 才会引入新的作用域; if/elif/else/ 、 try/except 、 for/while 并不能产生新的作用域； 0x03 python 作用域中的变量产生在python中，名字绑定到新的作用域时(即发生名字冲突或者第一次绑定时)会引入新的变量，同时绑定到一个对象上，名字绑定发生在如下的情况下： 参数声明： 参数声明会在函数的局部作用域中产生新的变量； 赋值操作： 对一个变量的初次赋值会在当前作用域中引入一个新的变量，后续赋值操作则会重新绑定该变量； 类和函数定义： 类和函数定义将类名和函数名作为变量引入当前作用域，类和函数体将形成另外一个作用域； import 语句： import语句在当前作用域中引入新的变量，一般是在全局作用域； for语句： for语句在当前作用域中引入新的变量(循环变量)； except 语句： except 语句在当前作用域中引入新的变量(异常对象)； 在 python 中，类定义所引入的作用域对于成员函数是不可见的，这与 c++ 之类的语言是不相同的，因此在 python 中，成员函数想要引用类体定义的变量，必须通过 self 或者类名来引用它； 0x04 python global 和 nonlocal 语句内层作用域若想直接修改上层变量，需要通过 global nonlocal 语句先声明 global 说明该符号修饰的变量来自与全局变量，但是需要注意并不能在当前层创建标示符； nolocal 说明该符号修饰的变量来自它的父作用域，同时会在该命名空间中创建与父函数变量同名的标示符； 参考链接： https://segmentfault.com/a/1190000004519811#articleHeader8 http://www.jianshu.com/p/3bb277c2935c https://segmentfault.com/a/1190000004461404]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux下计划任务学习记录]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2016%2F03%2F10%2Flinux%E5%AD%A6%E4%B9%A0-2016-03-10-linux%E4%B8%8B%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[0x01 计划任务简介linux 中计划任务主要分为”循环执行”和”只执行一次”两种，分别对应的时 crond 服务 和 atd 服务； 0x02 只执行一次的计划任务0x02.1 atd 服务说明atd 服务会轮训计划任务的文件，也就是我们用at 或者 batch 命令下达的任务，都会以文件的形式存储在系统中，其中： 在ubuntu系统下存在： 12/var/spool/cron/atjobs /var/spool/cron/atspool 在Centos系统下存在： 1/var/spool/at/ PS: 若是没有安装请用对应系统地包管理器进行安装 0x02.2 atd 服务开启:配置 atd 服务的权限： 首先寻找 /etc/at.allow 这个文件，只有写在这个文件里面的用户才能使用 at, 没有写在这个文件里面的用户不能使用(即使它也没被写在/etc/at.deny)中； 如果 /etc/at.allow 不存在，就寻找 /etc/at.deny 这个文件，写在这个 at.deny 的用户不能使用 at; 如果这两个文件都不存在则只能 root 用户使用 at; 确保 atd 服务开启： 12/etc/ini.d/atd status/etc/ini.d/atd start 设置 服务的开机自启动: 1chkconfig atd on 0x02.2 at,atq,atrm,bath命令1234567Usage: at [-V] [-q x] [-f file] [-mMlbv] timespec ... at [-V] [-q x] [-f file] [-mMlbv] -t time at -c job ... atq [-V] [-q x] at [ -rd ] job ... atrm [-V] job ... batch 参数说明： &gt; -V 显示版本信息 -q&lt;列队&gt; 使用指定的列队 -f&lt;文件&gt; 从指定文件读入任务而不是从标准输入读入 -m 当指定的任务被完成之后，将给用户发送邮件，即使没有标准输出 -M 永远不发送任何邮件 -l atq的别名 -d atrm的别名 -r atrm的别名 -b batch.的别名 -v 显示任务将被执行的时间 -t&lt;时间参数&gt; 以时间参数的形式提交要运行的任务 示例1: 三天后的下午 5 点锺执行/bin/ls 命令 12345[root@localhost ~]# at 5pm+3 days at&gt; /bin/ls &gt; /tmp/daodaoliang at&gt; &lt;EOT&gt;job 1 at 2016-03-10 14:27:47 示例2: 明天下午5:20执行一个脚本 12[root@localhost ~]# at -f /tmp/daodaoliang.sh 17:20 tomorrow job 8 at 2016-03-10 14:31:25 示例3: 查询当前任务信息 12345atq或者at -l 然后 1at -c &lt;任务号码&gt; 示例4: 删除某指定任务 12345atrm &lt;任务号码&gt;或者at -r &lt;任务号码&gt; 示例5: 从现在开始的系统闲暇时间执行一个脚本 12345batch now -f /tmp/daodaoliang.sh或者batch -f /tmp/daodaoliang.sh -b now PS: 空闲指的是 在CPU 的工作负载小于 0.8 的时候； 0x03 循环执行的计划任务0x03.1 crond服务说明 crond是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。 crond 执行的计划任务主要分为如下两类： 系统执行的工作：系统周期性所要执行的工作，如备份系统数据、清理缓存; 个人执行的工作：某个用户定期要做的工作，例如每隔10分钟检查邮件服务器是否有新信，这些工作可由每个用户自行设置。 0x03.2 crond服务开启12/etc/ini.d/crond startus/etc/ini.d/crond start 设置 服务的开机自启动: 1chkconfig crond on 0x03.3 crond服务配置 若 /etc/cron.allow 存在， 在这里面写入的用户则可以使用 crontab; 若 /etc/cron.deny 存在，在这里面写入的用户则不可以使用 crontab; 若这两个都不存在则看系统地配置参数了，要么只有超级管理员可以用，要么谁都可以用，一般来说，只要保留 etc/cron.deny 即可； 0x3.4 计划任务的说明系统的计划任务写在如下路径文件里面： &gt; /etc/crontab 文件(ubuntu系统可能不存在这个文件) /etc/cron.d/ 文件夹下的文件 /etc/cron.hourly/ 文件夹下的文件 /etc/cron.daily/ 文件夹下的文件 /etc/cron.weekly 文件夹下的文件 /etc/cron.monthly 文件夹下的文件 用户自己的计划任务希望在如下的文件里面: &gt; /var/spool/cron/&lt;用户名字&gt; 文件夹内的文件 总体来说按照用户和用途的不同需要按照以下来使用： &gt; 用户自己的计划任务直接用 crontab -e 来创建，这样能保证创建的指令行为不会被其他人看见； 系统维护使用 /etc/crontab 如果这个计划任务是比较重要系统计划任务，为了管理方便，同时易于追踪则直接写入 /etc/crontab比较方便； 自己开发的系统软件，最好是编写新的计划文件放到 /etc/cron.d/newfile 来进行管理比较方便 固定，小时、天、周等执行的工作，如果与系统维护有关则直接写在 /etc/crontab 集中管理比较好，当然也可以偷懒写在上述的几个特殊的文件夹里面； 0x3.5 crontab 格式说明12345678910111213SHELL=/bin/bash &lt;==使用哪種 shell 介面PATH=/sbin:/bin:/usr/sbin:/usr/bin &lt;==執行檔搜尋路徑MAILTO=root &lt;==若有額外STDOUT，以 email將資料送給誰# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed 0x3.6 anacron 的说明anacron 只是一个程序并非一个服务，他会每小时被 crond 执行一次： 在 centos 下面对于它的配置在 /etc/cron.hourly/0anacron 在 ubuntu 下面对于他的配置在 /etc/cron.d/anacron anacron 配置文件的说明 12345678910111213# /etc/anacrontab: configuration file for anacron# See anacron(8) and anacrontab(5) for details.SHELL=/bin/shPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/binHOME=/rootLOGNAME=root# These replace cron's entries1 5 cron.daily run-parts --report /etc/cron.daily7 10 cron.weekly run-parts --report /etc/cron.weekly@monthly 15 cron.monthly run-parts --report /etc/cron.monthly 配置文件中的四列分别的意思为 &gt; 第一列 天数 anacron 与 上次记录相差的天数，若是超过这个天数则就准备开始执行，若没有超过这个天数则不予执行； 第二列 延迟时间 (单位时分钟) 在上述超过天数后再进行执行计划任务，为了避免系统拥堵则延迟一定时间开始执行； 第三列 工作名称 这个计划工作的名字，这个可以自定义； 第四列 实际要运行的指令 比如 run-parts /etc/cron.daily 就是要运行在 指定目录下的所有脚本， 通常该脚本的路径 和 crond 的文件路径相同； 所以如果你需要确保某些命令执行则需要进行修改 /etc/anacron 文件； 参考链接： http://linux.vbird.org/linux_basic/0430cron.php http://blog.sina.com.cn/s/blog_6561ca8c0101ab83.html http://www.jb51.net/LINUXjishu/74014.html http://blog.csdn.net/richerg85/article/details/23442411 http://www.linuxfly.org/post/11/]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux下用logroate进行日志切割]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2016%2F03%2F09%2Flinux%E5%AD%A6%E4%B9%A0-2016-03-09-linux%E4%B8%8B%E5%88%A9%E7%94%A8logroate%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%2F</url>
    <content type="text"><![CDATA[TOC {:toc} 0x01 简介官网介绍请看这里 The logrotate utility is designed to simplify the administration of log files on a system which generates a lot of log files. Logrotate allows for the automatic rotation compression, removal and mailing of log files. Logrotate can be set to handle a log file daily, weekly, monthly or when the log file gets to a certain size. 0x02 关键文件说明以下是logrotate运行的关键点： /usr/bin/logrotate 程序所在位置； /etc/cron.daily/logrotate 默认让系统的cron每天执行logrotate一次； /etc/logrotate.conf 全局配置文件； /etc/logrotate.d 应用自个的配置文件存放目录，覆盖全局配置； 0x03 关键文件说明系统配置文件： 123456789101112131415161718192021222324252627282930313233343536# see "man logrotate" for details# rotate log files weeklyweekly# use the syslog group by default, since this is the owning group# of /var/log/syslog.su root syslog# keep 4 weeks worth of backlogsrotate 4# create new (empty) log files after rotating old onescreate# uncomment this if you want your log files compressed#compress# packages drop log rotation information into this directoryinclude /etc/logrotate.d# no packages own wtmp, or btmp -- we'll rotate them here/var/log/wtmp &#123; missingok monthly create 0664 root utmp rotate 1&#125;/var/log/btmp &#123; missingok monthly create 0660 root utmp rotate 1&#125;# system-specific logs may be configured here 用户自定义的配置文件： 保存在/etc/logrotate.d/下面，所以若是想要进行自己软件的日志切割则直接在这里进行编写自己的配置文件即可； 0x04 配置项说明nginx示例日志切割配置文件: 1234567891011121314/usr/local/nginx/logs/*.log &#123; daily dateext rotate 1 olddir /usr/local/nginx/other/logs missingok notifempty compress sharedscripts postrotate /bin/kill -USR1 $(cat /var/run/nginx.pid 2&gt;/dev/null) 2&gt;/dev/null ||: endscript&#125; 配置项说明： dateext : 文件后缀是日期格式,也就是切割后文件是:xxx.log-20150529(.gz) 这样,如果注释掉,切割出来是按数字递增,即前面说的 xxx.log-1(.gz) compress : 通过gzip 压缩转储旧的日志 nocompress : 不需要压缩时，用这个参数 copytruncate : 用于还在打开中的日志文件，把当前日志备份并截断 nocopytruncate : 备份日志文件但是不截断 create mode owner group：使用指定的文件模式创建新的日志文件 nocreate：不建立新的日志文件 delaycompress：和 compress 一起使用时，转储的日志文件到下一次转储时才压缩 nodelaycompress：覆盖 delaycompress 选项，转储同时压缩。 errors address：专储时的错误信息发送到指定的Email 地址 ifempty：即使是空文件也转储，这个是 logrotate 的缺省选项。 notifempty：如果是空文件的话，不转储 mail address：把转储的日志文件发送到指定的E-mail 地址 nomail：转储时不发送日志文件 olddir directory：转储后的日志文件放入指定的目录，必须和当前日志文件在同一个文件系统 noolddir：转储后的日志文件和当前日志文件放在同一个目录下 prerotate/endscript：在转储以前需要执行的命令可以放入这个对，这两个关键字必须单独成行 postrotate/endscript：在转储以后需要执行的命令可以放入这个对，这两个关键字必须单独成行 sharedscripts：所有的日志文件都轮转完毕后统一执行一次脚本 monthly: 日志文件将按月轮循。其它可用值为‘daily’，‘weekly’或者‘yearly’。 rotate count：指定日志文件删除之前转储的次数，0 指没有备份，5 指保留5 个备份 size size：当日志文件到达指定的大小时才转储，Size 可以指定 bytes (缺省)以及KB (sizek)或者MB missingok: 在日志轮循期间，任何错误将被忽略，例如“文件无法找到”之类的错误。 0x05 手动命令说明1234567891011用法: logrotate [OPTION...] &lt;configfile&gt; -d, --debug Don't do anything, just test (implies -v) -f, --force Force file rotation -m, --mail=command Command to send mail (instead of `/usr/bin/mail') -s, --state=statefile Path of state file -v, --verbose Display messages during rotation --version Display version informationHelp options: -?, --help Show this help message --usage Display brief usage message 示例1： 要调用为/etc/lograte.d/下配置的所有日志调用logrotate： 1logrotate /etc/logrotate.conf 示例2： 要为某个特定的配置调用logrotate 1logrotate /etc/logrotate.d/log-file 示例3： 使用-d选项以预演方式运行logrotate。要进行验证，不用实际轮循任何日志文件，可以模拟演练日志轮循并显示其输出。 1logrotate /etc/logrotate.d/log-file 示例4： 即使轮循条件没有满足，我们也可以通过使用-f选项来强制logrotate轮循日志文件，-v参数提供了详细的输出。 1logrotate -vf /etc/logrotate.d/log-file 0x06 简单示例：nginx.logrotate(error.log) 1234567891011/usr/local/nginx/logs/error.log &#123;dateextcreate#maxage 90rotate 60missingoksharedscriptspostrotate/bin/kill -USR1 `cat /var/run/nginx.pid`endscript&#125; php.logrotate(php-fpm.log、php-fpm.log.slow) 1234567891011/usr/local/php/var/log/php-fpm.log /usr/local/php/var/log/php-fpm.log.slow &#123;dateextcreate#maxage 90rotate 60missingoksharedscriptspostrotate/bin/kill -USR1 `cat /var/run/php-fpm.pid`endscript&#125; mysql.logrotate(slow-log、localhost.err) 123456789101112/var/lib/mysql/slow-log /var/lib/mysql/localhost.err &#123;dateextcreate# notifempty#maxage 90rotate 60missingoksharedscriptspostrotate/usr/local/mysql/bin/mysqladmin -uroot -p'password' flush-logsendscript&#125;]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux下进程后台运行方法]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2016%2F01%2F25%2Flinux%E5%AD%A6%E4%B9%A0-2016-01-25-linux%E8%BF%9B%E7%A8%8B%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文绝大部分都是摘抄自这里，我在这里做记录仅仅为了自己以后查阅的方便。 1. nohupnohup 的作用就是让提交的命令忽略hangup信号，nohup 命令的帮助信息： 12345678910111213141516171819202122用法：nohup 命令 [参数]... 或：nohup 选项忽略挂起信号运行指定的命令。 --help 显示此帮助信息并退出 --version 显示版本信息并退出If standard input is a terminal, redirect it from /dev/null.If standard output is a terminal, append output to &apos;nohup.out&apos; if possible,&apos;$HOME/nohup.out&apos; otherwise.If standard error is a terminal, redirect it to standard output.To save output to FILE, use &apos;nohup COMMAND &gt; FILE&apos;.注意：您的shell 内含自己的nohup 程序版本，它会覆盖这里所提及的相应版本。请查阅您的shell 文档获知它所支持的选项。请向bug-coreutils@gnu.org 报告nohup 的错误GNU coreutils 的主页：&lt;http://www.gnu.org/software/coreutils/&gt;GNU 软件一般性帮助：&lt;http://www.gnu.org/gethelp/&gt;请向&lt;http://translationproject.org/team/zh_CN.html&gt; 报告nohup 的翻译错误要获取完整文档，请运行：info coreutils &apos;nohup invocation&apos; 可见,nohup的使用时十分方便的，只需在要处理的命令前加上nohup即可，标准输出和标准错误缺省会被重定向到nohup.out文件中，一般我们可在结尾加上’&amp;’来将命令放入后台运行，也可以用 “&gt;/filename 2&gt;&amp;1” 来更改缺省的重定向文件名。 nohup示例： 1234567daodaoliang@daodaoliang-B85-HD3:/work/code/daodaoliang.github.com/_posts/linux学习$ nohup ping www.baidu.com &amp;[1] 26716nohup: 忽略输入并把输出追加到&quot;nohup.out&quot;daodaoliang@daodaoliang-B85-HD3:/work/code/daodaoliang.github.com/_posts/linux学习$ ps -ef | grep 26716daodaol+ 26716 20718 0 14:13 pts/5 00:00:00 ping www.baidu.comdaodaol+ 26721 20718 0 14:13 pts/5 00:00:00 grep --color=auto 26716daodaoliang@daodaoliang-B85-HD3:/work/code/daodaoliang.github.com/_posts/linux学习$ 2. setsidnohup无疑通过忽略HUP信号来使我们的进程避免中途被中断，但如果我们换个角度思考，如果我们的进程不属于接受HUP信号的终端的子进程，那么自然也就是不回收到HUP信号的影响了，setsid就能帮助我们做到这一点。 setsid 示例： 1setsid ping www.baidu.com 值得注意的是 上例中的进程ID(PID)为1839，即为用户的init进程，并不是当前终端进程； 3. &amp;这里还有一个关于 subshell 的小技巧，我们知道，将一个或者多个命名包含在 “()” 就能让这些命令在子shell中运行，从而扩展出很多有趣的功能，我们现在讨论的就是其中之一，当我们将 &amp; 也放入 () 之内，我们发现所提交的作业并不在作业列表中，也就是说无法通过 jobs来查看的，让我们来看看为什么这样就能躲过 hup 信号的影响把； subshell 示例： 1234daodaoliang@daodaoliang-B85-HD3:~$ (ping www.baidu.com &gt;/dev/null &amp;)daodaoliang@daodaoliang-B85-HD3:~$ ps -ef | grep pingdaodaol+ 24170 1839 0 10:58 pts/1 00:00:00 ping www.baidu.comdaodaol+ 24176 24096 0 10:58 pts/1 00:00:00 grep --color=auto ping 从上例中可以看出，新提交的任务的进程的父进程是 1839 即为 当前用户的Init进程，而不是当前终端进程，从而不在受当前终端的 hup 信号的影响了。 4. disown若果我们在没有事先使用 setsid 或者 nohup 的前提下就提交了命令时候就需要用 disdown 来进行补救； disown 使用方式： 用disown -h jobspec 来使某个作业忽略 hup 信号； 用disown -ah 来使所有作业都忽略 hup 信号； 用disown -rh 来使正在运行的作业忽略 hup 信号; 需要注意的是在使用 disown 之后，作业是被从作业列表里面移除的，我们不能使用 jobs 来查询到，但是使用 ps -ef 还是可以查询到； 需要注意的时这种方式的操作对象是作业，也就是说 disown 的操作对象是作业，如果一个任务没能以作业的形式运行则就需要进行特殊处理； 示例1 如果提交命令时已经用“&amp;”将命令放入后台运行： 123456daodaoliang@daodaoliang-B85-HD3:/work/code/daodaoliang.github.com$ ping www.baidu.com &gt;/dev/null &amp;[1] 515daodaoliang@daodaoliang-B85-HD3:/work/code/daodaoliang.github.com$ jobs[1]+ 运行中 ping www.baidu.com &gt; /dev/null &amp;daodaoliang@daodaoliang-B85-HD3:/work/code/daodaoliang.github.com$ daodaoliang@daodaoliang-B85-HD3:/work/code/daodaoliang.github.com$ disown -h %1 示例2 如果提交命令时未使用“&amp;”将命令放入后台运行，可使用 CTRL-z 和“bg”将其放入后台，再使用 “disown” : 123456789daodaoliang@daodaoliang-B85-HD3:~$ ping www.baidu.comPING www.a.shifen.com (61.135.169.125) 56(84) bytes of data.64 bytes from 61.135.169.125: icmp_seq=1 ttl=55 time=19.9 ms^Z[1]+ 已停止 ping www.baidu.comdaodaoliang@daodaoliang-B85-HD3:~$ jobs[1]+ 已停止 ping www.baidu.comdaodaoliang@daodaoliang-B85-HD3:~$ bg %1daodaoliang@daodaoliang-B85-HD3:~$ disown -h %1 5. screenscreen 提供了 ANSI/VT100 的终端模拟器，使它能够在一个真实终端下运行多个全屏的伪终端。screen 的参数很多，具有很强大的功能，我们在此仅介绍其常用功能以及简要分析一下为什么使用 screen 能够避免 HUP 信号的影响 使用 screen 很方便，有以下几个常用选项： 用screen -dmS session name来建立一个处于断开模式下的会话（并指定其会话名）。 用screen -list 来列出所有会话。 用screen -r session name来重新连接指定会话。 用快捷键CTRL-a d 来暂时断开当前会话。 当我们用“-r”连接到 screen 会话后，我们就可以在这个伪终端里面为所欲为，再也不用担心 HUP 信号会对我们的进程造成影响，也不用给每个命令前都加上“nohup”或者“setsid”了]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql全文索引简介]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%2F2016%2F01%2F14%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0-mysql%E4%B8%93%E9%A2%98-2016-01-14-mysql%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[工具安装本文所介绍的全文索引是基于mysql5.7版本的，官方相关文档在这里,本文也只是在文档和网上其他资料的基础上进行翻译整理。 语法: 123456789match (col1,col2,...) against (expr [search_modifier])search_modifier:&#123; in natural language mode | in natural language mode with query expansion | in boolean mode | with query expansion&#125; MySQL 已经支持全文索引搜索: mysql中的全文检索使用的是FULLTEXT类型的索引; Full-Text索引只能被用在InnoDB和MyISAm引擎的表上面，并且只能在CHAR ，VARCHAR和TEXT字段类型的列上; 在MySQL 5.7.6 中提供了内置的支持中日韩全文的NGRAM分析器，同时提供了针对日语的可安装的全文解析插件; FULLTEXT索引的定义可以在表用CREATE TABLE被创建时，或者ALTER TABLE 和 ALTER INDEX; 对于大数据集合，把数据插入一个有FULLTEXT索引的表要比把数据插入一个没有FULLTEXT表然后在表上机上FULLTEXT索引要慢（建议对于大数据量的表做全文索引时，先建立表然后把表上加上FULLTEXT索引） 有三种全文检索类型： 自然语言模式IN NATURAL LANGUAGE MODE，即通过MATCH AGAINST 传递某个特定的字符串来进行检索。 布尔模式IN BOOLEAN MODE，可以为检索的字符串增加操作符，例如“+”表示必须包含，“-”表示不包含，“*”表示通配符（这种情况， 即使传递的字符串较小或出现在停词中，也不会被过滤掉），其他还有很多特殊的布尔操作符，可以通过如下参数控制： 1234567mysql&gt; show variables like &apos;%ft_boolean_syntax%&apos;;+-------------------+----------------+| Variable_name | Value |+-------------------+----------------+| ft_boolean_syntax | + -&gt;&lt;()~*:&quot;&quot;&amp;| |+-------------------+----------------+1 row in set (0.00 sec) 查询扩展模式WITH QUERY EXPANSION, 这种模式是自然语言模式下的一个变种，会执行两次检索，第一次使用给定的短语进行检索，第二次是结合第一次相关性比较高的行进行检索。 创建全文索引： 123456CREATE TABLE test_article ( int id auto_increment primary key, varchar(45) title not null, text text_info not null, fulltext(`title`,`text_info`)) ENGINE= InnoDB; 或者 1create table ft_test(id int, content text, fulltext (content) with parser ngram); 修改配置文件 全局变量ngram_token_size指定了ngram分词法的词语长度，默认为2。ngram_token_size 是一个只读变量，每次修改它的值时都需要重建ngram算法的全文索引，否则改变不会生效； 在配置文件的 mysqld 标签下修改 ngram_token_size 即可；]]></content>
      <categories>
        <category>数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux下包管理说明]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2016%2F01%2F12%2Flinux%E5%AD%A6%E4%B9%A0-2016-01-12-linux%E5%B9%B3%E5%8F%B0%E4%B8%8B%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[主要的包管理家族 包管理系统 发行版(部分列表) Debian Style(.deb) Debian, Ubuntu, Xandros, Linspire Red Hat Style(.rpm) Fedora,CentOS,Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS 1.背景知识科普1.1 linux 中软件安装方式要么直接进行源码安装，要么用包管理工具对发行包进行安装，但是他们的共同之处在于: 都有配置文件,通过配置文件来改变程序的运行特征。 都拥有二进制的程序主体。 都自带库文件，供程序主体进行调用。 都带有帮助文件，对程序的使用方法进行说明。 1.2 软件的安装路径在自行下载源码进行编译安装时，是可以指定自定义的安装路径的，在使用包管理器时，都是按照自身预设的安装路径进行安装. 软件包的一般安装路径 文件路径 路径用途说明 / 系统根目录,在此安装的文件通常是OS在运行时需要调用到的程序 /usr 此目录一般情况下是提供基本服务的软件 /usr/local 此目录下一般情况是用户自行安装的第三方软件 系统相关的软件包的安装路径 文件路径 路径用途说明 /etc 配置文件路径 /bin 和 /sbin 二进制文件路径 /lib 库文件路径 系统提供服务相关的包安装路进 文件路径 路径用途说明 /etc 配置文件的路径 /usr/bin 和 /usr/sbin 二进制文件路径 /usr/lib 库文件路径 第三方软件包的安装路径 文件路径 路径用途说明 /usr/local/etc 配置文件路径 /usr/local/bin 和 /usr/local/sbin 二进制文件路径 /usr/local/lib 库文件路径 特别说明: 说明文件都要存放在 /usr/share/man 和 /usr/local/share/man 1.2 软件包的命名说明一般的软件包的组成形如(拿rpm包说明) name-version-release.arch.rpm 12345# name: 表示包的名称，包括主包名和分包名# version: 表示包的版本信息# release: 用于标识包本身的发行号，可以同时包含适用的操作系统# arch: 表示机器平台，noarch表示此包能安装到所有平台上面# 例如: gd-devel-2.0.35-11.el6.x86_64.rpm 12345# gd: 包的主名字# devel: 包的分包名字# 2.0.35: 表示版本信息，2为主板本号，0表示次版本信息，35为源码包的发行号，也叫做修订号，# 11.el6: 11 是rpm的发行号，el6表示REHL6# x86_64: 表示适合的平台 2. 主流发行版的软件包管理速查表 任务名称 Debian和Ubuntu等(apt系列) openSUSE(zypp) 安装包 apt-get install &lt;pkg&gt; zypper install &lt;pkg&gt; 卸载包 apt-get remove &lt;pkg&gt; zypper remove &lt;pkg&gt; yum erase &lt;pkg&gt; pacman -R &lt;pkg&gt; 更新包列表 apt-get update zypper refresh 更新系统所有包 apt-get upgrade zypper update 更新指定安装包 dkpg -i &lt;pkg&gt; rpm -Uvh &lt;pkg&gt; 列出源 cat /etc/apt/sources.list zypper repos 添加源 vim /etc/apt/sources.list zypper addrepo &lt;path&gt; 移除源 vim /etc/apt/sources.list zypper removerepo &lt;name&gt; 搜索包 apt-cache search &lt;pkg&gt; zypper search &lt;pkg&gt; 列出已安装的包 dpkg -l rpm -qa 任务名称 Fedora,CentOS(yum) Arch(pacman) 安装包 yum install &lt;pkg&gt; pacman -S &lt;pkg&gt; 卸载包 yum erase &lt;pkg&gt; pacman -R &lt;pkg&gt; 更新包列表 yum check-update pacman -Sy 更新系统所有包 yum update pacman -Su 更新系统指定包 rpm -Uvh &lt;pkg&gt;或者yum update &lt;pkg&gt; rpm -Uvh &lt;pkg&gt; 列出源 yum repolist cat /etc/pacman.conf 添加源 add &lt;repo&gt; to /etc/yum.repos.d/ vim /etc/pacman.conf 移除源 remove &lt;repo&gt; from /etc/yum.repos.d vim /etc/pacman.conf 搜索包 yum search &lt;pkg&gt; pacman -Qs &lt;pkg&gt; 列出已安装的包 rmp -qs pacman -Qii 3. RPM 包的基本操作3.1 RPM 命令常用参数1234567891011RPM 常规使用方式 rpm -? package.rpm ,其中 -? 为操作参数(更多信息，请查阅帮助 $man rpm)-q 在系统中查询软件或查询指定rpm包的内容信息-i 在系统中安装软件-U 在系统中升级软件-e 在系统卸载软件-h 用#(hash)符显示rpm安装过程-v 详述安装过程-p 表明对rpm包进行查询，通常和其他参数同时使用，如： -qlp 查询某个rpm包中的所有文件列表 -qip 查询某个rpm包的内容信息 3.2 RPM 命令参数使用方法 安装RPM包 1rpm -ivh package.rpm 升级RPM包 1rpm -Uvh package.rpm 卸载RPM包 1rpm -ev package 查询RPM包中包含的文件列表命令 1rpm -qlp package 查询RPM包瀚内容信息命令 1rpm -qip package 查询系统中所有已安装RPM包 1rpm -qa 4. DEB 包的基本操作4.1 DPKG命令常用参数1234567DPKG 的常规使用方法为 dpkg -? package.deb, 其中-? 为安装参数(更多信息，请查阅帮助$man dpkg)-l 在系统中查询软件内容信息--info 在系统中查询软件或查询指定rpm包的内容信息-i 在系统中安装/升级软件-r 在系统中卸载软件，不删除配置文件-P 在系统中卸载软件以及其配置文件 4.2 DPKG命令参数使用方法 安装DEB包 1sudo dpkg -i package.deb 升级DEB包 1sudo dpkg -i package.deb(和安装命令一样) 卸载DEB包 123sudo dpkg -r package.deb # 不卸载配置文件或者sudo dpkg -P package.deb # 卸载配置文件 查询DEB包中包含的文件列表命令 1sudo dpkg-deb -c package.deb 查询DEB包中包含的内容信息命令 1sudo dpkg --info package.deb 查询系统中所有已安装DEB包 1dpkg -l package 5. FAQ5.1 可以手动强制不进行 RPM/DEB 的依赖性关系检查吗？ RPM 可以。使用 –nodeps 辅助参数，则安装过程将不理会依赖性关系限制，强制安装目标包，如： 1# rpm -i --nodeps package_a.rpm DEB 可以。使用— force-depends 辅助参数，如： 1sudo dpkg -i --force-depends package_a.deb 5.2 RPM 中的 –force 是干什么用的？RPM 中的默认安装规则是不允许同一个包多次安装，也不允许降级安装。使用–force辅助参数不考虑以上因素，强制安装RPM包。但是，–force无法强制安装一个不满足系统依赖性关系的包（此时需要用到–nodeps参数）。使用方式如下： 1rpm -i --force package_a.rpm 5.3 RPM/DPKG 支持远程安装吗？ RPM 是。 RPM 支持 HTTP 和 FTP 协议，如： 1rpm -Uvh ftp://user:pass@ftpserver/package.rpm DPKG 最新的基于 DEB 包的系统中，远程安装通常被更先进的 APT 代替。 5.4 可以从 RPM/DPKG 中抽取个别文件吗？ RPM 是。可以使用 rpm2cpio 工具来提取文件：http://www.rpm.org/max-rpm/s1-rpm-miscellania-rpm2cpio.html DPKG 是。可以使用 dpkg-deb 工具来提取文件： 1dpkg-deb --extract ibm_lotus_notes-8.5.i586.deb $dir( 目标目录 ) 5.5 RPM/DPKG 提供包安装成功的验证机制吗？ RPM 是。可以使用 -V 参数进行验证。 DPKG Debian 系统通常使用 debsums 工具参数进行验证。 5.6 RPM/DPKG 提供包安全签名吗？ RPM 是。可以使用 –import 导入与软件同时发布的 GPG KEY, 接着使用 -K 命令来验证包的安全性，如： 1rpm --import pub_ibm_lotus_notes.gpg # rpm -K ibm_lotus_notes-8.5.i586.rpm 返回信息 : ibm_lotus_notes-8.5.i586.rpm: (sha1) dsa sha1 md5 gpg OK DPKG DPKG 不提供原生的 Key 验证机制。可以使用 debsigs 和 debsigs-verify，详情请见：http://man.ddvip.com/os/debiansecuring-howto/ch7.zh-cn.html 5.7 如果 RPM 的底层数据库损坏，RPM 还能使用吗？ RPM 如果底层数据库损坏，RPM 将无法正常使用。此时最常用的解决方法是重构数据库： 1rm -f /var/lib/rpm/__* ; rpm -vv --rebuilddb DPKG DPKG 本身不提供底层数据库恢复机制。它的数据库以文件形式保存在 /var/lib/dpkg 目录中。及时地备份这个目录是最好的预防数据库损坏措施。 5.8 可以查询系统中已经安装的某个文件属于哪个 RPM 包吗？ RPM 可以。使用 -qf 参数 , 如在安装了 Notes8.5 的系统中： 1rpm -qf /opt/ibm/lotus/notes/notes 返回信息 : Ibm_lotus_notes-8.5-20081211.1920 DPKG 可以。使用— search 参数 , 如在安装了 Notes8.5 的系统中： 1dpkg --search /opt/ibm/lotus/notes/notes 返回信息 : ibm-lotus-notes: /opt/ibm/lotus/notes/notes 5.9 可以查询 RPM 包的安装时间吗？ RPM 可以。可使用 –last 查询。如： 1rpm -qa --last 返回信息 : 系统中所有软件的安装时间。 DPKG DPKG 不提供直接的查询参数，但是可以用过查询 dpkg 的日志文件实现这个功能。如： 1cat /var/log/dpkg.log | grep "\ install\ "]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CentOS6.5配置防火墙]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2016%2F01%2F06%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2016-01-06-CentOS6-5%E9%85%8D%E7%BD%AE%E9%98%B2%E7%81%AB%E5%A2%99%2F</url>
    <content type="text"><![CDATA[检查iptables状态检查服务状态: 12$ service iptables statusiptables: Firewall is not running. 上面的状态说明iptables服务是没有被安装的,进行iptables的安装: 1$ yum install -y iptables 启动iptables: 1service iptables start 查看当前iptables的配置: 1$ iptables -L -n 清除默认的防火墙规则1234567891011# 允许所有请求iptables -P INPUT ACCEPT# 清空默认所有规则iptables -F# 清空自定义的所有规则iptables -X# 计数器置零iptables -Z 配置规则1234567891011121314151617181920212223242526# 允许本地的数据包发送iptables -A INPUT -i lo -j ACCEPT# SSH 端口22iptables -A INPUT -p tcp --dport 22 -j ACCEPT# FTP 端口21iptables -A INPUT -p tcp --dport 21 -j ACCEPT# WEB 端口80iptables -A INPUT -p tcp --dport 80 -j ACCEPT# 自定义的端口 XXXX iptables -A INPUT -p tcp --dport xxxx -j ACCEPT# 允许 pingiptables -A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT # 允许对外请求的返回包iptables -A INPUT -m state --state ESTABLISHED -j ACCEPT# 添加指定IP的所有tcp请求iptables -A INPUT -p tcp -s 112.114.123.12 -j ACCEPT #过滤所有非以上规则的请求iptables -P INPUT DROP 保存规则查看配置是否正确 1iptables -L -n 另开一个ssh链接，确保可以登录 保存 1$ service iptables save 添加自启动 1$ chkconfig iptables on]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux下netcat命令中无效参数e的解决方案]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2015%2F12%2F29%2Flinux%E5%AD%A6%E4%B9%A0-2015-12-29-netcat%E5%91%BD%E4%BB%A4%E6%97%A0%E6%95%88%E5%8F%82%E6%95%B0e%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[错误信息如下: 123nc: invalid option — ‘e’This is nc from the netcat-openbsd package. An alternative nc is availablein the netcat-traditional package. 修复方案如下： 在终端执行： 1$ sudo rm /etc/alternatives/nc &amp;&amp; sudo ln -s /bin/nc.traditional /etc/alternatives/nc 思路如下： 12345678$ ls -ld /bin/nclrwxrwxrwx 1 root root 20 12月 11 2014 /bin/nc -&gt; /etc/alternatives/nc$ ls -ld /etc/alternatives/nclrwxrwxrwx 1 root root 19 12月 29 17:10 /etc/alternatives/nc -&gt; /bin/nc.traditional 至此我们就找到了真正需要的nc了,然后够解决方案里面就是对其做了一个软连接]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[日常linux命令之nc]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2015%2F12%2F28%2Flinux%E5%AD%A6%E4%B9%A0-2015-12-28-%E6%97%A5%E5%B8%B8linux%E5%91%BD%E4%BB%A4%E4%B9%8Bnc%2F</url>
    <content type="text"><![CDATA[这是一篇我觉得很不错的文章，故而我进行了翻译，原文在这里 通常被称为TCP/IP的 瑞士军刀，Netcat的是一种非常通用的Linux工具，它可以让用TCP/IP协议做任何操作。这是一个系统管理员在网络相关的故障排除和实验时最喜欢的工具之一。 在本教程中，我分享了一些有用的netcat的例子，当然我所描述的例子的使用场景有限，如果你也是经常地使用netcat,随时分享你的使用技巧。 注意：当你绑定nc到 “众所周知”的端口(0~1023)时你需要root权限，其他情况用普通用户权限即可。 1. 测试远程主机的端口是否开放123$ nc -vn 123.125.114.144 5000nc: connect to 123.125.114.144 5000 (tcp) failed: Connection refused 1234$ nc -v 123.125.114.144 22Connection to 123.125.114.144 22 port [tcp/ssh] succeeded!SSH-2.0-OpenSSH_5.3 2. 发送UDP测试包到远程主机下面的命令将会发送一个UDP测试包到远程主机的5000端口，并且超时时间为1秒： 1$ echo -n "foo" | nc -u -w1 123.125.114.144 5000 3. 对远程主机进行端口扫描下面的命令会对远程主机的[1~1000] 和 [2000~3000]端口进行扫描，检查端口是否打开 1$ nc -vnz -w2 123.125.114.144 1-1000 2000-3000 4. 从主机 hostA.com 复制一个文件(例如 my.jpg)到主机 hostB.com在主机 hostB.com (接收者)： 1nc -lp 5000 &gt; my.jpg 在主机 hostB.com (发送者): 1nc hostA.com 5000 &lt; my.jpg 5. 从主机 hostA.com 传输整个文件夹(包裹里面的内容) 到主机 hostB.com在主机 hostB.com(接收者)上： 1$ nc -l 5000 | tar -xvf - 在主机 hostA.com(发送者)上： 1$ tar -cvf - /path/to/dir hostB.com 5000 6. 对远程主机的UPD端口进行扫描1$ nc -vnzu 123.125.114.144 1-65535 7. 启动一个静态网站服务输入如下命令将会启动一个WEB服务，把test.html启动在 8000端口 1$ while true;do nc -lp 8000 &lt; test.html;done 现在输入 http://:8000/test.html 就可以访问它，注意问了使用众所周知的80端口，你需要在运行nc时用root权限，如下所示： 1$ whilr true;do sudo nc -lp 80 &lt; test.html;done 8. (不安全)两台主机间聊天在其中一台主机(192.168.233.203): 1$ nc -lp 5000 在另外一台主机上: 1$ nc 192.168.233.203 5000 在运行了上述的命令后，键入任何操作都回在另外的主机上显示 9. 运行一个 “远程shell” 允许你在远程主机上执行任何命令在远程主机上(192.168.233.203): 1$ nc -lp 5000 -e /bin/bash 在本地主机上执行: 1$ nc 192.168.233.208 5000 在运行了上述命令周你就能在本地主机的终端运行任何命令了，这个命令将会被在远程主机的终端上执行，并且命令的输出也会出现在本地主机上，这个设置通常用来作为远程主机的后门程序。 10. 为一个常规网站创建一个WEB代理(例如 google.com)12$ mkfifo proxypipe$ while true; do nc -l 5000 0&lt;proxypipe | nc www.google.com 80 1&gt; proxypipe; done 上述命令将会创建一个名为 proxypipe 的管道，并且用nc重定向所有 TCP/5000 的链接到 http://www.google.com ,通过这个设置你就可以通过http://127.0.0.1:5000来访问google 11. 味一个常规网站创建一个SSL代理(例如 google.com)1234$ mkfifo proxypipe$ mkfifo proxypipe2$ nc -l 5000 -k &gt; proxypipe &lt; proxypipe2 &amp;$ while true do; openssl s_client -connect www.google.com:443 -quiet &lt; proxypipe &gt; proxypipe2; done 上述命令会用 nc 创建一个SSL代理链接到Google.com 12. 在服务器上流式化视频文件，并且从客户端用mplayer进行观看视频流在视频服务器(192.168.233.208)： 1$ cat video.avi | nc -l 5000 在客户端： 1$ nc 192.168.233.208 5000 | mplayer -vo x11 -cache 3000 - 13. 用IPV6监听一个TCP端口下面的命令会让nc在今听一个TCP地址时 使用 IPv6 协议，这在测试IPv6的配置时非常有用； 1$ nc -6 -l 5000 1$ sudo netstat -nap | grep 5000]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[reStructuredText 的基本语法]]></title>
    <url>%2F%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86%2F2015%2F12%2F22%2F%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86-2015-12-22-reStructuredText%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[reStructuredText 官方网址, 打不开吧!!!!!! fuck GFW 这里是Sphinx中关于reStructuredText的翻译，本文也是从里面挑拣自己平时回经常用到的语法进行示例化记录。 以下内容纯属虚构，图片也是随手在知乎上巴拉的头像 1.提示类信息123456789101112131415161718192021222324252627282930313233343536.. note:: 我是note 信息.. attention:: 我是attention信息.. caution:: 我是caution信息.. warning:: 我是warning信息.. tip:: 我是tip信息.. important:: 我是important信息.. hint:: 我是hint信息.. error:: 我是error信息.. danger:: 我是danger信息 2.标题类信息在reST中标题非常简单，只要在标题上(下)使用非字母和数字的七位元ASCII记录下标线（或上标线）即可，你不需担心标题会用什么格式，只要在相同位置使用相同标记即可。可用的字符有：! “ # $ % &amp; ‘ ( ) * + , - . / : ; &lt; = &gt; ? @ [ ] ^ _ ` { | } ~。 1234567891011121314151617181920212223============文章标题测试============***************章节标题测试***************小节标题测试===============子节标题测试------------------子子节标题测试^^^^^^^^^^^^^^^^^^^^^段落标题测试&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;段落标题测试****************** 3.字体类信息123456789**加黑字体***意大利斜体*\ 转义字体(后面跟着一个空格意味着后面是一个空格)``原始形态的字体而非Docutils处理后的文字，通常以等宽字体出现 Hello nami!`` 4.段落在reST中，段落只要在中间隔开一行即可，Docutils会自动判别各个段落，例如： 5.代码块1234567891011121314151617181920212223242526``I am code``我是代码测试快:: # coding: utf-8 __author__ = &apos;daodaoliang&apos; from flask import Flask from flask_restful import Resource, Api app = Flask(__name__) api = Api(app) # noinspection PyMethodMayBeStatic class Api_HelloWorld_V1(Resource): def get(self): return &#123;&apos;hello&apos;: &apos;world&apos;&#125; api.add_resource(Api_HelloWorld_V1, &apos;/&apos;) if __name__ == &apos;__main__&apos;: app.run(debug=True) 6. 表格123456789101112131415161718192021222324---------------------+------------------------+------------+----------+----------+| Header row, column 1 | Header 2 | Header 3 | Header 4 || (header rows optional) | | | |+========================+============+==========+==========+| body row 1, column 1 | column 2 | column 3 | column 4 |+------------------------+------------+----------+----------+| body row 2 | ... | ... | |+------------------------+------------+----------+----------+或者更为简洁的方式===== ===== ====== Inputs Output------------ ------ A B A or B===== ===== ======False False FalseTrue False TrueFalse True TrueTrue True True===== ===== ====== 7. 超链接 在后面加上下划线，只要在指定目标即可形成超链接 1234`我的博客啦啦啦啦`_... _我的博客啦啦啦啦: http://daodaoliang.github.io(这里不仅仅可以时网址，也可以时内部标题，实现内部的跳转) 内嵌网址的形式( 链接显示文字 &lt;网址&gt;_ ) 1`我的博客啦 &lt;http://daodaoliang.github.io&gt;`_. 直接写网址 1daodaoliang.github.io 无名超链接 1234567`我是一个很长长长长长长长……的文字`__我是后面的文字.. __: daodaoliang.github.io或者更简洁的:__ daodaoliang.github.io` 内部链接 1`内部标题`_ 间接链接 1234567`内部链接`_.. _内部链接: daodaoliang.github.io`我是链接`_.. _我是链接: 内部链接_ 无内容链接 123.. _回页首:`回页首`_ 8. 上下标123456781. 上标:123:sup:`2` 意思123的上标为22. 下标:123:sub:`2` 意思123的下表为2 9. 图片资源 段落间插入图片 123456789.. image:: https://pic4.zhimg.com/6a97b4a68a4db3f1d3ae66cd1638965f.jpeg :scale: 100 :height: 120 :width: 160 :align: left :alt: I&apos;m a girl. :target: https://pic4.zhimg.com/6a97b4a68a4db3f1d3ae66cd1638965f.jpeg 这个女孩我也不认识，只是在知乎随手巴拉的啦，哈哈哈哈(这个功能需要PIL库) 文字间插入图片 1234这里有\|内部图片|\，哈哈哈哈哈.. |内部图片| image:: https://pic4.zhimg.com/6a97b4a68a4db3f1d3ae66cd1638965f.jpeg]]></content>
      <categories>
        <category>项目工程管理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[gitflow分支管理模型(转载)]]></title>
    <url>%2F%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86%2F2015%2F11%2F05%2F%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86-2015-11-05-gitflow%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[重要的事情要加黑： 这里是原博客地址 gitflow 知识介绍gitflow的分支类型： master分支（1个） develop分支（1个） feature分支。同时存在多个 release分支。同一时间只有1个，生命周期很短，只是为了发布。 hotfix分支。同一时间只有1个。生命周期较短，用了修复bug或小粒度修改发布。 在这个模型中，master和develop都具有象征意义。master分支上的代码总是稳定的（stable build），随时可以发布出去。develop上的代码总是从feature上合并过来的，可以进行Nightly Builds，但不直接在develop上进行开发。当develop上的feature足够多以至于可以进行新版本的发布时，可以创建release分支。 release分支基于develop，进行很简单的修改后就被合并到master，并打上tag，表示可以发布了。紧接着release将被合并到develop；此时develop可能往前跑了一段，出现合并冲突，需要手工解决冲突后再次合并。这步完成后就删除release分支。 当从已发布版本中发现bug要修复时，就应用到hotfix分支了。hotfix基于master分支，完成bug修复或紧急修改后，要merge回master，打上一个新的tag，并merge回develop，删除hotfix分支。 由此可见release和hotfix的生命周期都较短，master/develop虽然总是存在但却不常使用。 以上就是gitflow的基本概念了。下面是nvie（gitflow的提出者，一个荷兰人！） A successful Git branching model（发布于2010年月5日）一文的笔记。 从右看起： 时间轴. feature（玫红）。主要是自己玩了，差不多的时候要合并回develop去。从不与master交互。 develop（黄色）。主要是和feature以及release交互。 release（绿色）。总是基于develop，最后又合并回develop。当然对应的tag跑到master这边去了。 hotfix（红色）。总是基于master，并最后合并到master和develop。 master（蓝色）。没有什么东西，仅是一些关联的tag，因从不在master上开发。 接下来nvie说道自己喜爱git，因git改变了人们对合并/分支（merge/branches）的看法。从集中式的代码管理工具过来的人感到释放了（beware of merge conflicts, they bite you，注意合并冲突，它们会跳出来咬你！）。 gitflow实例手动安装安装gitflow 12345git clone --recursive git://github.com/nvie/gitflow.gitcd gitflow/sudo make installls /usr/local/bin/git-flow/usr/local/bin/git-flow 命令安装gitflow 1apt-get install git-flow 官方的安装文档 到项目根目录下执行gitflow，因为之前修改没有commit，所以gitflow初始化失败： 12git flow initfatal: Working tree contains unstaged changes. Aborting. commit后再次进行gitflow初始化： 1234567891011121314151617$ git commit -a -m "update Bash"[master 8f5b874] update Bash 4 files changed, 71 insertions(+), 5 deletions(-)$ git flow initWhich branch should be used for bringing forth production releases? - masterBranch name for production releases: [master] Branch name for "next release" development: [develop] How to name your supporting branch prefixes?Feature branches? [feature/] Release branches? [release/] Hotfix branches? [hotfix/] Support branches? [support/] Version tag prefix? [] 一路回车下来，各个分支名都按默认的设置。最后，当前分支已经被切换到了develop： 123$ git branch* develop master 建立一个新的feature。git flow新建了功能分支feature/blog_builder，并在develop的基础上checkout了新分支： 12345$ git flow feature start blog_builder$ git branch develop* feature/blog_builder master 开发完成后执行如下命令： 12345$ git flow feature finish blog_builderSummary of actions:- The feature branch 'feature/blog_builder' was merged into 'develop'- Feature branch 'feature/blog_builder' has been removed- You are now on branch 'develop' 正如这条命令的总结所言，git flow为我们做了3件事： 把feature/blog_builder合并到了develop。 删除了feature/blog_builder分支。 切换回develop分支。 接下来发布一个正常的版本： 1$ git flow release start v0.5 一旦需要发布的版本确认无误可以发布后，执行命令： 1234567$ git flow release finish v0.5summary of actions:- Latest objects have been fetched from 'origin'- Release branch has been merged into 'master'- The release was tagged 'v0.5'- Release branch has been back-merged into 'develop'- Release branch 'release/v0.5' has been deleted 注意release/v0.5被合并到了master和develop分支，并打了个v0.5的tag，然后被删除，最后切换回了develop分支： 123 $ git branch* develop master 发布时只需将tag为v0.5的版本checkout出来部署即可： 12$ git tagv0.5 当上线后发现v0.5的bug，可以进行hotfix： 1$ git flow hotfix start v0.5.1 此时gitflow从master分支上拉出一个hotfix/v0.5.1的分支，接下来在新分支上修改bug。最后执行命令： 1$ git flow hotfix finish v0.5.1 这样hotfix/v0.5.1被merge到master/develop分支，打好v0.5.1这个tag，删除这个分支，切换回develop分支。 之后又是新一次的轮回，启动正常的feature开发。]]></content>
      <categories>
        <category>项目工程管理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以正确的方式开源 Python 项目(转载)]]></title>
    <url>%2F%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%2F2015%2F11%2F04%2F%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0-2015-11-04-%E4%BB%A5%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%96%B9%E5%BC%8F%E5%BC%80%E6%BA%90Python%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[重要的事情要加黑: 原文地址 大多数Python开发者至少都写过一个像工具、脚本、库或框架等对其他人也有用的工具。我写这篇文章的目的是让现有Python代码的开源过程尽可能清晰和无痛。我不是简单的指——“创建一个GitHub库，提交，在Reddit上发布，每天调用它”。在本文的结尾，你可以把现有的代码转换成一个能够鼓励他人使用和贡献的开源项目。然而每一个项目都是不同的，但其中将现有代码开源的流程对所有的Python项目都是类似的. 1. 工具和概念 1.1. 项目布局(目录结构) 1.2. setuptools 和 setup.py文件 1.3. git 版本控制 1.4. github 项目管理 1.4.1 github issues的如下作用: 1.4.1.1 bug跟踪 1.4.1.2 请求新特性 1.4.1.3 计划好的新特性 1.4.1.4 发布或者版本管理 1.5. git-flow git工作流 1.6. py.test 单元测试 1.7. tox 标准化测试 1.8. sphinx 自动生成html文档 1.9. TravisCI 持续测试集成 1.10 ReadTheDocs 持续文档集成 1.11 Cookiecutter 为开始下一个项目自动生成这些步骤 1.1 项目布局 当准备一个项目时，正确合理的布局(目录结构) 是十分重要的。一个合理的布局意味着参与者不必花时间来寻找某些代码的位置，凭直觉就可以找到文件的位置。因为我们在处理一个项目，就意味着可能需要到处移动一些东西，让我们从顶层开始，大多数项目都有很多的顶层文件(如：setup.py, README.md, requirements等等)。每个项目至少应该又下面三个目录： doc 目录，包括项目文档 项目目录， 以项目命名，存储实际的Python包 test目录 为了更好的理解文件该如何组织，这里时我的简单项目：sandman 布局快照： 12345678910111213141516171819202122232425$ pwd~/code/sandman$ tree.|- LICENSE|- README.md|- TODO.md|- docs| |-- conf.py| |-- generated| |-- index.rst| |-- installation.rst| |-- modules.rst| |-- quickstart.rst| |-- sandman.rst|- requirements.txt|- sandman| |-- __init__.py| |-- exception.py| |-- model.py| |-- sandman.py| |-- test| |-- models.py| |-- test_sandman.py|- setup.py 如你所看到那样，这里有一些顶层文件，一个docs目录（建立一个空目录，因为sphinx会将生成的文档放到这里），一个sandman目录，以及一个在sandman目录下的test目录 1.2 setuptools 和 setup.py 文件setup.py文件，你可能已经在其它包中看到过，被distuils包用来安装Python包的。对于任何一个项目，它都是一个很重要的文件，因为它包含了版本，包依赖信息，PyPi需要的项目描述，你的名字和联系信息，以及其它一些信息。它允许以编程的方式搜索安装包，提供元数据和指令说明让工具如何做。 setuptools包（实际上就是对distutils的增强）简单化了建立发布python包。使用setuptools给python包打包，和distutils打包没什么区别。这实在是没有任何理由不使用它。 setup.py应该放在你的项目的根目录。setup.py中最重要的一部分就是调用setuptools.setup，这里面包含了此包所需的所有元信息。这里就是sandman的setup.py的所有内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768from __future__ import print_functionfrom setuptools import setup, find_packagesfrom setuptools.command.test import test as TestCommandimport ioimport codecsimport osimport sysimport sandmanhere = os.path.abspath(os.path.dirname(__file__))def read(*filenames, **kwargs): encoding = kwargs.get('encoding', 'utf-8') sep = kwargs.get('sep', '\n') buf = [] for filename in filenames: with io.open(filename, encoding=encoding) as f: buf.append(f.read()) return sep.join(buf) long_description = read('README.txt', 'CHANGES.txt') class PyTest(TestCommand): def finalize_options(self): TestCommand.finalize_options(self) self.test_args = [] self.test_suite = True def run_tests(self): import pytest errcode = pytest.main(self.test_args) sys.exit(errcode) setup( name='sandman', version=sandman.__version__, url='http://github.com/jeffknupp/sandman/', license='Apache Software License', author='Jeff Knupp', tests_require=['pytest'], install_requires=['Flask&gt;=0.10.1', 'Flask-SQLAlchemy&gt;=1.0', 'SQLAlchemy==0.8.2', ], cmdclass=&#123;'test': PyTest&#125;, author_email='jeff@jeffknupp.com', description='Automated REST APIs for existing database-driven systems', long_description=long_description, packages=['sandman'], include_package_data=True, platforms='any', test_suite='sandman.test.test_sandman', classifiers = [ 'Programming Language :: Python', 'Development Status :: 4 - Beta', 'Natural Language :: English', 'Environment :: Web Environment', 'Intended Audience :: Developers', 'License :: OSI Approved :: Apache Software License', 'Operating System :: OS Independent', 'Topic :: Software Development :: Libraries :: Python Modules', 'Topic :: Software Development :: Libraries :: Application Frameworks', 'Topic :: Internet :: WWW/HTTP :: Dynamic Content', ], extras_require=&#123; 'testing': ['pytest'], &#125;) 大多数内容浅显易懂，可以从setuptools文档查看到，所以我只会触及”有趣”的部分。使用sandman.version和gettinglong_description方法（尽管我也记不住是哪一个，但是却可以从其它项目的setup.py中获得）来减少我们需要写的引用代码。相反，维护项目的版本有三个地方(setup.py, 包自身的version， 以及文档)，我们也可以使用包的version来填充setup里面的version参数 long_description被Pypi在你项目的PyPI主页当做文档使用。这里有其他一个文件，README.md，其中包含几乎相同的内容，我使用pandoc依据README.md自动生成README.rst，因此我们只需看README.rst就行了，并将它的内容设置为long_description。 py.test (上面讨论过) 中有一个特殊的条目（pytest类）设置允许Python检查setup.py可否正常工作。这段代码直接来自py.test指导文档。文件中的其他内容都是在设置文档中描述的安装参数。 其他的setup.py参数: 有一些sandman 用不到的启动参数，在你的包里可能会用到。举个例子，你可能正在分派一些脚本并希望你的用户能够从命令行执行。在这个例子中，脚本会和你其他的代码一起安装在正常的site-packages位置。用户安装完后，没有其他的简单方法运行它。基于这一点，setup可以带有一个的脚本参数来指明Python脚本应该如何安装。在包中安装一个调用go_foo.py的脚本，这个用来启动的调用包括下面这行： 1scripts = ['go_foo.py'], 确保在脚本中填入相对路径，并不仅仅是一个名称 (如scripts = [‘scripts/foo_scripts/go_foo.py’]).同样，你的脚本应该以”shebang”行和”python”开始，如下： 1#! /usr/bin/env python distutils将会在安装过程中自动用当前解释器位置取代这一行。如果你的包比我们这里讨论的要复杂，你可在官方文档中参看启动工具文档和分布python模块。在这两者中，你可以解决一些你可能会遇到的问题。 1.3 代码管理：git, 项目管理: github 在“以正确的方式开始一个Django项目”中，我建议版本控制使用git 或者 mercurial。如果对于以共享与贡献的项目来说，只有一个选择：git。事实上，从长远来说，如果你想人们能使用和参与贡献，那么不仅使用git很有必要，而且，你也能够使用GitHub来管理维护你的项目。 这并不是夸大其词（尽管很多人会以它为嚼头）。然而，管它好与差，git和GitHub事实上已经成为了开源项目的实际标准了。GitHub是很多潜在的贡献者最想注册的和最熟悉的。所以，我深信，这并不是掉以轻心，而是深思熟虑的产物。 新建一个README.md文件: 在GitHub的代码仓库中，项目的描述是从项目的根目录中的:README.md文件获取的。这个文件应该包含下面几点： 项目描述 项目ReadTheDocs页面连接[@Lesus 注：请查看 工具与概念 ] 一个用来显示当前构建状态的TravisCI按钮。 “Quickstart” 文档 (怎么快速安装和使用你的项目) 若有非python依赖包，请列举它以及怎么安装它 它(README)读起来很傻的感觉，但是确是一个很重要的文件。它可能是你未来的用户或者贡献者首先从它了解你的项目的。花些时间来写一个清楚明白的说明和使用GFM（GitHubFlavoredMarkdown）来使它更好看。实际上，如果使用原生的Markdown来写文档不爽，那么可以在Github上使用立即预览来创建或者修改这个文件。我们还没触及列表中的第二和第三项（ReadTheDocs和TravisCI），你会在接下来看到。 使用”Issues”页: 跟生活中的很多事情一样，你投入GitHub越多，你收获的越多。因为用户会使用GitHub的“Issues”页面反馈bug，使用该页面跟踪特性要求和改进是很有意义的。 更重要的是，它允许贡献者以一种优雅的方式看到：一个可能实现特性的列表以及自动化的管理合并请求流程（pull request）。GitHub的issues可以与评论、你项目里的其他issues及其他项目里的issues等交织，这使得“issues”页面成为一个有关所有bug修复、改进和新特性要求信息汇总的地方。确保“Issues”及时更新，至少及时回应新的问题。作为一个贡献者，没有什么比修复bug后看着它呈现在issues页面并等待着被合并更有吸引力的了。 1.4 使用git-flow这个明智的git工作流为使事情对自己和贡献者更容易，我建议使用非常流行的git-flow分支模型。 概述: 开发分支是你工作的主要分支，它也是将成为下一个release.feature的分支，代表着即将实现的新特性和尚未部署的修复内容（一个完整的功能分支有开发分支合并而来）。通过release的创建更新master。 安装: 按照你系统平台的git-flow安装指导操作，在这里。 安装完后，你可以使用下附命令迁移你的已有项目： 1$ git flow init Branch细节: 脚本将询问你一些配置问题，git-flow的默认建议值可以很好的工作。你可能会注意到你的默认分支被设置成develop。现在，让我们后头描述一下git-flow…嗯，flow，更详细一点。这样做的最简单的方法是讨论一下不同的分支及模型中的分支类型。 Master: master分支一直是存放“生产就绪”的代码。所有的提交都不应该提交到master分支上。当然，master分支上的代码只会从一个产品发布分支创建并结束后合并进来。这样在master上的代码一直是可以发布为产品的。并且，master也是一直处于可预计的状态，所以你永远不需要担心如果master分支修改了而某一个其他分支没有相应的修改。 Develop: 你的大部分工作是在develop分支上完成的。这个分支包含所有的完成的特性和修改的bug以便发布；每日构建或者持续集成服务器需要针对develop分支来进行，因为它代表着将会被包含在下一个发布里的代码。 对于一次性的提交，可以随便提交到develop上。 特性: 对于一些大的特性，就需要创建一个特性分支。特性分支从develop分支创建出来。它们可以是对于下一个发布的一些小小的增强或者更进一步的修改。而这，依然需要从现在开始工作。为了从一个新的分支上开始工作，使用： 1$ git flow feature start &lt;feature name&gt; 这命令创建了一个新的分支：feature/。通常会把代码提交到这个分支。当特性已经完成并且准备好发布的时候，它就应当用一下的命令将它合并会develop分支 1$ git flow feature finish &lt;feature name&gt; 这会把代码合并进develop分支，并且删除 feature/分支. Release: 一个release分支是当你准备好进行产品发布的时候从develop分支创建出来的。使用以下的命令来创建： 1$ git flow release start &lt;release number&gt; 注意，这是发布版本号第一次创建。所有完成的，准备好发布的分支必须已经合并到develop分支上。在release分支创建后，发布你的代码。任何小的bug修改需要提交到 release/分支上。当所有的bug被修复之后，运行以下的命令： 1$ git flow release finish &lt;release number&gt; 这个命令会把你的release/ 分支合并到master和develop分支，这意味着你永远不需要担心这几个分支会缺少一些必要的产品变更（可能是因为一个快速的bug修复导致的）。 Hotfix 然而hotfix分支可能会很有用，在现实世界中很少使用，至少我是这样认为的。hotfix就像master分支下创建的feature分支： 如果你已经关闭了release分支，但是之后又认识到还有一些很重要的东西需要一起发布，那么就在master分支（由$git flow release finish 创建的标签）下创建一个hotfix分支，就像这样： 1$ git flow hotfix start &lt;release number&gt; 当你完成改变和增加你的版本号使之独一无二(bump your version number)，然后完成hotfix分支： 1$ git flow hotfix finish &lt;release number&gt; 这好像一个release分支（因为它本质上就是一种release分支），会在master和develop分支上提交修改。我猜想它们很少使用的原因是因为已经存在一种可以给已发布的代码做出修改的机制：提交到一个未完成的release分支。当然，可能一开始，团队使用git flow release finish .. 太早了，然后第二天又发现需要快速修改。随着时间的推移，他们就会为一个release 分支多留一些时间，所以，不会再需要hotfix分支。另一种需要hotfix分支情况就是如果你立即需要在产品中加入新的特性，等不及在develop分支中加入改变。不过（期望）这些都是小概率事件。 1.5 virtualenv和virtualenvwrapper an Bicking的virtualenv工具事实上已经成为了隔离Python环境的标准途径了。它的目标很简单：如果你的一台机子中有很多Python项目，每个都有不同的依赖（可能相同的包，但是依赖不同的版本），仅仅在一个Python安装环境中管理这些依赖几乎是不可能的。virtualenv创建了一个“虚拟的”Python安装环境，每个环境都是相互隔离的，都有自己的site-packages, distribute和 使用pip安装包到虚拟环境而不是系统Python安装环境。 而且在你的虚拟环境中来回切换只是一个命令的事。Doug Hellmann的virtualenvwrapper使创建和管理多个虚拟环境更容易的隔离工具。让我们继续前进，马上安装这两个工具： 1234$ pip install `virtualenvwrapper`...Successfully installed `virtualenvwrapper` `virtualenv` `virtualenv`-clone stevedoreCleaning up... 如你所见，后者依赖于前者，所以简单的安装virtualenvwrapper就足够了。注意，如果你使用的是Python3，PEP-405通过venv包和pyvenv命令提供了Python原生虚拟环境的支持，在python3.3中已实现。你应该使用这个而不是前面提到的工具。一旦你安装了virtualenvwrapper，你需要添加一行内容到你的.zhsrc文件(对bash用户来说是.bashrc文件)： 1$ echo "source /usr/local/bin/virtualenvwrapper.sh" &gt;&gt; ~/.zshrc 这样在你的shell中增加了一些有用的命令（记得第一次使用时source一下你的.zshrc文件以使它生效）。虽然你可以使用mkvirtualenv命令直接创建一个virtualenv，但使用mkproject [OPTIONS] DEST_DIR创建一个“项目”将更有用。因为我们已经有一个现有的项目了，所有我们只需为我们的项目创建一个新的virtualenv，下附命令可以达到这效果： 12345$ mkvirtualenv ossprojectNew python executable in ossproject/bin/pythonInstalling setuptools............done.Installing pip...............done.(ossproject)$ 你会注意到你的shell提示符在你的virtualenv之后（我的是“ossproject”，你可以使用任何你喜欢的名字）。现在任何通过pip安装的模块将安装到你的virtualenv下的site-packages。要停止在你的项目上工作并切换回系统使用deactivate命令。你会看到命令提示符前你的virtualenv名字消失了。要重新回到你的项目上工作的话运行workon ，你会回到你的virtualenv。 除了简单地为你的项目创建virtualenv，你还会用它做其他事：生成你的requirements.txt文件，使用requirements.txt文件和-r标识可安装所有项目的依赖项。要创建该文件，在你的virtualenv运行以下命令（一旦你代码和virtualenv一起工作，就是那里）： 1(ossproject)$ pip freeze &gt; requirements.txt 你会得到一个所有你项目需要模块的列表，它以后可以被setup.py文件使用列出你的依赖关系。这里有一点需要注意：我经常在requirements.txt中将“==”改为“&gt;=“，这样代表“我正使用包的任何的后来版本”。你是否应该或需要在项目这样做取决于实际情况，但我应该指出来。将requirements.txt提交到你的git代码库中。此外，你现在可以添加这里的列出的包列表作为install_requirement参数的值到setup.py文件中的distutils.setup。这样做我们可以确保当上传包到PyPI后，它可以被pip安装并自动解决依赖关系。 1.6 使用py.test测试 在Python的自动测试系统里有两个主要的Python标准单元测试包（很有用）的替代品：nose和py.test。两个方案都将单元测试拓展的易于使用且增加额外的功能。说真的，哪个都是很好的选择。我更喜欢py.test因为下述几个原因： 支持setuptools/distutils项目 Python的setup.py测试技能可一直可以用 支持常见的断言（assert）语法 (而不是需要记住所有jUnit风格的断言函数) 更少的样板 支持多种测试风格 单元测试 文档测试 nose测试 注意 如果你已经有了一个自动测试的解决方案那继续使用它吧，跳过这一节。但请记住以后的章节你将被认为在使用py.test测试，这可能会影响到配置值。 测试安装 在测试目录里，无论你如何决定都要有这个目录，创建一个名为test_.py的文件。py.test的测试发现机制将把所有test_前缀的文件当做测试文件处理（除非明确告知）。在这个文件里放什么很大程度上取决于你。写测试是一个很大的话题，超出这篇文章的范围。最重要的，测试对你的和潜在的捐助者都是有用的。应该标识清楚每个用例是测试的什么函数。用例应该以相同的“风格”书写，这样潜在的贡献者不必猜测在你的项目中他/她应该使用三种测试风格中的哪种。 覆盖测试 自动化测试的覆盖率是一个有争议的话题。一些人认为它给出了错误的保证是一个毫无意义的度量，其他人认为它很有用。在我看在，我建议如果你已经使用自动化测试但从来没有检查过你的测试覆盖率，现在做这样一个练习。使用py.test，我们可以使用Ned Batchelder的覆盖测试工具。使用pip安装pytest-cov。如果你之前这样运行你的测试： 1$ py.test 你可以通过传递一些新的标识生成覆盖率报告，下面是运行sandman的一个例子： 12345678910111213141516171819202122$ py.test --cov=path/to/package$ py.test --cov=path/to/package --cov-report=term --cov-report=html====================================================== test session starts =======================================================platform darwin -- Python 2.7.5 -- pytest-2.3.5plugins: covcollected 23 itemssandman/test/test_sandman.py .......................---------------------------------------- coverage: platform darwin, python 2.7.5-final-0 -----------------------------------------Name Stmts Miss Cover--------------------------------------------------sandman/__init__ 5 0 100%sandman/exception 10 0 100%sandman/model 48 0 100%sandman/sandman 142 0 100%sandman/test/__init__ 0 0 100%sandman/test/models 29 0 100%sandman/test/test_sandman 114 0 100%--------------------------------------------------TOTAL 348 0 100%Coverage HTML written to dir htmlcov=================================================== 23 passed in 1.14 seconds =========================================================== 当然不是所有项目都有100%的测试覆盖率（事实上，正如你读到的，sandman没有100%覆盖），但获得100%的覆盖率是一个有用的练习。它能够揭示我之前没有留意的缺陷与重构机会。因为，作为测试本身，自动生成的测试覆盖报可以作为你持续集成的一部分。如果你选择这样做，部署一个标记来显示当前的测试覆盖率会为你的项目增加透明度（大多数时候会极大的鼓励他人贡献） 1.7 使用Tox进行标准化测试 一个所有Python项目维护者都需要面对的问题是兼容性。如果你的目标是同时支持Python 2.x和Python 3.x（如果你目前只支持Python 2.x，应该这样做），实际中你如何确保你的项目支持你所说的所有版本呢？毕竟，当你运行测试时，你只使用特定的版本环境来运行测试，它很可能在Python2.7.5中运行良好但在Python 2.6和3.3出现问题。 幸运的是有一个工具致力于解决这个问题。tox提供了“Python的标准化测试”，它不仅仅是在多个版本环境中运行你的测试。它创造了一个完整的沙箱环境，在这个环境中你的包和需求被安装和测试。如果你做了更改在测试时没有异常，但意外地影响了安装，使用Tox你会发现这类问题。 通过一个.ini文件配置tox：tox.ini。它是一个很容易配置的文件，下面是从tox文档中摘出来的一个最小化配置的tox.ini： 123456# content of: tox.ini , put in same dir as setup.py[tox]envlist = py26,py27[testenv]deps=pytest # install pytest in the venvscommands=py.test # or 'nosetests' or ... 通过设置envlist为py26和py27，tox知道需要在这两种版本环境下运行测试。tox大约支持十几个“默认”的环境沙箱，包括jython和pypy。tox这个强大的工具使用不同的版本进行测试，在不支持多版本时可配置警示。deps是你的包依赖列表。你甚至可以让tox从PyPI地址安装所有或一些你依赖包。显然，相当多的想法和工作已融入了项目。实际在你的所有环境下运行测试现在只需要四个按键： 1$ tox 一个更复杂的设置: 12345678910111213141516171819202122232425262728293031323334[tox]envlist=py27, py34 [testenv]deps= pytest coverage pytest-covsetenv= PYTHONWARNINGS=all [pytest]adopts=--doctest-modulespython_files=*.pypython_functions=test_norecursedirs=.tox .git [testenv:py27]commands= py.test --doctest-module [testenv:py34]commands= py.test --doctest-module [testenv:py27verbose]basepython=pythoncommands= py.test --doctest-module --cov=. --cov-report term [testenv:py34verbose]basepython=python3.4commands= py.test --doctest-module --cov=. --cov-report term 这个配置文件依旧比较简单。而结果呢？ （我从输出列表里截取了一部分）。如果想看我的测试对一个环境的覆盖率，只需运行： setuptools整合 tox可以和setuptools整合，这样python的setup.py测试可以运行你的tox测试。将下面的代码段放到你的setup.py文件里，这段代码是直接从tox的文档里拿来的： 1234567891011121314151617181920from setuptools.command.test import test as TestCommandimport sysclass Tox(TestCommand): def finalize_options(self): TestCommand.finalize_options(self) self.test_args = [] self.test_suite = True def run_tests(self): #import here, cause outside the eggs aren't loaded import tox errcode = tox.cmdline(self.test_args) sys.exit(errcode) setup( #..., tests_require=['tox'], cmdclass = &#123;'test': Tox&#125;, ) 现在Python的setup.py测试将下载tox并运行它。真的很酷并且很节省时间。 1.8 Sphinx文档生成器Sphinx是由pocoo团队开发的工具[@Lesus 注：pocoo团队开发了很多优秀的产品：如Flask, Jinja2等等]。它已经用来生成Python官方文档和大多数流行的Python包的文档。它以更容易的方式从Python代码中自动产生Python文档。 使用它完成工作 Sphinx不用了解Python程序以及怎样从它们中提取出来。它只能翻译reStructuredText文件，也就意味着你的代码文档的reStructuredText译文需要让Sphinx知道才能工作，但是管理维护所有的.py文件[至少是函数和类的部分]的reStructuredText译文显然是不可行的。 幸运的是，Sphinx有一个类似javadoc的扩展，叫做autodoc,可以用来从你的代码文档中萃取出reStructuredText。为了能够充分利用Sphinx和autodoc的能力，你需要已一种特别的方式格式化你的文档。特别是，你需要使用Sphinx的Python指令时。这里就是使用reStructuredText指令来为一个函数生成文档，使输出结果的HTML文档更漂亮： 1234567891011121314151617181920def _validate(cls, method, resource=None):"""Return ``True`` if the the given *cls* supports the HTTP *method* foundon the incoming HTTP request.:param cls: class associated with the request's endpoint:type cls: :class:`sandman.model.Model` instance:param string method: HTTP method of incoming request:param resource: *cls* instance associated with the request:type resource: :class:`sandman.model.Model` or None:rtype: bool"""if not method in cls.__methods__: return False class_validator_name = 'validate_' + method if hasattr(cls, class_validator_name): class_validator = getattr(cls, class_validator_name) return class_validator(resource)return True 文档需要花费一点功夫，但是为了你的使用者，这个付出是值得的。好吧，好的文档使一个可用的项目去其糟粕。Sphinx的autodoc扩展让我们可以使用很多指令，而这些指令可以自动的从你文档中生成文档。 安装 确认将Sphinx安装在你的virtualenv内，因为文档在项目里也是按版本来的。Sphinx不同的版本可能会产生不同的HTML输出。通过将其安装在你的virtualenv内，你可以以受控的方式升级你的文档。我们要保持我们的文档在docs文件夹，将文档生成到docs/generated文件夹。在项目的根目录运行以下命令将根据你的文档字符自动重构文本文档： 1sphinx-apidoc -F -o docs &lt;package name&gt; 这将产生一个包含多个文档文件的docs文件夹。此外，它创建了一个叫conf.py的文件，它将负责你的文档配置。你还会发现一个Makefile，方便使用一个命令（生成html）构建HTML文档。在你最终生成文档之前，确保你已经在本地安装了相应的包（尽管可以使用pip，但python setup.py develop是最简单的保持更新的方法），否则sphinx-apidoc无法找到你的包。 配置:conf.py conf.py文件创建用来控制产生的文档的各个方面。它自己会很好生成文档，所以我只简单地触及两点。 版本和发布 首先，确保你的版本和发布版本号保持最新。这些数字会作为生成的文档的一部分显示，所以你不希望它们远离了实际值。保持你的版本最新的最简单方式就是在你的文档和setup.py文件中都从你的包的version属性读取。我从Flask的conf.py借用过来配置sandman的conf.py： 123456789101112import pkg_resourcestry: release = pkg_resources.get_distribution('sandman').versionexcept pkg_resources.DistributionNotFound: print 'To build the documentation, The distribution information of sandman' print 'Has to be available. Either install the package into your' print 'development environment or run "setup.py develop" to setup the' print 'metadata. A virtualenv is recommended!' sys.exit(1)del pkg_resources version = '.'.join(release.split('.')[:2]) 这就是说，为了让文档产生正确的版本号，你只需在你的项目的虚拟环境中简单的需要运行$python setup.py develop即可。现在你只需担心保持version为最新，因为setup.py会使用它。 html_theme 考虑到更改default到html_theme，我更喜欢原生态的东西，显然这是一个个人喜好的问题。我之所以提出这个问题是因为Python官方文档在Python 2和Python 3将默认主题更改为Pydoc主题（后者的主题是一个自定义主题仅在CPython源代码中可用）。对一些人来说，默认的主题使一个项目看起来“老”一些。 1.9 PyPI PyPI，Python包索引（以前被称为“Cheeseshop”）是一个公开可用的Python包中央数据库。PyPI是你的项目发布的地方。一旦你的包（及其相关的元数据）上传到PyPI，别人通过pip或easy_instal可以下载并安装它。这一点得强调一下：即使你的项目托管在GitHub，直到被上传到PyPI后你的项目才是有用的。当然，有些人可以复制你的git库任何直接手工安装它，但更多的人想使用pip来安装它。 最后的一步 如果你已经完成了所有的前面部分中的步骤，你可能急着想把你的包上传到PyPI，供其他人使用！先别急着做上述事情，在分发你的包之前，有一个叫做cheesecake的有用的工具有助于运行最后一步。它分析你的包并指定一个分类的数字分数。它衡量你的包在打包、安装、代码质量以及文档的数量和质量方面是否容易/正确。除了作粗略衡量的“准备”，cheesecake在完整性检查方面很优秀。你会很快看到你的setup.py文件是否有错或者有没有忘记为一个文件制作文档。我建议在上传每个项目到PyPI之前运行一下它，而不仅只是第一个。 初始化上传 现在，你已经确定了你的代码不是垃圾和当人们安装它时不会崩溃，让我们把你的包放到PyPI上吧！你将会通过setuptools和setup.py脚本交互。如果这是第一次上传到PyPI，你将首先注册它： 1$ python setup.py register 注意：如果你还没有一个免费的PyPI账户，你将需要现在去注册一个，才能注册这个包[@Lesus 注：注册之后还需要到邮箱去验证才行]。在你已使用了上面注册之后，你就可以创建发布包和上传到PyPI了: 1$ python setup.py sdist upload 上面这个命令建立一个源码发布版(sdist)，然后上传到PyPI.如果你的包不是纯粹的Python（也就是说，你有二进制需要编译进去），你就需要发布一个二进制版，请看setuptools文档，了解更多。 发布及版本号 PyPI使用发行版本模型来确定你软件包的哪个版本是默认可用的。初次上传后，为使你软件包的每次更新后在PyPI可用，你需要指定一个新版本号创建一个发布。版本号管理是一个相当复杂的课题，PEP有专门的内容：PEP 440——版本识别和依赖指定。我建议参照PEP 400指南（明显地），但如果你选择使用不同版本的方案，在setup.py中使用的版本比目前PyPI中的版本“高”，这样PyPI才会认为这是一个新版本。 工作流 将你的第一个发布版本上传到PyPI后，基本的工作流程如下： 继续在你的项目上工作 (比如修复bug，添加新特性等等) 确保测试通过 在git-flow中创建一个发布分支“冻结”你的代码 在你项目的init.py文件里更新versionnumber版本变量 多次测试运行setup.py，将新版本上传到PyPI 用户希望你保持足够的更新频率以修复bug。你要管理好你的版本号，不要“过于频繁”的发布。记住：你的用户不会手工维护他们每个安装模块的不同的版本。 1.10 使用TravisCI持续集成 持续集成是指一个项目中所有变化不断整合的过程（不是周期性的批量更新）。就我们而言，这意味每次我们GitHub提交时，我们通过测试运行来发现是否有什么异常，正如你想象的，这是一个非常有价值的实践。不要有“忘记运行测试”的提交。如果你的提交通不过测试，你将收到一封电子邮件被告知。 TravisCI是一种使GitHub项目持续集成更容易的服务。如果你还没有账号到这看一下注册一个，完成这些之后，在我们进入CI之前我们先需要创建一个简单的文件。 通过.travis.yml配置 在TravisCI上的不同项目通过一个.travis.yml文件来配置，这个文件在项目的根目录。简要地说，我们需要告诉Travis： 我们项目使用的语言是什么 它使用的是语言的哪个版本 使用什么命令安装它 使用什么命令运行项目的测试 这些都是很直接的东西。下面是sandman.travis.yml的内容： 1234567891011language: pythonpython: - "2.7"install: - "pip install -r requirements.txt --use-mirrors" - "pip install coverage" - "pip install coveralls"script: - "coverage run --source=sandman setup.py test"after_success: coveralls 在列出语言和版本后，我们告诉Travis如何安装我们的包。在install这行，确认包含下面这行： 1- "pip install -r requirements.txt --use-mirrors" 这是pip安装我们项目的要求（如果有必要的话使用PyPI镜像站点）。另外的两行内容是sandman特有的。它使用一个额外的服务（coveralls.io）来连续监测测试用例的覆盖率，这不是所有项目都需要的。 script：列出能运行该项目测试的命令。与上面一样，sandman还需要做一些额外的工作。你的项目需要的只有Python的setup.py测试，after_success部分也可以一块删掉。 一旦你提交了这个文件并在TravisCI中激活了你的项目的，push到GitHub。一会儿后，你会看到一个基于你最近提交的编译结束结果。如果成功了，你的编译呈现“绿色”和并且状态页会显示编译通过。你可以看到你项目在任何时间的编译历史。这对对人开发特别有用，在历史页可以看到特定开发者出错和编译的频率… 你还会收到一封通知你编译成功的电子邮件。当然你也可以设置只有在出错或错误被修复时才有邮件通知，但编译输出结果相同时也不会发送。这是非常有用的，你在不必被无用的“编译通过！”邮件淹没的同时在发生改变仍会收到警示。 1.11 用ReadTheDocs做持续文档集成 尽管PyPI有一个官方文档站点（pythonhosted.org），但是ReadTheDocs提供了一个更好的体验。为什么？ReadTheDocs有针对GitHub非常棒的集成。当你注册ReadTheDocs的时候，你就会看到你的所有GitHub 代码库。选择合适的代码库，做一些小幅的配置，那么你的文档就会在你每次提交到GitHub之后自动重新生成。 配置你的项目应该是一个很直观的事情。只有一些事需要记住，尽管，这里有一个配置字段的列表，对应的值可能不一定是你直接用得上的： Repo: https://github.com/github_username/project_name.git Default Branch:develop Default Version:latest Python configuration file: (leave blank) Usevirtualenv: (checked) Requirements file:requirements.txt Documentation Type: Sphinx HTML 1.12 DRY 不要重复你自己 现在你已经完成了对于一个现存代码基础的所有艰难的开源工作，你可能不会想在开始一个新项目的时候把这些事重来一遍。幸运的是，你并不需要这么做。有Andrey Roy的Cookiecutter工具（我链接到了Python版本，尽管还有一些不同语言的版本在the main repo)） Cookiecutter是一个命令行工具能够自动执行新建项目的一些步骤来做这篇文章里提到的一些事情。 Daniel Greenfeld ( @pydanny )写了一篇很好的关于它的博客并且提到了如何与这篇文章里提到的实践联系上。你可以从这里看看这篇文章： Cookiecutter: Project Templates Made Easy . 结论我们已经介绍了所有用来开源一个Python包的命令，工具和服务。当然，你可以直接把它扔到GitHub上并且说“自己安装它”，但是没人会这么做。并且你仅仅是开发源代码并不算是真正的开源软件。 另外，你可能不会为你的项目吸引外部贡献者。通过这里列出的方法来设立你的项目，你就已经创建了一个容易维护的Python包并且会鼓励大家来使用和贡献代码。而这，就是开源软件的真正精神，不是吗？]]></content>
      <categories>
        <category>开源框架学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入研究tornado框架---tornado入门]]></title>
    <url>%2F%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%2F2015%2F11%2F04%2F%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0-2015-11-04-%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6tornado%E6%A1%86%E6%9E%B6-tornado%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>开源框架学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[centos 6.5 搭建ftp 服务器]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2015%2F10%2F10%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2015-10-10-CentOS6-5%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[0x00 如何快速的搭建简易的资源发布站开启简易的python http服务器12cd /home/your_pathpython -m SimpleHTTPServer 8000 开启防火墙的对应端口1vim /etc/sysconfig/iptables 增加对应的端口就好 0x01 知识储备FTP通道解释 FTP包含了两个通道，一个叫控制通道，一个叫数据通道； 控制通道：控制通道是和FTP服务器进行沟通的通道，连接FTP，发送FTP指令都是通过控制通道来完成的。 数据通道：数据通道是和FTP服务器进行文件传输或者列表的通道。 FTP协议中，控制连接均有客户端发起，而数据连接有两种工作方式：PORT方式和PASV方式 FTP数据通道的主动被动方式 PORT模式(主动方式) FTP 客户端首先和FTP Server的TCP 21端口建立连接，通过这个通道发送命令，客户端需要接收数据的时候在这个通道上发送PORT命令。 PORT命令包含了客户端用什么端口(一个大于1024的端口)接收数据。在传送数据的时候，服务器端通过自己的TCP 20端口发送数据。 FTP server必须和客户端建立一个新的连接用来传送数据。 PASV模式(被动方式) 在建立控制通道的时候和PORT模式类似，当客户端通过这个通道发送PASV 命令的时候，FTP server打开一个位于1024和5000之间的随机端口并且通知客户端在这个端口上传送数据的请求，然后FTP server 将通过这个端口进行数据的传送，这个时候FTP server不再需要建立一个新的和客户端之间的连接传送数据。 vsftpd的配置文件说明 文件 注释 /etc/vsftpd/vsftpd.conf 主配置文件 /usr/sbin/vsftpd Vsftpd的主程序 /etc/rc.d/init.d/vsftpd 启动脚本 /etc/pam.d/vsftpd PAM认证文件（此文件中file=/etc/vsftpd/ftpusers字段，指明阻止访问的用户来自/etc/vsftpd/ftpusers文件中的用户） /etc/vsftpd/ftpusers 禁止使用vsftpd的用户列表文件。记录不允许访问FTP服务器的用户名单，管理员可以把一些对系统安全有威胁的用户账号记录在此文件中，以免用户从FTP登录后获得大于上传下载操作的权利，而对系统造成损坏。（注意：linux-4中此文件在/etc/目录下） /etc/vsftpd/user_list 禁止或允许使用vsftpd的用户列表文件。这个文件中指定的用户缺省情况（即在/etc/vsftpd/vsftpd.conf中设置userlist_deny=YES）下也不能访问FTP服务器，在设置了userlist_deny=NO时,仅允许user_list中指定的用户访问FTP服务器。（注意：linux-4中此文件在/etc/目录下） /var/ftp 匿名用户主目录；本地用户主目录为：/home/用户主目录，即登录后进入自己家目录 /var/ftp/pub 匿名用户的下载目录，此目录需赋权根chmod 1777 pub（1为特殊权限，使上载后无法删除） /etc/logrotate.d/vsftpd.log Vsftpd的日志文件 主配置文件说明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140 # 是否允许匿名登录FTP服务器，默认设置为YES允许 # 用户可使用用户名ftp或anonymous进行ftp登录，口令为用户的E-mail地址。 # 如不允许匿名访问则设置为NO anonymous_enable=YES # 是否允许本地用户(即linux系统中的用户帐号)登录FTP服务器，默认设置为YES允许 # 本地用户登录后会进入用户主目录，而匿名用户登录后进入匿名用户的下载目录/var/ftp/pub # 若只允许匿名用户访问，前面加上#注释掉即可阻止本地用户访问FTP服务器 local_enable=YES# 是否允许本地用户对FTP服务器文件具有写权限，默认设置为YES允许 write_enable=YES # 掩码，本地用户默认掩码为077 # 你可以设置本地用户的文件掩码为缺省022，也可根据个人喜好将其设置为其他值 #local_umask=022# 是否允许匿名用户上传文件，须将全局的write_enable=YES。默认为YES #anon_upload_enable=YES # 是否允许匿名用户创建新文件夹 #anon_mkdir_write_enable=YES# 是否激活目录欢迎信息功能 # 当用户用CMD模式首次访问服务器上某个目录时，FTP服务器将显示欢迎信息 # 默认情况下，欢迎信息是通过该目录下的.message文件获得的 # 此文件保存自定义的欢迎信息，由用户自己建立 #dirmessage_enable=YES # 是否让系统自动维护上传和下载的日志文件 # 默认情况该日志文件为/var/log/vsftpd.log,也可以通过下面的xferlog_file选项对其进行设定 # 默认值为NO xferlog_enable=YES# Make sure PORT transfer connections originate from port 20 (ftp-data). # 是否设定FTP服务器将启用FTP数据端口的连接请求 # ftp-data数据传输，21为连接控制端口 connect_from_port_20=YES # 设定是否允许改变上传文件的属主，与下面一个设定项配合使用 # 注意，不推荐使用root用户上传文件 #chown_uploads=YES# 设置想要改变的上传文件的属主，如果需要，则输入一个系统用户名 # 可以把上传的文件都改成root属主。whoever：任何人 #chown_username=whoever # 设定系统维护记录FTP服务器上传和下载情况的日志文件 # /var/log/vsftpd.log是默认的，也可以另设其它 #xferlog_file=/var/log/vsftpd.log# 是否以标准xferlog的格式书写传输日志文件 # 默认为/var/log/xferlog，也可以通过xferlog_file选项对其进行设定 # 默认值为NO #xferlog_std_format=YES # 以下是附加配置，添加相应的选项将启用相应的设置 # 是否生成两个相似的日志文件 # 默认在/var/log/xferlog和/var/log/vsftpd.log目录下 # 前者是wu_ftpd类型的传输日志，可以利用标准日志工具对其进行分析；后者是vsftpd类型的日志 #dual_log_enable# 是否将原本输出到/var/log/vsftpd.log中的日志，输出到系统日志 #syslog_enable # 设置数据传输中断间隔时间，此语句表示空闲的用户会话中断时间为600秒 # 即当数据传输结束后，用户连接FTP服务器的时间不应超过600秒。可以根据实际情况对该值进行修改 #idle_session_timeout=600# 设置数据连接超时时间，该语句表示数据连接超时时间为120秒，可根据实际情况对其个修改 #data_connection_timeout=120 # 运行vsftpd需要的非特权系统用户，缺省是nobody #nopriv_user=ftpsecure# 是否识别异步ABOR请求。 # 如果FTP client会下达“async ABOR”这个指令时，这个设定才需要启用 # 而一般此设定并不安全，所以通常将其取消 #async_abor_enable=YES # 是否以ASCII方式传输数据。默认情况下，服务器会忽略ASCII方式的请求。 # 启用此选项将允许服务器以ASCII方式传输数据 # 不过，这样可能会导致由"SIZE /big/file"方式引起的DoS攻击 #ascii_upload_enable=YES #ascii_download_enable=YES# 登录FTP服务器时显示的欢迎信息 # 如有需要，可在更改目录欢迎信息的目录下创建名为.message的文件，并写入欢迎信息保存后 #ftpd_banner=Welcome to blah FTP service. # 黑名单设置。如果很讨厌某些email address，就可以使用此设定来取消他的登录权限 # 可以将某些特殊的email address抵挡住。 #deny_email_enable=YES# 当上面的deny_email_enable=YES时，可以利用这个设定项来规定哪些邮件地址不可登录vsftpd服务器 # 此文件需用户自己创建，一行一个email address即可 #banned_email_file=/etc/vsftpd/banned_emails # 用户登录FTP服务器后是否具有访问自己目录以外的其他文件的权限 # 设置为YES时，用户被锁定在自己的home目录中，vsftpd将在下面chroot_list_file选项值的位置寻找chroot_list文件 # 必须与下面的设置项配合 #chroot_list_enable=YES# 被列入此文件的用户，在登录后将不能切换到自己目录以外的其他目录 # 从而有利于FTP服务器的安全管理和隐私保护。此文件需自己建立 #chroot_list_file=/etc/vsftpd/chroot_list # 是否允许递归查询。默认为关闭，以防止远程用户造成过量的I/O #ls_recurse_enable=YES# 是否允许监听。 # 如果设置为YES，则vsftpd将以独立模式运行，由vsftpd自己监听和处理IPv4端口的连接请求 listen=YES # 设定是否支持IPV6。如要同时监听IPv4和IPv6端口， # 则必须运行两套vsftpd，采用两套配置文件 # 同时确保其中有一个监听选项是被注释掉的 #listen_ipv6=YES# 设置PAM外挂模块提供的认证服务所使用的配置文件名，即/etc/pam.d/vsftpd文件 # 此文件中file=/etc/vsftpd/ftpusers字段，说明了PAM模块能抵挡的帐号内容来自文件/etc/vsftpd/ftpusers中 #pam_service_name=vsftpd # 是否允许ftpusers文件中的用户登录FTP服务器，默认为NO # 若此项设为YES，则user_list文件中的用户允许登录FTP服务器 # 而如果同时设置了userlist_deny=YES，则user_list文件中的用户将不允许登录FTP服务器，甚至连输入密码提示信息都没有 #userlist_enable=YES/NO # 设置是否阻扯user_list文件中的用户登录FTP服务器，默认为YES #userlist_deny=YES/NO# 是否使用tcp_wrappers作为主机访问控制方式。 # tcp_wrappers可以实现linux系统中网络服务的基于主机地址的访问控制 # 在/etc目录中的hosts.allow和hosts.deny两个文件用于设置tcp_wrappers的访问控制 # 前者设置允许访问记录，后者设置拒绝访问记录。 # 如想限制某些主机对FTP服务器192.168.57.2的匿名访问，编缉/etc/hosts.allow文件，如在下面增加两行命令： # vsftpd:192.168.57.1:DENY 和vsftpd:192.168.57.9:DENY # 表明限制IP为192.168.57.1/192.168.57.9主机访问IP为192.168.57.2的FTP服务器 # 此时FTP服务器虽可以PING通，但无法连接 tcp_wrappers=YES]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[后台开发语言比较]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2015%2F10%2F09%2Flinux%E5%AD%A6%E4%B9%A0-2015-10-09-%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux命令行艺术]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2015%2F09%2F24%2Flinux%E5%AD%A6%E4%B9%A0-2015-06-01-linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%89%BA%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[命令行的艺术 必读 基础 日常使用 文件及数据处理 系统调试 一行代码 冷门但有用 仅限 MacOS X 系统 更多资源 免责声明 授权条款 熟练使用命令行是一种常常被忽视或被认为难以掌握的技能，但实际上，它可以提高你作为工程师的灵活性以及生产力。本文是一份我在 Linux 上工作时发现的一些关于命令行的使用的小技巧的摘要。有些小技巧是非常基础的，而另外一些则是相当复杂的甚至晦涩难懂的。这篇文章并不长，但当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。 这里的大部分内容首次 出现于 Quora，但考虑到这里的人们都具有学习的天赋且乐于接受别人的建议，使用 Github 来做这件事是更佳的选择。如果你在本文中发现了错误或者存在可以改善的地方，请果断提交 Issue 或 Pull Request！(当然在提交前请看一下必读节和已有的 PR/issue）。 必读涵盖范围： 这篇文章对刚接触命令行的新手以及具有命令行使用经验的人都有用处。本文致力于做到覆盖面广（尽量包括一切重要的内容），具体（给出最常见的具体的例子）以及简洁（避免一些不必要的东西以及一些偏题的可以在其他地方翻阅到文献的东西）。 每个小技巧在某个特定情境下都是基本的或能够显著地节约时间。 本文为 Linux 所写，除了仅限 MacOS X 系统节。其它节中的大部分内容都适用于其它 Unix 系统或 MacOS 系统，甚至 Cygwin。 本文关注于交互式 Bash，尽管很多技巧适用于其他 shell 或 Bash 脚本。 本文包括了“标准的”Unix 命令和需要安装特定包的命令，只要它们足够重要。 注意事项： 为了能在一页内展示尽量多的东西，一些具体的信息会被间接的包含在引用页里。聪明机智的你如果掌握了使用 Google 搜索引擎的基本思路与命令，那么你将可以查阅到更多的详细信息。使用 apt-get／yum／dnf／pacman／pip／brew（以及其它合适的包管理器）来安装新程序。 使用 Explainshell 去获取相关命令、参数、管道等内容的解释。 基础 学习 Bash 的基础知识。具体来说，输入 man bash 并至少全文浏览一遍; 它很简单并且不长。其他的 shell 可能很好用，但 Bash 功能强大且几乎所有情况下都是可用的 （ 只学习 zsh，fish 或其他的 shell 的话，在你自己的电脑上会显得很方便，但在很多情况下会限制你，比如当你需要在服务器上工作时）。 学习并掌握至少一个基于文本的编辑器。通常 Vim （vi） 会是你最好的选择。 学会如何使用 man 命令去阅读文档。学会使用 apropos 去查找文档。了解有些命令并不对应可执行文件，而是Bash内置的，可以使用 help 和 help -d 命令获取帮助信息。 学会使用 &gt; 和 &lt; 来重定向输出和输入，学会使用 | 来重定向管道。明白 &gt; 会覆盖了输出文件而 &gt;&gt; 是在文件未添加。了解标准输出 stdout 和标准错误 stderr。 学会使用通配符 * （或许再算上 ? 和 {…}） 和引用以及引用中 &#39; 和 &quot; 的区别。 熟悉 Bash 任务管理工具：&amp;，ctrl-z，ctrl-c，jobs，fg，bg，kill 等。 了解 ssh，以及基本的无密码认证，ssh-agent，ssh-add 等。 学会基本的文件管理：ls 和 ls -l （了解 ls -l 中每一列代表的意义），less，head，tail 和 tail -f （甚至 less +F），ln 和 ln -s （了解硬链接与软链接的区别），chown，chmod，du （硬盘使用情况概述：du -hk *）。 关于文件系统的管理，学习 df，mount，fdisk，mkfs，lsblk。 学习基本的网络管理：ip 或 ifconfig，dig。 熟悉正则表达式，以及 grep／egrep 里不同参数的作用，例如 -i，-o，-v，-A，-B 和 -C。 学会使用 apt-get，yum，dnf 或 pacman （取决于你使用的 Linux 发行版）来查找或安装包。确保你的环境中有 pip 来安装基于 Python 的命令行工具 （部分程序使用 pip 来安装会很简单）。 日常使用 在 Bash 中，可以使用 Tab 自动补全参数，使用 ctrl-r 搜索命令行历史。 在 Bash 中，使用 ctrl-w 删除你键入的最后一个单词，使用 ctrl-u 删除整行，使用 alt-b 和 alt-f 按单词移动，使用 ctrl-k 从光标处删除到行尾，使用 ctrl-l 清屏。键入 man readline 查看 Bash 中的默认快捷键，内容很多。例如 alt-. 循环地移向前一个参数，以及 alt-* 展开通配符。 你喜欢的话，可以键入 set -o vi 来使用 vi 风格的快捷键。 键入 history 查看命令行历史记录。其中有许多缩写，例如 !$（最后键入的参数）和 !!（最后键入的命令），尽管通常被 ctrl-r 和 alt-. 取代。 回到上一个工作路径：cd - 如果你输入命令的时候改变了主意，按下 alt-# 在行首添加 #（将你输入的命令视为注释），并回车。这样做的话，之后你可以很方便的利用命令行历史回到你刚才输入到一半的命令。 使用 xargs （ 或 parallel）。他们非常给力。注意到你可以控制每行参数个数（-L）和最大并行数（-P）。如果你不确定它们是否会按你想的那样工作，先使用 xargs echo 查看一下。此外，使用 -I{} 会很方便。例如： 12find . -name '*.py' | xargs grep some_functioncat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname pstree -p 有助于展示进程树。 使用 pgrep 和 pkill 根据名字查找进程或发送信号。 了解你可以发往进程的信号的种类。比如，使用 kill -STOP [pid] 停止一个进程。使用 man 7 signal 查看详细列表。 使用 nohup 或 disown 使一个后台进程持续运行。 使用 netstat -lntp 或 ss -plat 检查哪些进程在监听端口（默认是检查 TCP 端口; 使用参数 -u 检查 UDP 端口）。 有关打开套接字和文件，请参阅 lsof。 使用 uptime 或 w 来查看系统已经运行多长时间。 使用alias来创建常用命令的快捷形式。例如：alias ll=&#39;ls -latr&#39;使你可以方便地执行ls -latr命令。 在 Bash 脚本中，使用 set -x 去调试输出，尽可能的使用严格模式，使用 set -e 令脚本在发生错误时退出而不是继续运行，使用 set -o pipefail 严谨地对待错误（尽管问题可能很微妙）。当牵扯到很多脚本时，使用 trap。 在 Bash 脚本中，子 shell（使用括号(...)）是一种便捷的方式去组织参数。一个常见的例子是临时地移动工作路径，代码如下： 123# do something in current dir(cd /some/other/dir &amp;&amp; other-command)# continue in original dir 在 Bash 中，注意到其中有许多形式的扩展。检查变量是否存在：${name:?error message}。例如，当 Bash 脚本需要一个参数时，可以使用这样的代码 input_file=${1:?usage: $0 input_file}。数学表达式：i=$(( (i + 1) % 5 ))。序列：{1..10}。 截断字符串：${var%suffix} 和 ${var#prefix}。例如，假设 var=foo.pdf，那么 echo ${var%.pdf}.txt 将输出 foo.txt。 通过使用 &lt;(some command) 可以将输出视为文件。例如，对比本地文件 /etc/hosts 和一个远程文件： 1diff /etc/hosts &lt;(ssh somehost cat /etc/hosts) 了解 Bash 中的“here documents”，例如 cat &lt;&lt;EOF ...。 在 Bash 中，同时重定向标准输出和标准错误，some-command &gt;logfile 2&gt;&amp;1。通常，为了保证命令不会在标准输入里残留一个打开了的文件句柄导致你当前所在的终端无法操作，添加 &lt;/dev/null 是一个好习惯。 使用 man ascii 查看具有十六进制和十进制值的ASCII表。man unicode，man utf-8，以及 man latin1 有助于你去了解通用的编码信息。 使用 screen 或 tmux 来使用多个屏幕，当你在使用 ssh 时（保存 session 信息）将尤为有用。另一个轻量级的解决方案是 dtach。 ssh 中，了解如何使用 -L 或 -D（偶尔需要用 -R）去开启隧道是非常有用的，例如当你需要从一台远程服务器上访问 web。 对 ssh 设置做一些小优化可能是很有用的，例如这个 ~/.ssh/config 文件包含了防止特定环境下断开连接、压缩数据、多通道等选项： 1234567TCPKeepAlive=yesServerAliveInterval=15ServerAliveCountMax=6Compression=yesControlMaster autoControlPath /tmp/%r@%h:%pControlPersist yes 部分其他的关于 ssh 的选项是安全敏感且应当小心启用的。例如在可信任的网络中：StrictHostKeyChecking=no，ForwardAgent=yes 获取文件的八进制格式权限，使用类似如下的代码： 1stat -c '%A %a %n' /etc/timezone 使用 percol 或者 fzf 可以交互式地从另一个命令输出中选取值。 使用 fpp（PathPicker）可以与基于另一个命令(例如 git）输出的文件交互。 将 web 服务器上当前目录下所有的文件（以及子目录）暴露给你所处网络的所有用户，使用：python -m SimpleHTTPServer 7777 （使用端口 7777 和 Python 2）或python -m http.server 7777 （使用端口 7777 和 Python 3）。 以某种权限执行命令，使用sudo（root 权限）或sudo -u（其他用户）。使用su或者sudo bash来启动一个以对应用户权限运行的 shell。使用su -模拟其他用户的登录。 文件及数据处理 在当前路径下通过文件名定位一个文件，find . -iname &#39;*something*&#39;（或类似的）。在所有路径下通过文件名查找文件，使用 locate something （但请记住 updatedb 可能没有对最近新建的文件建立索引）。 使用 ag 在源代码或数据文件里检索（比 grep -r 更好）。 将HTML转为文本：lynx -dump -stdin Markdown，HTML，以及所有文档格式之间的转换，试试 pandoc。 如果你不得不处理 XML，xmlstarlet 宝刀未老。 使用 jq 处理 JSON。 Excel 或 CSV 文件的处理，csvkit 提供了 in2csv，csvcut，csvjoin，csvgrep 等工具。 关于 Amazon S3，s3cmd 很方便而 s4cmd 更快。Amazon 官方的 aws 是其他 AWS 相关工作的基础。 了解如何使用 sort 和 uniq，包括 uniq 的 -u 参数和 -d 参数，详见后文一行代码节。另外可以了解一下 comm。 了解如何使用 cut，paste 和 join 来更改文件。很多人都会使用 cut，但几乎都不会使用 join。 了解如何运用 wc 去计算新行数（-l），字符数（-m），单词数（-w）以及字节数（-c）。 了解如何使用 tee 将标准输入复制到文件甚至标准输出，例如 ls -al | tee file.txt。 了解语言环境对许多命令行工具的微妙影响，包括排序的顺序和性能。大多数 Linux 的安装过程会将 LANG 或其他有关的变量设置为符合本地的设置。意识到当你改变语言环境时，排序的结果可能会改变。明白国际化可能会时 sort 或其他命令运行效率下降许多倍。某些情况下（例如集合运算）你可以放心的使用 export LC_ALL=C 来忽略掉国际化并使用基于字节的顺序。 了解 awk 和 sed 关于数据的简单处理的用法。例如，将文本文件中第三列的所有数字求和：awk &#39;{ x += $3 } END { print x }&#39;. 这可能比同等作用的 Python 代码块三倍且代码量少三倍。 替换一个或多个文件中出现的字符串： 1perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt 依据某种模式批量重命名多个文件，使用 rename。对于复杂的重命名规则，repren 或许有帮助。 1234# Recover backup files foo.bak -&gt; foo:rename 's/\.bak$//' *.bak# Full rename of filenames，directories，and contents foo -&gt; bar:repren --full --preserve-case --from foo --to bar . 使用 shuf 从一个文件中随机选取行。 了解 sort 的参数。处理数字方面，使用 -n 或者 -h 来处理可读性数字（例如 du -h 的输出）。明白键的工作原理（-t 和 -k）。例如，注意到你需要 -k1，1 来仅按第一个域来排序，而 -k1 意味着按整行排序。稳定排序（sort -s）在某些情况下很有用。例如，以第二个域为主关键字，第一个域为次关键字进行排序，你可以使用 sort -k1，1 | sort -s -k2，2。 如果你想在 Bash 命令行中写 tab 制表符，按下 ctrl-v [Tab] 或键入 $&#39;\t&#39; （后者可能更好，因为你可以复制粘贴它）。 标准的源代码对比及合并工具是 diff 和 patch。使用 diffstat 查看变更总览数据。注意到 diff -r 对整个文件夹有效。使用 diff -r tree1 tree2 | diffstat 查看变更总览数据。 对于二进制文件，使用 hd 使其以十六进制显示以及使用 bvi 来编辑二进制。 同样对于二进制文件，使用 strings（包括 grep 等等）允许你查找一些文本。 二进制文件对比（Delta 压缩），使用 xdelta3。 使用 iconv 更改文本编码。而更高级的用法，可以使用 uconv，它支持一些高级的 Unicode 功能。例如，这条命令将所有元音字母转为小写并移除了： 1uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; ' &lt; input.txt &gt; output.txt 拆分文件，查看 split（按大小拆分）和 csplit（按模式拆分）。 使用 zless，zmore，zcat 和 zgrep对压缩过的文件进行操作。 系统调试 curl 和 curl -I 可以便捷地被应用于 web 调试中，它们的好兄弟 wget 也可以，或者是更潮的 httpie。 使用 iostat、netstat、top （htop 更佳）和 dstat 去获取硬盘、cpu 和网络的状态。熟练掌握这些工具可以使你快速的对系统的当前状态有一个大概的认识。 若要对系统有一个深度的总体认识，使用 glances。它在一个终端窗口中向你提供一些系统级的数据。这对于快速的检查各个子系统非常有帮助。 若要了解内存状态，运行并理解 free 和 vmstat 的输出。尤其注意“cached”的值，它指的是 Linux 内核用来作为文件缓存的内存大小，因此它与空闲内存无关。 Java 系统调试则是一件截然不同的事，一个可以用于 Oracle 的 JVM 或其他 JVM 上的调试的小技巧是你可以运行 kill -3 &lt;pid&gt; 同时一个完整的栈轨迹和堆概述（包括 GC 的细节）会被保存到标准输出/日志文件。JDK 中的 jps，jstat，jstack，jmap 很有用。SJK tools 更高级. 使用 mtr 去跟踪路由，用于确定网络问题。 用 ncdu 来查看磁盘使用情况，它比常用的命令，如 du -sh *，更节省时间。 查找正在使用带宽的套接字连接或进程，使用 iftop 或 nethogs。 ab 工具（捆绑于 Apache）可以简单粗暴地检查 web 服务器的性能。对于更复杂的负载测试，使用 siege。 wireshark，tshark 和 ngrep 可用于复杂的网络调试。 了解 strace 和 ltrace。这俩工具在你的程序运行失败、挂起甚至崩溃，而你却不知道为什么或你想对性能有个总体的认识的时候是非常有用的。注意 profile 参数（-c）和附加到一个运行的进程参数 （-p）。 了解使用 ldd 来检查共享库。 了解如何运用 gdb 连接到一个运行着的进程并获取它的堆栈轨迹。 学会使用 /proc。它在调试正在出现的问题的时候有时会效果惊人。比如：/proc/cpuinfo，/proc/meminfo，/proc/cmdline，/proc/xxx/cwd，/proc/xxx/exe，/proc/xxx/fd/，/proc/xxx/smaps（这里的 xxx 表示进程的 id 或 pid）。 当调试一些之前出现的问题的时候，sar 非常有用。它展示了 cpu、内存以及网络等的历史数据。 关于更深层次的系统分析以及性能分析，看看 stap（SystemTap），perf)，以及sysdig。 查看你当前使用的系统，使用 uname 或者 uname -a （Unix／kernel 信息） or lsb_release -a （Linux 发行版信息）。 无论什么东西工作得很欢乐时试试 dmesg（可能是硬件或驱动问题）。 一行代码一些命令组合的例子： 当你需要对文本文件做集合交、并、差运算时，结合使用 sort/uniq 很有帮助。假设 a 与 b 是两内容不同的文件。这种方式效率很高，并且在小文件和上G的文件上都能运用 （sort 不被内存大小约束，尽管在 /tmp 在一个小的根分区上时你可能需要 -T 参数），参阅前文中关于 LC_ALL 和 sort 的 -u 参数的部分。 123cat a b | sort | uniq &gt; c # c is a union bcat a b | sort | uniq -d &gt; c # c is a intersect bcat a b b | sort | uniq -u &gt; c # c is set difference a - b 使用 grep . * 来阅读检查目录下所有文件的内容，例如检查一个充满配置文件的目录比如 /sys、/proc、/etc。 计算文本文件第三列中所有数的和（可能比同等作用的 Python 代码快三倍且代码量少三倍）： 1awk '&#123; x += $3 &#125; END &#123; print x &#125;' myfile 如果你想在文件树上查看大小\日期，这可能看起来像递归版的 ls -l 但比 ls -lR 更易于理解： 1find . -type f -ls 假设你有一个类似于 web 服务器日志文件的文本文件，并且一个确定的值只会出现在某些行上，假设一个 acct_id 参数在URI中。如果你想计算出每个 acct_id 值有多少次请求，使用如下代码： 1cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn 运行这个函数从这篇文档中随机获取一条小技巧（解析 Markdown 文件并抽取项目）： 1234567function taocl() &#123; curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md | pandoc -f markdown -t html | xmlstarlet fo --html --dropdtd | xmlstarlet sel -t -v "(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]" | xmlstarlet unesc | fmt -80&#125; 冷门但有用 expr：计算表达式或正则匹配 m4：简单地宏处理器 yes：多次打印字符串 cal：漂亮的日历 env：执行一个命令（脚本文件中很有用） printenv：打印环境变量（调试时或在使用脚本文件时很有用） look：查找以特定字符串开头的单词 cut、paste 和 join：数据修改 fmt：格式化文本段落 pr：将文本格式化成页/列形式 fold：包裹文本中的几行 column：将文本格式化成多列或表格 expand 和 unexpand：制表符与空格之间转换 nl：添加行号 seq：打印数字 bc：计算器 factor：分解因数 gpg：加密并签名文件 toe：terminfo entries 列表 nc：网络调试及数据传输 socat：套接字代理，与 netcat 类似 slurm：网络可视化 dd：文件或设备间传输数据 file：确定文件类型 tree：以树的形式显示路径和文件，类似于递归的 ls stat：文件信息 time：执行命令，并计算执行时间 tac：反向输出文件 shuf：文件中随机选取几行 comm：一行一行的比较排序过的文件 pv：监视通过管道的数据 hd 和 bvi：保存或编辑二进制文件 strings：从二进制文件中抽取文本 tr：转换字母 iconv 或 uconv：简易的文件编码 split 和 csplit：分割文件 units：将一种计量单位转换为另一种等效的计量单位（参阅 /usr/share/units/definitions.units） 7z：高比例的文件压缩 ldd：动态库信息 nm：提取 obj 文件中的符号 ab：性能分析 web 服务器 strace：系统调用调试 mtr：更好的网络调试跟踪工具 cssh：可视化的并发 shell rsync：通过 ssh 或本地文件系统同步文件和文件夹 wireshark 和 tshark：抓包和网络调试工具 ngrep：网络层的 grep host 和 dig：DNS 查找 lsof：列出当前系统打开文件的工具以及查看端口信息 dstat：系统状态查看 glances：高层次的多子系统总览 iostat：硬盘使用状态 mpstat: CPU 使用状态 vmstat: 内存使用状态 htop：top 的加强版 last：登入记录 w：查看处于登录状态的用户 id：用户/组 ID 信息 sar：系统历史数据 iftop 或 nethogs：套接字及进程的网络利用 ss：套接字数据 dmesg：引导及系统错误信息 sysctl: 在内核运行时动态地查看和修改内核的运行参数 hdparm：SATA/ATA 磁盘更改及性能分析 lsb_release：Linux 发行版信息 lsblk：列出块设备信息：以树形展示你的磁盘以及磁盘分区信息 lshw，lscpu，lspci，lsusb 和 dmidecode：查看硬件信息，包括 CPU、BIOS、RAID、显卡、USB设备等 lsmod 和 modifno：列出内核模块，并显示其细节 fortune，ddate 和 sl：额，这主要取决于你是否认为蒸汽火车和莫名其妙的名人名言是否“有用” 仅限 MacOS X 系统以下是仅限于 MacOS 系统的技巧 用 brew （Homebrew）或者 port （MacPorts）进行包管理。这些可以用来在 Mac 系统上安装以上的大多数命令。 用 pbcopy 复制任何命令的输出到桌面应用，用 pbpaste 粘贴输入。 用 open 或者 open -a /Applications/Whatever.app 使用桌面应用打开文件。 Spotlight： 用 mdfind 搜索文件，用 mdls 列出元数据（例如照片的 EXIF 信息）。 注意 MacOS 系统是基于 BSD UNIX 的，许多命令（例如 ps，ls，tail，awk，sed）都和 Linux 中有些微的不同，这些极大的被 System V-style Unix 和 GNU 工具影响。你可以通过标题为 “BSD General Commands Manual” 的 man 页面发现这些不同。在有些情况下 GNU 版本的命令也可能被安装（例如 gawk 和 gsed 对应 GNU 中的 awk 和 sed ）。如果要写跨平台的 Bash 脚本，避免使用这些命令（例如，考虑 Python 或者 perl ）或者经过仔细的测试。 更多资源 awesome-shell：一份精心组织的命令行工具及资源的列表。 Strict mode：为了编写更好的脚本文件。 免责声明除去特别微小的任务，记录下这些代码以便他人查看。责任往往伴随着能力，可以做并不意味着应该做。 授权条款本文使用授权协议 Creative Commons Attribution-ShareAlike 4.0 International License。]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python提升效率(视频)]]></title>
    <url>%2FPython%E5%AD%A6%E4%B9%A0%2F2015%2F09%2F09%2FPython%E5%AD%A6%E4%B9%A0-2015-09-09-python%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87-%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python装饰器学习(转载)]]></title>
    <url>%2FPython%E5%AD%A6%E4%B9%A0%2F2015%2F09%2F09%2FPython%E5%AD%A6%E4%B9%A0-2015-09-09-python%E8%A3%85%E9%A5%B0%E5%99%A8%E5%AD%A6%E4%B9%A0-%E8%BD%AC%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[这是转载原文在这里 引言本文主要梳理了Python decorator的实现思路，解释了为什么Python decorator是现在这个样子。 关于代理模式、装饰模式设计模式中经常听到的代理模式、装饰器模式，这两种叫法实际上是说的同一件事，只是侧重点不同而已。 例如：(以Java为例) 1234567891011121314151617181920public class CountProxy implements Count &#123; private CountImpl countImpl; public CountProxy(CountImpl countImpl)&#123; countImpl = countImpl; &#125; @Override public void queryCount()&#123; System.out.println("事务处理之前"); // 调用委托类的方法 countImpl.queryCount(); System.out.println("事务处理之后"); &#125; @Override public void updateCount() &#123; System.out.println("事务处理之前"); // 调用委托类的方法 countImpl.update(); System.out.println("事务处理之后"); &#125; &#125; 在这个例子中CountProxy是对CountImpl的封装。 使用者通过CountProxy.queryCount()方法调用CountImpl.queryCount()方法被称为代理，即CountProxy是代理类，CountImpl是被代理类。 在Countproxy.queryCount()中，可以在CountImpl.queryCount()被调用之前和之后执行一些额外的操作，被称为装饰，即CountProxy被称为装饰类，CountImpl被称为被装饰类。 so: 如果强调CountProxy类对CountImpl进行代理的作用，则称为代理模式。 如果强调CountProxy类对CountImpl进行装饰的作用，则称为装饰模式。 不论是哪种称呼其本质都是对原有对象的封装，其封装的目的就是增强所管理的对象或者是管理所增强的对象。 从上面的例子可以发现，封装围绕的核心是可调用对象。 Python中的代理/装饰 Python中的可调用对象包括函数和实现call方法的类。 Python中的函数也是对象，可以作为高阶函数的参数传入或者返回值返回。 因此当被封装的对象是一个函数时，可以使用高阶函数对这个函数进行封装。 例如： 12345678910def query_count_proxy(param_fun, name, age) print "事务开始之前" res = param_fun(name, age) print "事务开始之后" return res def query_count(name, age) print "something you want" query_count_proxy(query_count, name, age) 但是，这个例子中，query_count函数作为参数传入query_count_proxy函数中，并在query_count_proxy函数中被调用，并作返回值作为其返回值返回，完成了其代理的功能，同时在调用之前和之后加上了一些装饰的代码，完成了装饰的功能，但是query_count_proxy的函数参数和query_count的函数参数不一样了，理想情况应该保持接口一直才对。 为了保持一致，我们可以利用高阶函数可以返回函数的特点来完成： 123456789101112def query_count_proxy(param_fun) def inner_function(name,age) print "事务执行之前" res = param_fun(name, age) print "事务执行之后" return resreturn inner_functiondef query_count(name, age) print "somethiing you want"query_count_proxy(query_count)('daodaoliang',26) 修改后的例子，query_count_proxy仅负责接收一个被代理的函数query_count作为参数，同时，返回一个函数对象inner_function,真正的封装动作都是在这个闭包函数中。 此时若是调用query_count_proxy(query_count) 就会返回一个函数对象，则给其传递参数就像与执行了inner_function(name,age) 但是目前为止我们的使用方式query_count_proxy(query_count)(‘daodaoliang’,26)并没有做到接口一直，为此我们需要用到python的动态绑定的特性修改为如下 12query_count = query_count_proxy(query_count)query_count('daodaoliang', 26) 执行query_count_proxy(query_count) 返回一个函数对象，并通过动态绑定将其绑定到query_count上面，在此之后执行query_count(‘daodaoliang’, 26) 等同于执行innery_function(‘daodaoliang’, 26) 这么做的结果是代理之后使用方式和未代理时的使用方式一样，都是使用query_count(‘daodaoliang’, 26) 不同的是使用代理后执行的是代理之后的代码。 但是这样子的是不简洁的，这种反复而又琐碎的工作，python给我提供了一个语法糖，就是在其前面加上@query_count. 123@query_count_proxy def query_count(name, age) print "do something you want" python 看到这样的语法就会自动执行 query_count = query_count_proxy(query_count)进行名字绑定]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入浅出RPC——深入篇(转载)]]></title>
    <url>%2F%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%2F2015%2F08%2F27%2F%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-2015-08-27-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARPC-%E6%B7%B1%E5%85%A5%E7%AF%87%2F</url>
    <content type="text"><![CDATA[本文转载自这里是原文 《深入篇》我们主要围绕 RPC 的功能目标和实现考量去展开，一个基本的 RPC 框架应该提供什么功能，满足什么要求以及如何去实现它？ RPC 功能目标RPC的主要功能呢个目标是让构建分布式计算更加容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。为实现该目标，RPC框架提供一种透明的调用机制让使用者不必显式的区分本地调用和远程调用，在前文《浅出篇》给出了一种时间结构，基于stub的是结构来实现，下面我们将细化stub结构的实现。 RPC调用分类RPC调用分以下两种： 同步调用 客户方等待调用执行完成并返回结果 异步调用 客户调用后不用等待执行结果返回，但依然可以通过回调通知等方式获取返回结果，若客户方不关系调用返回结果，则变成单向异步调用，单向调用不用返回结果。 RPC结构拆解《浅出篇》给出了一个比较粗粒度的RPC实现概念结构，这里我们进一步细化它该由哪些组件构成，如下图所示： RPC服务方通过RpcServer导出远程接口方法，而客户方通过RpcClient去引入远程接口方法。客户方向调用本地方法一样去调用远程方法，RPC框架提供接口的代理实现，实际的调用委托给RpcProxy。代理封装调用信用信息将调用转交给RpcInvoker去实际执行，在客户端的RpcInvoker通过连接器RpcConnector去维持服务器端的通道RpcChannel，并使用RpcProtocol执行协议编码(encode)并将编码后的消息通过通道发给服务方。 RPC服务方的RpcAcceptor去接受客户方的调用请求，同样使用RPCProtocol执行协议解码(decode)。解码后的信息传递给RPCProcessor去控制处理调用过程，最后在委托调用给RPCInvoker去实际执行并返回调用结果。 RPC组件职责上面我们进一步拆解了RPC实现结构的哥哥组件部分，下面我们详细说明每个部分的职责： RPCServer 负责导出接口 RpcClient 负责导入接口 RpcProxy 远程接口代理实现 RpcInvoker 客户方实现：负责编码调用信息，并发送调用信息并等待调用返回。服务方实现：负责调用服务端接口的具体实现并返回调用结果。 RpcProtocol 负责协议编解码 RpcConnector 负责维持客户方和服务方的谅解通道和发送数据到服务方 RpcAcceptor 负责接收客户方的请求并返回处理结果 RpcProcessor 负责在服务方管理调用过程，包括线程池和调用的超时时间等。 RpcChannel 数据传输通道 RPC实现分析在进一步拆解了组件并划分了职责以后，这里以在Java平台实现该RPC框架概念模型为例，详细分析下实现中需要考虑的因素： 导出远程接口导出远程接口的意思指的只有导出的接口可以供远程调用，而未导出的接口则不能用，在java中导出接口的代码片段可能如下： 123DemoServer demo = new ...; RpcSerber server = new ...; server.export(Demoserver.class, demo, options) 我们可以导出整个接口也可以更细粒度一点只导出接口中的某些方法，如： 12//只导出Demoserver中签名为hi(string s) 的方法 server.export(DemoServer.class, demo, "hi", new Class&lt;?&gt;[] &#123;String.class&#125;,options) java 中还有一种比较特殊的调用就是多态，也就是一个接口可能有多个实现，那么远程调用时到底调用哪个？ 这个本地调用的语义是通过 jvm 提供的引用多态性隐式实现的，那么对于 RPC 来说跨进程的调用就没法隐式实现了。 如果前面 DemoService 接口有 2 个实现，那么在导出接口时就需要特殊标记不同的实现，如： 12345DemoService demo = new ...;DemoService demo2 = new ...;RpcServer server = new ...;server.export(DemoService.class, demo, options);server.export("demo2", DemoService.class, demo2, options); 上面 demo2 是另一个实现，我们标记为 demo2 来导出， 那么远程调用时也需要传递该标记才能调用到正确的实现类，这样就解决了多态调用的语义。 导入远程接口与客户端代理导入相对于导出远程接口，客户端代码为了能够发起调用必须要获得远程接口的方法或过程定义。 目前，大部分跨语言平台 RPC 框架采用根据 IDL 定义通过 code generator 去生成 stub 代码， 这种方式下实际导入的过程就是通过代码生成器在编译期完成的。 我所使用过的一些跨语言平台 RPC 框架如 CORBAR、WebService、ICE、Thrift 均是此类方式。 代码生成的方式对跨语言平台 RPC 框架而言是必然的选择，而对于同一语言平台的 RPC 则可以通过共享接口定义来实现。 在 java 中导入接口的代码片段可能如下： 123RpcClient client = new ...; DemoServer demo = client.refer(DemoServer.class); demo.hi("how are you"); 在 java 中 import 是关键字，所以代码片段中我们用 refer 来表达导入接口的意思。 这里的导入方式本质也是一种代码生成技术，只不过是在运行时生成，比静态编译期的代码生成看起来更简洁些。 java 里至少提供了两种技术来提供动态代码生成，一种是 jdk 动态代理，另外一种是字节码生成。 动态代理相比字节码生成使用起来更方便，但动态代理方式在性能上是要逊色于直接的字节码生成的，而字节码生成在代码可读性上要差很多。 两者权衡起来，个人认为牺牲一些性能来获得代码可读性和可维护性显得更重要。 协议编解码客户端代理在发起调用前需要对调用信息进行编码，这就要考虑需要编码些什么信息并以什么格式传输到服务端才能让服务端完成调用。 出于效率考虑，编码的信息越少越好（传输数据少），编码的规则越简单越好（执行效率高）。 我们先看下需要编码些什么信息： 调用编码 接口方法 包括接口名、方法名 方法参数 包括参数类型、参数值 调用属性 包括调用属性信息，例如调用附件隐式参数、调用超时时间等 返回编码 返回结果 接口方法中定义的返回值 返回码 异常返回码 返回异常信息 调用异常信息 除了以上这些必须的调用信息，我们可能还需要一些元信息以方便程序编解码以及未来可能的扩展。 这样我们的编码消息里面就分成了两部分，一部分是元信息、另一部分是调用的必要信息。 如果设计一种 RPC 协议消息的话，元信息我们把它放在协议消息头中，而必要信息放在协议消息体中。 下面给出一种概念上的 RPC 协议消息设计格式： 消息头 magic：协议魔数，为解码设计 header size: 协议头长度，为扩展设计 version: 协议版本，为扩展时使用 st: 消息体序列化类型 hb: 心跳信息标记，为长连接传输层心跳设计 ow: 单向消息标记 rp: 相应消息标记。不置位默认是请求消息 status code： 响应消息状态码 reserved: 为字节对齐保留 message id：消息id body size:消息体长度 消息体 采用序列化编码，常见有以下格式： XML:如webservice(SOAP) json: 如json-RPC binary: 如thrift,hession,kryo等 格式确定后编解码就简单了，由于头长度一定所以我们比较关心的就是消息体的序列化方式。 序列化我们关心三个方面： 序列化和反序列化的效率，越快越好。 序列化后的字节长度，越小越好。 序列化和反序列化的兼容性，接口参数对象若增加了字段，是否兼容。 上面这三点有时是鱼与熊掌不可兼得，这里面涉及到具体的序列化库实现细节，就不在本文进一步展开分析了。 传输服务协议编码之后，自然就是需要将编码后的 RPC 请求消息传输到服务方，服务方执行后返回结果消息或确认消息给客户方。 RPC 的应用场景实质是一种可靠的请求应答消息流，和 HTTP 类似。 因此选择长连接方式的 TCP 协议会更高效，与 HTTP 不同的是在协议层面我们定义了每个消息的唯一 id，因此可以更容易的复用连接。 既然使用长连接，那么第一个问题是到底 client 和 server 之间需要多少根连接？ 实际上单连接和多连接在使用上没有区别，对于数据传输量较小的应用类型，单连接基本足够。 单连接和多连接最大的区别在于，每根连接都有自己私有的发送和接收缓冲区， 因此大数据量传输时分散在不同的连接缓冲区会得到更好的吞吐效率。 所以，如果你的数据传输量不足以让单连接的缓冲区一直处于饱和状态的话，那么使用多连接并不会产生任何明显的提升， 反而会增加连接管理的开销。 连接是由 client 端发起建立并维持。 如果 client 和 server 之间是直连的，那么连接一般不会中断（当然物理链路故障除外）。 如果 client 和 server 连接经过一些负载中转设备，有可能连接一段时间不活跃时会被这些中间设备中断。 为了保持连接有必要定时为每个连接发送心跳数据以维持连接不中断。 心跳消息是 RPC 框架库使用的内部消息，在前文协议头结构中也有一个专门的心跳位， 就是用来标记心跳消息的，它对业务应用透明。 执行调用client stub 所做的事情仅仅是编码消息并传输给服务方，而真正调用过程发生在服务方。 server stub 从前文的结构拆解中我们细分了 RpcProcessor 和 RpcInvoker 两个组件， 一个负责控制调用过程，一个负责真正调用。 这里我们还是以 java 中实现这两个组件为例来分析下它们到底需要做什么？ java 中实现代码的动态接口调用目前一般通过反射调用。 除了原生的 jdk 自带的反射，一些第三方库也提供了性能更优的反射调用， 因此 RpcInvoker 就是封装了反射调用的实现细节。 调用过程的控制需要考虑哪些因素，RpcProcessor 需要提供什么样地调用控制服务呢？ 下面提出几点以启发思考： 效率提升 每个请求应该尽快被执行，因此我们不能每请求来再创建线程去执行，需要提供线程池服务. 资源隔离 当我们导出多个远程接口时，如何避免单一接口调用占据所有线程资源，而引发其他接口执行阻塞。 超时控制 当某个接口执行缓慢，而 client 端已经超时放弃等待后，server 端的线程继续执行此时显得毫无意义。 RPC 异常处理无论 RPC 怎样努力把远程调用伪装的像本地调用，但它们依然有很大的不同点，而且有一些异常情况是在本地调用时绝对不会碰到的。 在说异常处理之前，我们先比较下本地调用和 RPC 调用的一些差异： 本地调用一定会执行，而远程调用则不一定，调用消息可能因为网络原因并未发送到服务方。 本地调用只会抛出接口声明的异常，而远程调用还会跑出 RPC 框架运行时的其他异常。 本地调用和远程调用的性能可能差距很大，这取决于 RPC 固有消耗所占的比重。 正是这些区别决定了使用 RPC 时需要更多考量。 当调用远程接口抛出异常时，异常可能是一个业务异常， 也可能是 RPC 框架抛出的运行时异常（如：网络中断等）。 业务异常表明服务方已经执行了调用，可能因为某些原因导致未能正常执行， 而 RPC 运行时异常则有可能服务方根本没有执行，对调用方而言的异常处理策略自然需要区分。 由于 RPC 固有的消耗相对本地调用高出几个数量级，本地调用的固有消耗是纳秒级，而 RPC 的固有消耗是在毫秒级。 那么对于过于轻量的计算任务就并不合适导出远程接口由独立的进程提供服务， 只有花在计算任务上时间远远高于 RPC 的固有消耗才值得导出为远程接口提供服务。 总结至此我们提出了一个 RPC 实现的概念框架，并详细分析了需要考虑的一些实现细节。 无论 RPC 的概念是如何优雅，但是“草丛中依然有几条蛇隐藏着”，只有深刻理解了 RPC 的本质，才能更好地应用。]]></content>
      <categories>
        <category>进程间通信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入浅出RPC——浅出篇(转载)]]></title>
    <url>%2F%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%2F2015%2F08%2F27%2F%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-2015-08-27-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARPC-%E6%B5%85%E5%87%BA%E7%AF%87%2F</url>
    <content type="text"><![CDATA[本文转载自这里是原文 近几年的项目中，服务化和微服务化渐渐成为中大型分布式系统架构的主流方式，而 RPC 在其中扮演着关键的作用。 在平时的日常开发中我们都在隐式或显式的使用 RPC，一些刚入行的程序员会感觉 RPC 比较神秘，而一些有多年使用 RPC 经验的程序员虽然使用经验丰富，但有些对其原理也不甚了了。 缺乏对原理层面的理解，往往也会造成开发中的一些误用。 本文分上下两篇《浅出篇》和《深入篇》，其目标就是想尝试深入浅出的分析下 RPC 本质，我总是这么认为理解了本质才能更好的应用。 RPC是什么RPC全称是Remote Procedure Call是一种进程间通信方式。它允许程序调用另外一个地址空间（通常是共享网络的另一台机器）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论调用本地的还是远程的，本质上编写的调用代码基本相同。 RPC起源RPC 这个概念术语在上世纪 80 年代由 Bruce Jay Nelson 提出。 这里我们追溯下当初开发 RPC 的原动机是什么？ 在 Nelson 的论文 Implementing Remote Procedure Calls 中他提到了几点： 简单：RPC 概念的语义十分清晰和简单，这样建立分布式计算就更容易。高效：过程调用看起来十分简单而且高效。通用：在单机计算中过程往往是不同算法部分间最重要的通信机制 通俗一点说，就是一般程序员对于本地的过程调用很熟悉，那么我们把 RPC 作成和本地调用完全类似，那么就更容易被接受，使用起来毫无障碍。 Nelson 的论文发表于 30 年前，其观点今天看来确实高瞻远瞩，今天我们使用的 RPC 框架基本就是按这个目标来实现的。 RPC 结构 UserUser-stubRPCRuntimeServer-stubServe 这里 user 就是 client 端，当 user 想发起一个远程调用时，它实际是通过本地调用 user-stub。 user-stub 负责将调用的接口、方法和参数通过约定的协议规范进行编码并通过本地的 RPCRuntime 实例传输到远端的实例。 远端 RPCRuntime 实例收到请求后交给 server-stub 进行解码后发起本地端调用，调用结果再返回给 user 端。 RPC 实现Nelson 论文中给出的这个实现结构也成为后来大家参考的标准范本。 大约 10 年前，我最早接触分布式计算时使用的 CORBAR 实现结构基本与此类似。 CORBAR 为了解决异构平台的 RPC，使用了 IDL（Interface Definition Language）来定义远程接口，并将其映射到特定的平台语言中。 后来大部分的跨语言平台 RPC 基本都采用了此类方式，比如我们熟悉的 Web Service（SOAP），近年开源的 Thrift 等。 他们大部分都通过 IDL 定义，并提供工具来映射生成不同语言平台的 user-stub 和 server-stub，并通过框架库来提供 RPCRuntime 的支持。 不过貌似每个不同的 RPC 框架都定义了各自不同的 IDL 格式，导致程序员的学习成本进一步上升（苦逼啊），Web Service 尝试建立业界标准，无赖标准规范复杂而效率偏低，否则 Thrift 等更高效的 RPC 框架就没必要出现了。 IDL 是为了跨平台语言实现 RPC 不得已的选择，要解决更广泛的问题自然导致了更复杂的方案。 而对于同一平台内的 RPC 而言显然没必要搞个中间语言出来，例如 java 原生的 RMI，这样对于 java 程序员而言显得更直接简单，降低使用的学习成本。 目前市面上提供的 RPC 框架已经可算是五花八门，百家争鸣了。 需要根据实际使用场景谨慎选型，需要考虑的选型因素我觉得至少包括下面几点： 性能指标 是否需要跨语言平台 内网开放还是公网开放 开源 RPC 框架本身的质量、社区活跃度 总结《浅出篇》大概就到这里结束了，《深入篇》会具体深入讲解一个 RPC 框架需要实现哪里基本功能，达到什么目标，并以在 java 平台上去具体实现一个 RPC 框架为例，分析其需要考虑的实现因素。]]></content>
      <categories>
        <category>进程间通信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pernoca toolkit 学习]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%2F2015%2F08%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0-mysql%E4%B8%93%E9%A2%98-2015-08-26-Pernoca-ToolKit%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[工具安装 官网链接 手册链接 整包下载链接:123wget percona.com/get/percona-toolkit.tar.gzwget percona.com/get/percona-toolkit.rpmwget percona.com/get/percona-toolkit.deb 单个工具下载链接:1wget percona.com/get/TOOL TOOL 要改为下面的的工具的名字]]></content>
      <categories>
        <category>数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python邮件发送]]></title>
    <url>%2FPython%E5%AD%A6%E4%B9%A0%2F2015%2F08%2F05%2FPython%E5%AD%A6%E4%B9%A0-2015-08-05-python%E9%82%AE%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[python邮件发送1. 纯文本邮件1234567891011121314151617181920#coding: utf-8import smtplibfrom email.mime.text import MIMETextfrom email.header import Headersender = '××××××××××××××'receiver = '××××××××××××××'subject = 'python email test'smtpserver = 'smtp.yeah.net'username = '××××××××××××××'password = '××××××××××××××'msg = MIMEText('你好','plain','utf-8')#中文需参数‘utf-8’，单字节字符不需要msg['Subject'] = Header(subject, 'utf-8')smtp = smtplib.SMTP()smtp.connect(smtpserver)smtp.login(username, password)smtp.sendmail(sender, receiver, msg.as_string())smtp.quit() 2. HTML文本邮件123456789101112131415161718192021#!/usr/bin/env python3#coding: utf-8import smtplibfrom email.mime.text import MIMETextsender = '××××××××××××××'receiver = '××××××××××××××'subject = 'python email test'smtpserver = 'smtp.yeah.net'username = '××××××××××××××'password = '××××××××××××××'msg = MIMEText('&lt;html&gt;&lt;h1&gt;你好&lt;/h1&gt;&lt;/html&gt;','html','utf-8')msg['Subject'] = subjectsmtp = smtplib.SMTP(smtpserver)smtp.connect()smtp.login(username, password)smtp.sendmail(sender, receiver, msg.as_string())smtp.quit() 3. 带图片的HTML邮件1234567891011121314151617181920212223242526272829303132333435# coding: UTF-8import smtplibfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartfrom email.mime.image import MIMEImagesender = 'daodaoliang@yeah.net'receiver = '88341189@qq.com'subject = 'python email test'smtpserver = 'smtp.yeah.net'username = 'daodaoliang@yeah.net'password = '××××××××××××××'msgRoot = MIMEMultipart('related')msgRoot['Subject'] = 'test message'msgRoot['From'] = sendermsgRoot['To'] = receivermsgText = MIMEText('&lt;b&gt;Some &lt;i&gt;HTML&lt;/i&gt; text&lt;/b&gt; and an image.&lt;br&gt;&lt;img src="cid:image1"&gt;&lt;br&gt;good!', 'html', 'utf-8')msgRoot.attach(msgText)fp = open('d:\\1.png', 'rb')msgImage = MIMEImage(fp.read())fp.close()msgImage.add_header('Content-ID', '&lt;image1&gt;')msgRoot.attach(msgImage)smtp = smtplib.SMTP()smtp.connect(smtpserver)smtp.docmd('ehlo', 'daodaoliang@yeah.net')smtp.login(username, password)smtp.sendmail(sender, receiver, msgRoot.as_string())smtp.quit() 4. 带附件的邮件123456789101112131415161718192021222324252627282930# coding: UTF-8import smtplibfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartsender = 'daodaoliang@yeah.net'receiver = '88341189@qq.com'subject = 'python email test'smtpserver = 'smtp.yeah.net'username = 'daodaoliang@yeah.net'password = '××××××××××××××'msgRoot = MIMEMultipart('related')msgRoot['Subject'] = 'test message'msgRoot['From'] = sendermsgRoot['To'] = receiver# 构造附件att = MIMEText(open('d:\\1.png', 'rb').read(), 'base64', 'utf-8')att["Content-Type"] = 'application/octet-stream'att["Content-Disposition"] = 'attachment; filename="1.png"'msgRoot.attach(att)smtp = smtplib.SMTP()smtp.connect(smtpserver)smtp.docmd('ehlo', 'daodaoliang@yeah.net')smtp.login(username, password)smtp.sendmail(sender, receiver, msgRoot.as_string())smtp.quit() 5. 邮件群发12345678910111213141516171819202122232425262728293031323334353637# coding: UTF-8__author__ = 'daodaoliang'import smtplibfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartfrom email.mime.image import MIMEImagesender = 'daodaoliang@yeah.net'receiver = ['88341189@qq.com', '553888032@qq.com', '836343656@qq.com', '843834154@qq.com']subject = 'python email test'smtpserver = 'smtp.yeah.net'username = 'daodaoliang@yeah.net'password = '×××××××××××××××××'msgRoot = MIMEMultipart('related')msgRoot['Subject'] = '邮件群发测试'msgRoot['From'] = sendermsgRoot['To'] = ','.join(receiver)msgText = MIMEText('&lt;b&gt;Some &lt;i&gt;HTML&lt;/i&gt; text&lt;/b&gt; and an image.&lt;br&gt;&lt;img src="cid:image1"&gt;&lt;br&gt;good!', 'html', 'utf-8')msgRoot.attach(msgText)fp = open('d:\\1.png', 'rb')msgImage = MIMEImage(fp.read())fp.close()msgImage.add_header('Content-ID', '&lt;image1&gt;')msgRoot.attach(msgImage)smtp = smtplib.SMTP()smtp.connect(smtpserver)smtp.docmd('ehlo', 'daodaoliang@yeah.net')smtp.login(username, password)smtp.sendmail(sender, receiver, msgRoot.as_string())smtp.quit()]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CentOS6.5配置nginx+phpfpm]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2015%2F08%2F03%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2015-05-12-CentOS6-5%E9%85%8D%E7%BD%AEnginx-phpfpm%2F</url>
    <content type="text"><![CDATA[&gt;nginx本身不能处理PHP，它只是个web服务器，当接收到请求后，如果是php请求，则发给php解释器处理，并把结果返回给客户端 [TOC] nginx一般是把请求发fastcgi管理进程处理，fascgi管理进程选择cgi子进程处理结果并返回被nginx 1. 编译安装php-fpm1.1 什么是PHP-FPM PHP-FPM是一个PHP FastCGI管理器，是只用于PHP的,下载地址：我是下载地址 PHP-FPM其实是PHP源代码的一个补丁，旨在将FastCGI进程管理整合进PHP包中。必须将它patch到你的PHP源代码中，在编译安装PHP后才可以使用。 新版PHP已经集成php-fpm了，不再是第三方的包了，推荐使用。PHP-FPM提供了更好的PHP进程管理方式，可以有效控制内存和进程、可以平滑重载PHP配置，比spawn-fcgi具有更多优点，所以被PHP官方收录了。在./configure的时候带 –enable-fpm参数即可开启PHP-FPM。 PS: PHP详细的安装配置选项地址:我是地址 1.2 安装先环境准备在centos下执行 123456789yum -y install gcc automake autoconf libtool makeyum -y install gcc gcc-c++ glibcyum -y install libmcrypt-devel mhash-devel libxslt-devel \libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel \zlib zlib-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel \ncurses ncurses-devel curl curl-devel e2fsprogs e2fsprogs-devel \krb5 krb5-devel libidn libidn-devel openssl openssl-devel 1.3 PHP-FPM安装1234567891011121314wget http://cn2.php.net/distributions/php-5.4.7.tar.gztar zvxf php-5.4.7.tar.gzcd php-5.4.7./configure --prefix=/usr/local/php --enable-fpm --with-mcrypt \--enable-mbstring --disable-pdo --with-curl --disable-debug --disable-rpath \--enable-inline-optimization --with-bz2 --with-zlib --enable-sockets \--enable-sysvsem --enable-sysvshm --enable-pcntl --enable-mbregex \--with-mhash --enable-zip --with-pcre-regex --with-mysql --with-mysqli \--with-gd --with-jpeg-dirmake all install 1.4 修改PHP-FPM配置文件123updatedblocated php-fpm 进入对应的目录后进行配置文件的修改 2. 安装配置nginx2.1 安装nginx安装过程请参考我的这篇博客：博客地址 2.2 配置nginx在nginx.conf中修改server段的配置文件，增加如下内容 1234567location ~ \.php$ &#123;root html;fastcgi_pass 127.0.0.1:9000;fastcgi_index index.php;fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;include fastcgi_params;&#125; PS： 其中server段增加的配置中,注意第二行和倒数第二行,否则会出现No input file specified.错误 3.测试在根目录下创建index.php文件,启动php-fpm和nginx后在浏览器输入对应的监听地址即可 4.常见错误4.1 php configure时出错error: XML configuration could not be found```12 apt-get install libxml2 libxml2-dev (ubuntu下)yum -y install libxml2 libxml2-devel（centos下)12#### 4.2 Please reinstall the BZip2 distribution wget http://www.bzip.org/1.0.5/bzip2-1.0.5.tar.gztar -zxvf bzip2-1.0.5.tar.gzcd bzip2-1.0.5makemake install123456789101112#### 4.3 php的配置文件中有一行--with-mysql=/usr安装的时候提示：configure: error: Cannot find MySQL header files under yes.Note that the MySQL client library is not bundled anymore.这是由于安装mysql时没有安装mysql头文件，或者是路径指定不正确,php找不到mysql的头文件引起的错误提示。* 查看你的系统有没有安装mysql header```find / -name mysql.h 如果有。请指定–with-mysql=/跟你的正常路径。 redhat系列安装 -ivh MySQL-devel-4.1.12-1.i386.rpm```123* ubuntu安装```apt-get install libmysqlclient15-dev 最后一步php的配置选项添加–with-mysql=/usr 4.4 No input file specified.1234567location ~ \.php$ &#123;root html;fastcgi_pass 127.0.0.1:9000;fastcgi_index index.php;fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;include fastcgi_params;&#125; 4.5 mcrypt.h not found. Please reinstall libmcrypt1yum install libmcrypt-devel 或者 1234567cd /usr/local/srcwget http://softlayer.dl.sourceforge.net/sourceforge/mcrypt/libmcrypt-2.5.8.tar.gztar -zxvf libmcrypt-2.5.8.tar.gzcd /usr/local/src/libmcrypt-2.5.8./configure --prefix=/usr/localmakemake install]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Qt在Windows上的调试器安装与配置]]></title>
    <url>%2FQt%E5%AD%A6%E4%B9%A0%2F2015%2F07%2F30%2FQt%E5%AD%A6%E4%B9%A0-2015-07-30-Qt%E5%9C%A8Windows%E4%B8%8A%E7%9A%84%E8%B0%83%E8%AF%95%E5%99%A8%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[如果安装Qt时使用的是Visual Studio的预编译版，那么很有可能就会缺少调试器（Debugger），而使用MSVC的Qt对应的原生调试器是CDB（对应MinGW的Qt使用GDB调试器）。本文介绍如何下载安装CDB，并在Qt Creator配置之。 示例环境：Windows 7 64bit + Visual Studio 2013 + Qt 5.5.0 选择合适的Windows Driver Kit（WDK）CDB已经不再作为独立软件包，而是WDK中的一部分。虽然WDK是对应不同的Windows版本的，但是因为我们只需要CDB，而不开发驱动程序，基本上不用理会操作系统的要求，只需关注对应的Visual Studio版本即可。 WDK 7.1对应的是VS2010 WDK 8.0对应VS2012 WDK 8.1对应VS2013 WDK 8.0、WDK 8.1支持Windows 7、Windows Server 2008 R2、Windows8、Windows 8.1、Windows Server 2012，本文选用的就是WDK 8.1 从微软下载WDK 得到的是一个不到1MB的在线安装程序，安装时，只需要选中Debugging Tools for Windows即可，其它都可以不安装，如下图所示: 安装完成后Close关闭安装程序。 配置Qt Creator重新启动Qt Creator，在设置里面，Build &amp; Run的Kits选项卡，可以看到Kits里面之前的黄色感叹号三角形没有了，而且Debugger也被自动识别到了。 在Debugger面板里，CDB Path选项卡，点击Insert后边的小三角形选择Symbol Server，弹出的窗口填写存放Symbol的缓存文件夹。确认后如下图 不过第一次debug的时候，可能还是会提示Symbol Server的设置，一般直接确认就可以了。]]></content>
      <categories>
        <category>Qt学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql中create_database和create_schema的区别]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%2F2015%2F07%2F27%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0-mysql%E4%B8%93%E9%A2%98-2015-07-27-mysql%E4%B8%ADcreate-database%E5%92%8Ccreate-schema%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[&gt; 在使用MS SQL的时候，一般创建数据库我们都习惯于使用CREATE DATABASE 来完成，而使用CREATE SCHEMA来创建架构，但是在MySQL中，官方的中文文档在 CREATE DATABASE 语法一节中写了一句：也可以使用CREATE SCHEMA。那么CREATE SCHEMA和CREATE DATABASE在MySQL难道是一样的吗？ MySQL 5.0官方的英文文档中有这么一句： 123CREATE DATABASE creates a database with the given name.To use this statement, you need the CREATE privilege for the database.CREATE SCHEMA is a synonym for CREATE DATABASE as of MySQL 5.0.2. 这个说法译成中文应该是：CREATE DATABASE根据给定的名称创建数据库，要用这个语法，你需要有数据库的CREATE权限，CREATE SCHEMA从MySQL5.0.2起，可作为CREATE DATABASE的一个代名词。 按照这个说法，CREATE SCHEMA是和CREATE DATABASE是一样的，为了验证这个说法，参阅了后继的官方文档，在MySQL5.5的英文文档中，官方如是说： 123CREATE DATABASE creates a database with the given name.To use this statement, you need the CREATE privilege for the database.CREATE SCHEMA is a synonym for CREATE DATABASE. 中文：CREATE DATABASE根据给定的名称创建数据库，你需要拥有数据库的CREATE权限来使用这个语句。CREATE SCHEMA是CREATE DATABASE的一个代名词。 由此可见，在MySQL的语法操作中（MySQL5.0.2之后），可以使用CREATE DATABASE和CREATE SCHEMA来创建数据库，两者在功能上是一致的。在使用MySQL官方的MySQL管理工具MySQL Workbench 5.2.47创建数据库时，使用的是CREATE SCHEMA来创建数据库的。而这和MS SQL中的SCHEMA有很大差别。]]></content>
      <categories>
        <category>数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[检查 MySQL 配置文件 my.cnf 是否有误的方法]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%2F2015%2F07%2F24%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0-mysql%E4%B8%93%E9%A2%98-2015-07-25-%E6%A3%80%E6%9F%A5MySQL%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E6%9C%89%E8%AF%AF%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1/usr/libexec/mysqld --help --verbose]]></content>
      <categories>
        <category>数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql修改my.cnf的innodb_log_file_size后数据库启动失败的解决方法]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%2F2015%2F07%2F24%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0-mysql%E4%B8%93%E9%A2%98-2015-07-25-%E4%BF%AE%E6%94%B9innodb-log-file-size%E5%90%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[12# 找到mysql的数据目录下的ib_logfile文件，删除，然后重启mysql# 数据文件在配置文件有配置，若是默认则在`/var/lib/mysql/`下面]]></content>
      <categories>
        <category>数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python字符串相关处理]]></title>
    <url>%2FPython%E5%AD%A6%E4%B9%A0%2F2015%2F07%2F06%2FPython%E5%AD%A6%E4%B9%A0-2015-07-06-Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[版本控制Git常用命令图示]]></title>
    <url>%2F%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86%2F2015%2F06%2F24%2F%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86-2015-06-24-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6Git%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%9B%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[本图示转载自：这里]]></content>
      <categories>
        <category>项目工程管理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python在windows下的服务程序]]></title>
    <url>%2FPython%E5%AD%A6%E4%B9%A0%2F2015%2F06%2F09%2FPython%E5%AD%A6%E4%B9%A0-2015-06-09-python%E5%9C%A8windows%E4%B8%8B%E7%9A%84%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[Python程序作为Windows服务启动，需要安装pywin32包。下载路径： 我是下载路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import win32serviceutil import win32service import win32event class PythonService(win32serviceutil.ServiceFramework): """ Usage: 'PythonService.py [options] install|update|remove|start [...]|stop|restart [...]|debug [...]' Options for 'install' and 'update' commands only: --username domain\username : The Username the service is to run under --password password : The password for the username --startup [manual|auto|disabled|delayed] : How the service starts, default = manual --interactive : Allow the service to interact with the desktop. --perfmonini file: .ini file to use for registering performance monitor data --perfmondll file: .dll file to use when querying the service for performance data, default = perfmondata.dll Options for 'start' and 'stop' commands only: --wait seconds: Wait for the service to actually start or stop. If you specify --wait with the 'stop' option, the service and all dependent services will be stopped, each waiting the specified period. """ #服务名 _svc_name_ = "PythonService" #服务显示名称 _svc_display_name_ = "Python Service Demo" #服务描述 _svc_description_ = "Python service demo." def __init__(self, args): win32serviceutil.ServiceFramework.__init__(self, args) self.hWaitStop = win32event.CreateEvent(None, 0, 0, None) self.logger = self._getLogger() self.isAlive = True def _getLogger(self): import logging import os import inspect logger = logging.getLogger('[PythonService]') this_file = inspect.getfile(inspect.currentframe()) dirpath = os.path.abspath(os.path.dirname(this_file)) handler = logging.FileHandler(os.path.join(dirpath, "service.log")) formatter = logging.Formatter('%(asctime)s %(name)-12s %(levelname)-8s %(message)s') handler.setFormatter(formatter) logger.addHandler(handler) logger.setLevel(logging.INFO) return logger def SvcDoRun(self): import time self.logger.error("svc do run....") while self.isAlive: self.logger.error("I am alive.") time.sleep(1) # 等待服务被停止 #win32event.WaitForSingleObject(self.hWaitStop, win32event.INFINITE) def SvcStop(self): # 先告诉SCM停止这个过程 self.logger.error("svc do stop....") self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING) # 设置事件 win32event.SetEvent(self.hWaitStop) self.isAlive = Falseif __name__=='__main__': win32serviceutil.HandleCommandLine(PythonService) 安装服务 1python PythonService.py install 让服务自动启动 1python PythonService.py --startup auto install 启动服务 1python PythonService.py start 重启服务 1python PythonService.py restart 停止服务 1python PythonService.py stop 删除/卸载服务 1python PythonService.py remove]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql配置文件详解]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%2F2015%2F06%2F03%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0-mysql%E4%B8%93%E9%A2%98-2015-06-03-mysql%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[配置文件解析 你也可以使用在线配置文件生成向导来完成这个工作 4GB RAM, 只使用InnoDB, ACID, 少量的连接, 队列负载大 [client]1234# mysql客户端链接数据库时默认的tcp端口号port = 3306# 为MySQL客户程序与服务器之间的本地通信指定一个套接字文件(Linux下默认是/var/lib/mysql/mysql.sock文件)socket = /var/lib/mysql/mysql.sock [mysqld]一般配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144# mysql服务端监听默认的tcp端口号port = 3306 # 为MySQL客户程序与服务器之间的本地通信指定一个套接字文件(Linux下默认是/var/lib/mysql/mysql.sock文件)socket = /var/lib/mysql/mysql.sock# back_log 是操作系统在监听队列中所能保持的连接数,队列保存了在MySQL连接管理器线程处理之前的连接.# 如果你有非常高的连接率并且出现”connection refused” 报错,你就应该增加此处的值.# 检查你的操作系统文档来获取这个变量的最大值.如果将back_log设定到比你操作系统限制更高的值,将会没有效果back_log = 50# 不在TCP/IP端口上进行监听.如果所有的进程都是在同一台服务器连接到本地的mysqld,这样设置将是增强安全的方法# 所有mysqld的连接都是通过Unix sockets 或者命名管道进行的.注意在windows下如果没有打开命名管道选项而只是用此项# (通过 “enable-named-pipe” 选项) 将会导致mysql服务没有任何作用!# skip-networking# MySQL 服务所允许的同时会话数的上限，其中一个连接将被SUPER权限保留作为管理员登录.即便已经达到了连接数的上限.max_connections = 100# 每个客户端连接最大的错误允许数量,如果达到了此限制.这个客户端将会被MySQL服务阻止直到执行了”FLUSH HOSTS” 或者服务重启# 非法的密码以及其他在链接时的错误会增加此值.查看 “Aborted_connects” 状态来获取全局计数器.max_connect_errors = 10# 所有线程所打开表的数量.这样你需要确认在[mysqld_safe]中 “open-files-limit” 变量设置打开文件数量允许至少4096table_cache = 2048# 允许外部文件级别的锁. 打开文件锁会对性能造成负面影响,# 所以只有在你在同样的文件上运行多个数据库实例时才使用此选项(注意仍会有其他约束!)# 或者你在文件层面上使用了其他一些软件依赖来锁定MyISAM表external-locking# 服务所能处理的请求包的最大大小以及服务所能处理的最大的请求大小(当与大的BLOB字段一起工作时相当必要)# 每个连接独立的大小.大小动态增加max_allowed_packet = 16M# 在一个事务中binlog为了记录SQL状态所持有的cache大小,如果你经常使用大的,多声明的事务,你可以增加此值来获取更大的性能.# 所有从事务来的状态都将被缓冲在binlog缓冲中然后在提交后一次性写入到binlog中,如果事务比此值大, 会使用磁盘上的临时文件来替代.# 此缓冲在每个连接的事务第一次更新状态时被创建binlog_cache_size = 1M# 独立的内存表所允许的最大容量.此选项为了防止意外创建一个超大的内存表导致永尽所有的内存资源.max_heap_table_size = 64M# 排序缓冲被用来处理类似ORDER BY以及GROUP BY队列所引起的排序,如果排序后的数据无法放入排序缓冲,一个用来替代的基于磁盘的合并分类会被使用# 查看 “Sort_merge_passes” 状态变量.在排序发生时由每个线程分配sort_buffer_size = 8M# 此缓冲被使用来优化全联合(full JOINs 不带索引的联合).类似的联合在极大多数情况下有非常糟糕的性能表现,但是将此值设大能够减轻性能影响.# 通过 “Select_full_join” 状态变量查看全联合的数量,当全联合发生时,在每个线程中分配join_buffer_size = 8M# 我们在cache中保留多少线程用于重用,当一个客户端断开连接后,如果cache中的线程还少于thread_cache_size,则客户端线程被放入cache中.# 这可以在你需要大量新连接的时候极大的减少线程创建的开销, (一般来说如果你有好的线程模型的话,这不会有明显的性能提升.).thread_cache_size = 8# 此允许应用程序给予线程系统一个提示在同一时间给予渴望被运行的线程的数量.# 此值只对于支持 thread_concurrency() 函数的系统有意义( 例如Sun Solaris).# 你可可以尝试使用 [CPU数量]*(2..4) 来作为thread_concurrency的值thread_concurrency = 8# 查询缓冲常被用来缓冲 SELECT 的结果并且在下一次同样查询的时候不再执行直接返回结果.# 打开查询缓冲可以极大的提高服务器速度, 如果你有大量的相同的查询并且很少修改表.# 查看 “Qcache_lowmem_prunes” 状态变量来检查是否当前值对于你的负载来说是否足够高.# 注意: 在你表经常变化的情况下或者如果你的查询原文每次都不同,# 查询缓冲也许引起性能下降而不是性能提升.query_cache_size = 64M# 只有小于此设定值的结果才会被缓冲# 此设置用来保护查询缓冲,防止一个极大的结果集将其他所有的查询结果都覆盖.# query_cache_limit = 2M# 被全文检索索引的最小的字长.# 你也许希望减少它,如果你需要搜索更短字的时候.# 注意在你修改此值之后,# 你需要重建你的 FULLTEXT 索引ft_min_word_len = 4# 如果你的系统支持 memlock() 函数,你也许希望打开此选项用以让运行中的mysql在在内存高度紧张的时候。# 数据在内存中保持锁定并且防止可能被swapping out# 此选项对于性能有益# memlock# 当创建新表时作为默认使用的表类型,# 如果在创建表示没有特别执行表类型,将会使用此值default_table_type = MYISAM# 线程使用的堆大小. 此容量的内存在每次连接时被预留.# MySQL 本身常不会需要超过64K的内存# 如果你使用你自己的需要大量堆的UDF函数# 或者你的操作系统对于某些操作需要更多的堆,# 你也许需要将其设置的更高一点.thread_stack = 192K# 设定默认的事务隔离级别.可用的级别如下:# READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLEtransaction_isolation = REPEATABLE-READ# 内部(内存中)临时表的最大大小# 如果一个表增长到比此值更大,将会自动转换为基于磁盘的表.# 此限制是针对单个表的,而不是总和.tmp_table_size = 64M# 打开二进制日志功能.# 在复制(replication)配置中,作为MASTER主服务器必须打开此项# 如果你需要从你最后的备份中做基于时间点的恢复,你也同样需要二进制日志.# 如果你需要从你最后的备份中做基于时间点的恢复,你也同样需要二进制日志.log-bin=mysql-bin# 如果你在使用链式从服务器结构的复制模式 (A-&gt;B-&gt;C),# 你需要在服务器B上打开此项.# 此选项打开在从线程上重做过的更新的日志,# 并将其写入从服务器的二进制日志.# log_slave_updates# 打开全查询日志. 所有的由服务器接收到的查询 (甚至对于一个错误语法的查询)# 都会被记录下来. 这对于调试非常有用, 在生产环境中常常关闭此项.# log# 将警告打印输出到错误log文件. 如果你对于MySQL有任何问题# 你应该打开警告log并且仔细审查错误日志,查出可能的原因.# log_warnings# 记录慢速查询. 慢速查询是指消耗了比 “long_query_time” 定义的更多时间的查询.# 如果 log_long_format 被打开,那些没有使用索引的查询也会被记录.# 如果你经常增加新查询到已有的系统内的话. 一般来说这是一个好主意,log_slow_queries# 所有的使用了比这个时间(以秒为单位)更多的查询会被认为是慢速查询.# 不要在这里使用”1″, 否则会导致所有的查询,甚至非常快的查询页被记录下来(由于MySQL 目前时间的精确度只能达到秒的级别).long_query_time = 2# 在慢速日志中记录更多的信息.# 一般此项最好打开.# 打开此项会记录使得那些没有使用索引的查询也被作为到慢速查询附加到慢速日志里log_long_format# 此目录被MySQL用来保存临时文件.例如,# 它被用来处理基于磁盘的大型排序,和内部排序一样.# 以及简单的临时表.# 如果你不创建非常大的临时文件,将其放置到 swapfs/tmpfs 文件系统上也许比较好# 另一种选择是你也可以将其放置在独立的磁盘上.# 你可以使用”;”来放置多个路径# 他们会按照roud-robin方法被轮询使用.# tmpdir = /tmp 复制有关的设置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 # 唯一的服务辨识号,数值位于 1 到 2^32-1之间. # 此值在master和slave上都需要设置. # 如果 “master-host” 没有被设置,则默认为1, 但是如果忽略此选项,MySQL不会作为master生效. server-id = 1 # 复制结构中的master – 必须 # master-host = # 当连接到master上时slave所用来认证的用户名 – 必须 # master-user = # 当连接到master上时slave所用来认证的密码 – 必须 # master-password = # master监听的端口. # 可选 – 默认是3306 # master-port = # 使得slave只读.只有用户拥有SUPER权限和在上面的slave线程能够修改数据. # 你可以使用此项去保证没有应用程序会意外的修改slave而不是master上的数据 # read_only``` ***MyISAM 相关选项***```ini # 关键词缓冲的大小, 一般用来缓冲MyISAM表的索引块. # 不要将其设置大于你可用内存的30%, # 因为一部分内存同样被OS用来缓冲行数据 # 甚至在你并不使用MyISAM 表的情况下, 你也需要仍旧设置起 8-64M 内存由于它同样会被内部临时磁盘表使用. key_buffer_size = 32M # 用来做MyISAM表全表扫描的缓冲大小. # 当全表扫描需要时,在对应线程中分配. read_buffer_size = 2M # 当在排序之后,从一个已经排序好的序列中读取行时,行数据将从这个缓冲中读取来防止磁盘寻道. # 如果你增高此值,可以提高很多ORDER BY的性能. # 当需要时由每个线程分配 read_rnd_buffer_size = 16M # MyISAM 使用特殊的类似树的cache来使得突发插入 # (这些插入是,INSERT SELECT, INSERT VALUES (), (), , 以及 LOAD DATA # INFILE) 更快. 此变量限制每个进程中缓冲树的字节数. # 设置为 0 会关闭此优化. # 为了最优化不要将此值设置大于 “key_buffer_size”. # 当突发插入被检测到时此缓冲将被分配. bulk_insert_buffer_size = 64M # 此缓冲当MySQL需要在 REPAIR, OPTIMIZE, ALTER 以及 LOAD DATA INFILE 到一个空表中引起重建索引时被分配. # 这在每个线程中被分配.所以在设置大值时需要小心. myisam_sort_buffer_size = 128M # MySQL重建索引时所允许的最大临时文件的大小 (当 REPAIR, ALTER TABLE 或者 LOAD DATA INFILE). # 如果文件大小比此值更大,索引会通过键值缓冲创建(更慢) myisam_max_sort_file_size = 10G # 如果被用来更快的索引创建索引所使用临时文件大于制定的值,那就使用键值缓冲方法. # 这主要用来强制在大表中长字串键去使用慢速的键值缓冲方法来创建索引. myisam_max_extra_sort_file_size = 10G # 如果一个表拥有超过一个索引, MyISAM 可以通过并行排序使用超过一个线程去修复他们. # 这对于拥有多个CPU以及大量内存情况的用户,是一个很好的选择. myisam_repair_threads = 1 # 自动检查和修复没有适当关闭的 MyISAM 表. myisam_recover # 默认关闭 Federated skip-federated BDB 相关选项 12# 如果你运行的MySQL服务有BDB支持但是你不准备使用的时候使用此选项. 这会节省内存并且可能加速一些事.skip-bdb INNODB 相关选项 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# 如果你的MySQL服务包含InnoDB支持但是并不打算使用的话,# 使用此选项会节省内存以及磁盘空间,并且加速某些部分# skip-innodb# 附加的内存池被InnoDB用来保存 metadata 信息# 如果InnoDB为此目的需要更多的内存,它会开始从OS这里申请内存.# 由于这个操作在大多数现代操作系统上已经足够快, 你一般不需要修改此值.# SHOW INNODB STATUS 命令会显示当先使用的数量.innodb_additional_mem_pool_size = 16M# InnoDB使用一个缓冲池来保存索引和原始数据, 不像 MyISAM.# 这里你设置越大,你在存取表里面数据时所需要的磁盘I/O越少.# 在一个独立使用的数据库服务器上,你可以设置这个变量到服务器物理内存大小的80%# 不要设置过大,否则,由于物理内存的竞争可能导致操作系统的换页颠簸.# 注意在32位系统上你每个进程可能被限制在 2-3.5G 用户层面内存限制,# 所以不要设置的太高.innodb_buffer_pool_size = 2G# InnoDB 将数据保存在一个或者多个数据文件中成为表空间.# 如果你只有单个逻辑驱动保存你的数据,一个单个的自增文件就足够好了.# 其他情况下.每个设备一个文件一般都是个好的选择.# 你也可以配置InnoDB来使用裸盘分区 – 请参考手册来获取更多相关内容innodb_data_file_path = ibdata1:10M:autoextend# 设置此选项如果你希望InnoDB表空间文件被保存在其他分区.# 默认保存在MySQL的datadir中.# innodb_data_home_dir =# 用来同步IO操作的IO线程的数量. This value is# 此值在Unix下被硬编码为4,但是在Windows磁盘I/O可能在一个大数值下表现的更好.innodb_file_io_threads = 4# 如果你发现InnoDB表空间损坏, 设置此值为一个非零值可能帮助你导出你的表.# 从1开始并且增加此值知道你能够成功的导出表.# innodb_force_recovery=1# 在InnoDb核心内的允许线程数量.# 最优值依赖于应用程序,硬件以及操作系统的调度方式.# 过高的值可能导致线程的互斥颠簸.innodb_thread_concurrency = 16# 如果设置为1 ,InnoDB会在每次提交后刷新(fsync)事务日志到磁盘上,# 这提供了完整的ACID行为.# 如果你愿意对事务安全折衷, 并且你正在运行一个小的食物, 你可以设置此值到0或者2来减少由事务日志引起的磁盘I/O# 0代表日志只大约每秒写入日志文件并且日志文件刷新到磁盘.# 2代表日志写入日志文件在每次提交后,但是日志文件只有大约每秒才会刷新到磁盘上.innodb_flush_log_at_trx_commit = 1# 加速InnoDB的关闭. 这会阻止InnoDB在关闭时做全清除以及插入缓冲合并.# 这可能极大增加关机时间, 但是取而代之的是InnoDB可能在下次启动时做这些操作.# innodb_fast_shutdown# 用来缓冲日志数据的缓冲区的大小.# 当此值快满时, InnoDB将必须刷新数据到磁盘上.# 由于基本上每秒都会刷新一次,所以没有必要将此值设置的太大(甚至对于长事务而言)innodb_log_buffer_size = 8M# 在日志组中每个日志文件的大小.# 你应该设置日志文件总合大小到你缓冲池大小的25%~100%# 来避免在日志文件覆写上不必要的缓冲池刷新行为.# 不论如何, 请注意一个大的日志文件大小会增加恢复进程所需要的时间.innodb_log_file_size = 256M# 在日志组中的文件总数.# 通常来说2~3是比较好的.innodb_log_files_in_group = 3# InnoDB的日志文件所在位置. 默认是MySQL的datadir.# 你可以将其指定到一个独立的硬盘上或者一个RAID1卷上来提高其性能# innodb_log_group_home_dir# 在InnoDB缓冲池中最大允许的脏页面的比例.# 如果达到限额, InnoDB会开始刷新他们防止他们妨碍到干净数据页面.# 这是一个软限制,不被保证绝对执行.innodb_max_dirty_pages_pct = 90# InnoDB用来刷新日志的方法.# 表空间总是使用双重写入刷新方法# 默认值是 “fdatasync”, 另一个是 “O_DSYNC”.# innodb_flush_method=O_DSYNC# 在被回滚前,一个InnoDB的事务应该等待一个锁被批准多久.# InnoDB在其拥有的锁表中自动检测事务死锁并且回滚事务.# 如果你使用 LOCK TABLES 指令, 或者在同样事务中使用除了InnoDB以外的其他事务安全的存储引擎# 那么一个死锁可能发生而InnoDB无法注意到.# 这种情况下这个timeout值对于解决这种问题就非常有帮助.innodb_lock_wait_timeout = 120 [mysqldump]123# 不要在将内存中的整个结果写入磁盘之前缓存. 在导出非常巨大的表时需要此项quickmax_allowed_packet = 16M [mysql]123no-auto-rehash# 仅仅允许使用键值的 UPDATEs 和 DELETEs .# safe-updates [isamchk]1234key_buffer = 512Msort_buffer_size = 512Mread_buffer = 8Mwrite_buffer = 8M [myisamchk]1234key_buffer = 512Msort_buffer_size = 512Mread_buffer = 8Mwrite_buffer = 8M [mysqlhotcopy]12interactive-timeout [mysqld_safe]1234# 增加每个进程的可打开文件数量.# 警告: 确认你已经将全系统限制设定的足够高!# 打开大量表需要将此值设bopen-files-limit = 8192]]></content>
      <categories>
        <category>数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql中文乱码问题]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%2F2015%2F06%2F03%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0-mysql%E4%B8%93%E9%A2%98-2015-06-03-mysql%E8%A7%A3%E5%86%B3%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. 查看当前编码 登陆mysql查看 1show variables like &apos;character%&apos;; 显示如下： character_set_database和character_set_server的默认字符集还是latin1 2. 修改字符编码 在[mysqld]字段加入character-set-server=utf8： 1234[mysqld]port = 3306socket = /var/lib/mysql/mysql.socketcharacter-set-server = utf-8 在[client]字段加入default-character-set=utf-8: 1234[client]port = 3306socket = /var/lib/mysql/mysql.sockdefault-character-set=utf8 在[mysql]字段里加入default-character-set=utf8： 123[mysql]no-auto-rehashdefault-character-set=utf8 3. 修改完成后，service mysql restart重启mysql服务就生效 4. 查阅目前的编码 1SHOW VARIABLES LIKE ‘&apos;character%&apos;; 5. 连接层修改编码 若是经过上述设置以后汉子依然乱码则需要在发送查询之前执行 1set names &apos;utf8&apos; 他相当于： 123SET character_set_client = utf8;SET character_set_results = utf8;SET character_set_connection = utf8; 6. 终极解决方案 12345678[client]default-character-set=utf8[mysql]default-character-set=utf8[mysqld]collation-server = utf8_unicode_ciinit-connect=’SET NAMES utf8′character-set-server = utf8]]></content>
      <categories>
        <category>数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux脚本文件格式错误]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2015%2F06%2F01%2Flinux%E5%AD%A6%E4%B9%A0-2015-06-01-linux%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[/bin/sh^M:bad interpreter: No such file or directory 这个错误发生在你在windows下编写文件上传到linux服务器去运行的时候。错误原因：windows和linux的文件不一样。 解决办法:vi该文件 在命令模式下输入 :set ff=unix 回车 执行完成后输入:wq]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux目录结构]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2015%2F05%2F27%2Flinux%E5%AD%A6%E4%B9%A0-2015-05-27-linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[在Linux文件系统中的每一个子目录都有特定的目的和用途。一般都是根据FHS标准定义一个正式的文件系统结构的，这个标准规定了哪些目录应该哪些作用 FHS依据文件系统使用的频繁与否与是否允许使用者随意更动, 而将目录定义成为四种交互作用的形态,用表格来说有点像底下这样： 可分享的(shareable) 不可分享的(unshareable) 不变的(static) /usr (软件放置处) /etc (配置文件) /opt (第三方协力软件) /boot (开机与核心档) 可变动的(variable) /var/mail (使用者邮件信箱) /var/run (程序相关) /var/spool/news (新闻组) /var/lock (程序相关) 可分享的：可以分享给其他系统挂载使用的目录,所以包括执行文件与用户的邮件等数据, 是能够分享给网络上其他主机挂载用的目录； 不可分享的：自己机器上面运作的装置文件或者是与程序有关的socket文件等, 由于仅与自身机器有关,所以当然就不适合分享给其他主机了. 不变的：有些数据是不会经常变动的,跟随着distribution而不变动. 例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等； 可变动的：经常改变的数据,例如登录文件、一般用户可自行收受的新闻组等. 事实上,FHS针对目录树架构仅定义出三层目录底下应该放置什么数据而已,分别是底下这三个目录的定义： / (root, 根目录)：与开机系统有关； /usr (unix software resource)：与软件安装/执行有关； /var (variable)：与系统运作过程有关. 1.根目录 (/) 的意义与内容：摘要： 所有的目录都是由根目录衍生出来的(根目录是整个系统最重要的一个目录) 与开机/还原/系统修复等动作有关. (由于系统开机时需要特定的开机软件、核心文件、开机所需程序、 函式库等等文件数据,若系统出现错误时,根目录也必须要包含有能够修复文件系统的程序才行) FHS标准建议：根目录(/)所在分割槽应该越小越好, 且应用程序所安装的软件最好不要与根目录放在同一个分割槽内,保持根目录越小越好.(因为越大的分割槽妳会放入越多的数据,如此一来根目录所在分割槽就可能会有较多发生错误的机会,如此不但效能较佳,根目录所在的文件系统也较不容易发生问题.) 1.1根目录(/)底下目录FHS定义的说明： 目录 应放置文件内容 /bin 系统有很多放置执行文件的目录,但/bin比较特殊.因为/bin放置的是在单人维护模式下还能够被操作的指令. 在/bin底下的指令可以被root与一般账号所使用,主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的指令. /boot 这个目录主要在放置开机会使用到的文件,包括Linux核心文件以及开机选单与开机所需配置文件等等. Linux kernel常用的档名为：vmlinuz,如果使用的是grub这个开机管理程序, 则还会存在/boot/grub/这个目录！ /dev 在Linux系统上,任何装置与接口设备都是以文件的型态存在于这个目录当中的. 你只要透过存取这个目录底下的某个文件,就等于存取某个装置啰～ 比要重要的文件有/dev/null, /dev/zero, /dev/tty, /dev/lp, /dev/hd, /dev/sd*等等 /etc 系统主要的配置文件几乎都放置在这个目录内,例如人员的账号密码文件、 各种服务的启始档等等.一般来说,这个目录下的各文件属性是可以让一般使用者查阅的, 但是只有root有权力修改.FHS建议不要放置可执行文件(binary)在这个目录中喔.比较重要的文件有： /etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/ 等等. /home 这是系统默认的用户家目录(home directory).在你新增一个一般使用者账号时, 默认户家目录都会规范到这里来.比较重要的是,家目录有两种代号喔：~：代表目前这个用户的家目录,而 ~dmtsai ：则代表 dmtsai 的家目录！ /lib 系统的函式库非常的多,而/lib放置的则是在开机时会用到的函式库, 以及在/bin或/sbin底下的指令会呼叫的函式库而已. 什么是函式库呢？妳可以将他想成是『外挂』,某些指令必须要有这些『外挂』才能够顺利完成程序的执行之意. 尤其重要的是/lib/modules/这个目录, 因为该目录会放置核心相关的模块(驱动程序)喔！ /media media是『媒体』的英文,顾名思义,这个/media底下放置的就是可移除的装置啦！ 包括软盘、光盘、DVD等等装置都暂时挂载于此.常见的档名有：/media/floppy, /media/cdrom等等. /mnt 如果妳想要暂时挂载某些额外的装置,一般建议妳可以放置到这个目录中. 在最早时候,这个目录的用途与/media相同啦！只是有了/media之后,这个目录就用来暂时挂载用了. /opt 这个是给第三方协力软件放置的目录.什么是第三方协力软件啊？ 举例来说,KDE这个桌面管理系统是一个独立的计划,不过他可以安装到Linux系统中,因此KDE的软件就建议放置到此目录下了. 另外,如果妳想要自行安装额外的软件(非原本的distribution提供的),那么也能够将你的软件安装到这里来. 不过,以前的Linux系统中,我们还是习惯放置在/usr/local目录下呢！ /root 系统管理员(root)的家目录.之所以放在这里,是因为如果进入单人维护模式而仅挂载根目录时, 该目录就能够拥有root的家目录,所以我们会希望root的家目录与根目录放置在同一个分割槽中 /sbin Linux有非常多指令是用来设定系统环境的,这些指令只有root才能够利用来『设定』系统,其他用户最多只能用来『查询』而已. 放在/sbin底下的为开机过程中所需要的,里面包括了开机、修复、还原系统所需要的指令. 至于某些服务器软件程序,一般则放置到/usr/sbin/当中.至于本机自行安装的软件所产生的系统执行文件(system binary), 则放置到/usr/local/sbin/当中了.常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等. /srv srv可以视为『service』的缩写,是一些网络服务启动之后,这些服务所需要取用的数据目录. 常见的服务例如WWW, FTP等等.举例来说,WWW服务器需要的网页数据就可以放置在/srv/www/里面. /tmp 这是让一般使用者或者是正在执行的程序暂时放置文件的地方. 这个目录是任何人都能够存取的,所以你需要定期的清理一下.当然,重要数据不可放置在此目录啊！ 因为FHS甚至建议在开机时,应该要将/tmp下的数据都删除！ /lost+found 这个目录是使用标准的ext2/ext3文件系统格式才会产生的一个目录,目的在于当文件系统发生错误时, 将一些遗失的片段放置到这个目录下.这个目录通常会在分割槽的最顶层存在, 例如你加装一颗硬盘于/disk中,那在这个系统下就会自动产生一个这样的目录『/disk/lost+found』 /proc 这个目录本身是一个『虚拟文件系统(virtual filesystem)』喔！他放置的数据都是在内存当中, 例如系统核心、行程信息(process)、周边装置的状态及网络状态等等.因为这个目录下的数据都是在内存当中, 所以本身不占任何硬盘空间啊！比较重要的文件例如：/proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/* 等等. /sys 这个目录其实跟/proc非常类似,也是一个虚拟的文件系统,主要也是记录与核心相关的信息. 包括目前已加载的核心模块与核心侦测到的硬件装置信息等等.这个目录同样不占硬盘容量！ PS：不可以移动的目录： 根目录与开机有关,开机过程中仅有根目录会被挂载, 其他分割槽则是在开机完成之后才会持续的进行挂载的行为.就是因为如此,因此根目录下与开机过程有关的目录, 就不能够与根目录放到不同的目录去！ /etc：配置文件 /bin：重要执行档 /dev：所需要的装置文件 /lib：执行档所需的函式库与核心所需的模块 /sbin：重要的系统执行文件 1.2 /usr 的意义与内容： 依据FHS的基本定义,/usr里面放置的数据属于可分享的与不可变动的(shareable, static), 如果你知道如何透过网络进行分割槽的挂载,那么/usr确实可以分享给局域网络内的其他主机来使用！ usr(Unix Software Resource 即Unix操作系统软件资源) FHS建议所有软件开发者,应该将他们的数据合理的分别放置到这个目录下的次目录,而不要自行建立该软件自己独立的目录. 所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下,因此这个目录有点类似Windows 系统的『C:\Windows\ + C:\Program files\』这两个目录的综合体,系统刚安装完毕时,这个目录会占用最多的硬盘容量. /usr的次目录建议有底下这些： 目录 应放置文件内容 /usr/X11R6/ 为X Window System重要数据所放置的目录,之所以取名为X11R6是因为最后的X版本为第11版,且该版的第6次释出之意. /usr/bin/ 绝大部分的用户可使用指令都放在这里！请注意到他与/bin的不同之处.(是否与开机过程有关) /usr/include/ c/c++等程序语言的档头(header)与包含档(include)放置处,当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时,会使用到里头的许多包含档喔！ /usr/lib/ 包含各应用软件的函式库、目标文件(object file),以及不被一般使用者惯用的执行档或脚本(script). 某些软件会提供一些特殊的指令来进行服务器的设定,这些指令也不会经常被系统管理员操作, 那就会被摆放到这个目录下啦.要注意的是,如果你使用的是X86_64的Linux系统, 那可能会有/usr/lib64/目录产生喔！ /usr/local/ 系统管理员在本机自行安装自己下载的软件(非distribution默认提供者),建议安装到此目录, 这样会比较便于管理.举例来说,你的distribution提供的软件较旧,你想安装较新的软件但又不想移除旧版, 此时你可以将新版软件安装于/usr/local/目录下,可与原先的旧版软件有分别啦！ 你可以自行到/usr/local去看看,该目录下也是具有bin, etc, include, lib…的次目录！ /usr/sbin/ 非系统正常运作所需要的系统指令.最常见的就是某些网络服务器软件的服务指令(daemon)！ /usr/share/ 放置共享文件的地方,在这个目录下放置的数据几乎是不分硬件架构均可读取的数据, 因为几乎都是文本文件. /usr/src/ 一般原始码建议放置到这里,src有source的意思.至于核心原始码则建议放置到/usr/src/linux/目录下. 1.3 /var 的意义与内容： /var目录主要针对常态性变动的文件,包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件, 包括程序文件(lock file, run file),或者例如MySQL数据库的文件等等. 所以/var在系统运作后才会渐渐占用硬盘容量的目录 常见的次目录有： 目录 应放置文件内容 /var/cache/ 应用程序本身运作过程中会产生的一些暂存档； /var/lib/ 程序本身执行的过程中,需要使用到的数据文件放置的目录.在此目录下各自的软件应该要有各自的目录. 举例来说,MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去！ /var/lock/ 某些装置或者是文件资源一次只能被一个应用程序所使用,如果同时有两个程序使用该装置时, 就可能产生一些错误的状况,因此就得要将该装置上锁(lock),以确保该装置只会给单一软件所使用. 举例来说,刻录机正在刻录一块光盘,你想一下,会不会有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录,那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁, 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用啰. /var/log/ 重要到不行！这是登录文件放置的目录！里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等. /var/mail/ 放置个人电子邮件信箱的目录,不过这个目录也被放置到/var/spool/mail/目录中！ 通常这两个目录是互为链接文件啦！ /var/run/ 某些程序或者是服务启动后,会将他们的PID放置在这个目录下喔！ 至于PID的意义我们会在后续章节提到的. /var/spool/ 这个目录通常放置一些队列数据,所谓的『队列』就是排队等待其他程序使用的数据啦！ 这些数据被使用后通常都会被删除.举例来说,系统收到新信会放置到/var/spool/mail/中, 但使用者收下该信件后该封信原则上就会被删除.信件如果暂时寄不出去会被放到/var/spool/mqueue/中, 等到被送出后就被删除.如果是工作排程数据(crontab),就会被放置到/var/spool/cron/目录中！]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux下SSH命令用法小结]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2015%2F05%2F27%2Flinux%E5%AD%A6%E4%B9%A0-2015-05-27-linux%E4%B8%8BSSH%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[SSH为Secure Shell的缩写，由IETF的网络工作小组（Network Working Group）所制定；SSH为创建在应用层和传输层基础上的安全协议。在我们日常的工作中，经常涉及到维护服务器，那么为了方便操作，以及安全方面的考虑，通常我们都会在服务器上安装ssh服务端，这样，在我们自己的机器上通过ssh客户端工具连接到服务器，既方便又安全。下面说说ssh应用的基本功能。 1、连接到远程主机：123ssh name@remoteserver;或者ssh remoteserver -l name 说明：以上两种方式都可以远程登录到远程主机，server代表远程主机，name为登录远程主机的用户名。 2、连接到远程主机指定的端口：123ssh name@remoteserver -p 2222;或者ssh remoteserver -l name –p 2222 说明：p 参数指定端口号，通常在路由里做端口映射时，我们不会把22端口直接映射出去，而是转换成其他端口号，这时就需要使用-p 端口号命令格式。 3、通过远程主机1跳到远程主机2：1ssh -t remoteserver1 ssh remoteserver2 说明：当远程主机remoteserver2无法直接到达时，可以使用-t参数，然后由remoteserver1跳转到remoteserver2。在此过程中要先输入remoteserver1的密码，然后再输入remoteserver2的密码，然后就可以操作remoteserver2了。 4、通过SSH运行远程shell命令：1ssh -l name remoteserver ‘command’ 说明：连接到远程主机，并执行远程主机的command命令。例如：查看远程主机的内存使用情况。 5、修改SSH监听端口：&gt;默认情况下，SSH监听连接端口22，攻击者使用端口扫描软件就可以看到主机是否运行有SSH服务，将SSH端口修改为大于1024的端口是一个明智的选择，因为大多数端口扫描软件（包括nmap）默认情况都不扫描高位端口。打开/etc/ssh/sshd_config文件并查找下面这样的行： 1234567Port 22``` 去掉该行前面的# 号，然后修改端口号并重新启动SSH服务：```sh$ /etc/init.d/ssh restart 6、仅允许SSH协议版本2：&gt;有两个SSH协议版本，仅使用SSH协议版本2会更安全，SSH协议版本1有安全问题，包括中间人攻击（man-in-the-middle）和注入（insertion）攻击。编辑/etc/ssh/sshd_config文件并查找下面这样的行： 1# Protocol 2,1 修改为： 1Protocol 2 7、禁止root用户登录：&gt;通常情况下，不采用直接用root用户登录到远程主机，由于root用户拥有超级权限，这样会带来安全隐患，所以，一般我们用普通用户登录，当需要管理远程主机时，再切换到root用户下。打开/etc/ssh/sshd_config文件并查找下面这样的行： 1#PermitRootLogin yes 将#号去掉，然后将yes修改成no，重启ssh服务，这样就可以禁止root用户登录。 8、设置登录时提示信息&gt;首先编辑一个文件，如bannertest.txt，文件内容自行定义。然后打开/etc/ssh/sshd_config文件并查找下面这样的行： 1#Banner /some/path 将#号去掉，然后将bannertest.txt文件的全路径替换/some/path，然后保存，重启ssh服务。当客户端登录时，就会看到bannertest.txt文件中的提示信息。 9、scp命令：&gt;scp命令是SSH中最方便有用的命令，可以在两台服务器之间传送文件。并且在传输过程中仍是使用ssh加密的。 将远程主机的/tmp/test 文件复制到本地的/bak文件夹下 1scp -p root@192.168.1.120:/tmp/test /bak 将本地/bak/1234 文件复制到远程主机的/tmp路径下 1scp -p /bak/1234 root@192.168.1.120:/tmp]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[远程开机包封装]]></title>
    <url>%2FPython%E5%AD%A6%E4%B9%A0%2F2015%2F05%2F19%2FPython%E5%AD%A6%E4%B9%A0-2015-05-19-Wake-on-lan%E8%BF%9C%E7%A8%8B%E5%BC%80%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[使用方法 同一局域网内的机器，只需指定目标主机的MAC地址，就令远程主机开机。 非同一局域网的情况下，除需指定目标主机的MAC地址，还需指定目标主机的地址。 示例： 同一局域网内的使用示例：./wake_on_lan.py -m 12-34-56-78-90-AB 非同一局域网的使用示例：./wake_on_lan.py -m 12-34-56-78-90-AB -a 8.8.8.8 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#coding=utf-8from optparse import OptionParserimport socketimport structdef wake(addr, mac): mac_data = [] for i in range(0, 12, 2): mac_data.append(int(mac[i:i+2], 16)) packet = struct.pack("!BBBBBB", 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF); packet_mac = struct.pack("!BBBBBB", *mac_data) for i in range(0, 16): packet += packet_mac #print "len: ", len(packet), "data: ", packet s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1) try: s.sendto(packet, addr) print "唤醒数据包发送完成", addr, mac finally: s.close()def main(): usage = "%prog [options]" parser = OptionParser(usage = usage) parser.add_option("-a", "--addr", dest="addr", help="Boardcast address", metavar="255.255.255.255") parser.add_option("-p", "--port", dest="port", help="Port", metavar="7") parser.add_option("-m", "--mac", dest="mac", help="MAC address", metavar="FF-FF-FF-FF-FF-FF") (options, args) = parser.parse_args() if not options.mac: parser.print_help() return addr = "255.255.255.255" port = 7 mac = options.mac.replace("-", "") if options.addr: addr = options.addr if len(mac) != 12: print "无效的MAC地址: %s" % options.mac return if options.port: port = int(options.port) wake((addr, port), mac)if __name__ == "__main__": main()]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux系统信息命令]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2015%2F05%2F19%2Flinux%E5%AD%A6%E4%B9%A0-2015-05-19-linux%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[linux系统信息 查看内核/操作系统/CPU信息 1uname -a 查看操作系统版本 1head -n 1 /etc/issue 查看CPU信息 1cat /proc/cpuinfo 查看计算机名 1hostname 列出所有PCI设备 1lspci -tv 列出所有USB设备 1lsusb -tv 列出加载的内核模块 1lsmod 查看环境变量 1env 显示机器的处理器架构(1) 1arch 显示机器的处理器架构(2) 1uname -m 显示正在使用的内核版本 1uname -r 显示硬件系统部件 1dmidecode -q 罗列一个磁盘的架构特性 1hdparm -i /dev/hda 在磁盘上执行测试性读取操作 1hdparm -tT /dev/sda 显示中断 1cat /proc/interrupts 校验内存使用 1cat /proc/meminfo 显示哪些swap被使用 1cat /proc/swaps 显示内核的版本 1cat /proc/version 显示网络适配器及统计 1cat /proc/net/dev 显示已加载的文件系统 1cat /proc/mounts 显示系统日期 1date 显示2015年的日历表 1234567 cal 2015``` * 设置日期和时间 – 月日时分年.秒```sh date 041217002007.00 将时间修改保存到 BIOS 1clock -w 系统的关机、重启以及登出 关闭系统(1) 1shutdown -h now 关闭系统(2) 1init 0 关闭系统(3) 1telinit 0 按预定时间关闭系统 1shutdown -h hours:minutes &amp; 取消按预定时间关闭系统 1shutdown -c 重启 (1) 1shutdown -r now 重启 (2) 1reboot 注销 1logout 查看linux系统资源 查看内存使用量和交换区使用量 1free -m 查看各分区使用情况 1df -h 查看指定目录的大小 1du -sh &lt;目录名&gt; 查看内存总量 1grep MemTotal /proc/meminfo 查看空闲内存量 1grep MemFree /proc/meminfo 查看系统运行时间、用户数、负载 1uptime 查看系统负载 1cat /proc/loadavg 查看linux磁盘和分区 查看挂接的分区状态 1mount | column -t 查看所有分区 1fdisk -l 查看所有交换分区 1swapon -s 查看磁盘参数(仅适用于IDE设备) 1hdparm -i /dev/hda 查看启动时IDE设备检测状况 1dmesg | grep IDE 查看网络配置的命令 查看所有网络接口的属性 1ifconfig 查看防火墙设置 1iptables -L 查看路由表 1route -n 查看所有监听端口 1netstat -lntp 查看所有已经建立的连接 1netstat -antp 查看网络统计信息 1netstat -s 查看linux进程 查看所有进程 1ps -ef 实时显示进程状态 1top 查看用户的命令 查看活动用户 1w 查看指定用户信息 1id &lt;用户名&gt; 查看用户登录日志 1last 查看系统所有用户 1cut -d: -f1 /etc/passwd 查看系统所有组 1cut -d: -f1 /etc/group 查看当前用户的计划任务 1crontab -l 查看系统服务的命令 列出所有系统服务 1chkconfig –list 列出所有启动的系统服务 1chkconfig –list | grep on 安装程序的命令 查看所有安装的软件包 1rpm -qa 获取帮助的命令 1man &lt;命令&gt;]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux下mysql忘记root密码的处理方案]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%2F2015%2F05%2F17%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0-mysql%E4%B8%93%E9%A2%98-2015-04-15-linux%E4%B8%8Bmysql%E5%BF%98%E8%AE%B0root%E5%AF%86%E7%A0%81%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[准备工作 首先确认mysql数据库处于安全状态，因为在找回密码的过程中，mysql处于没有密码保护的状态，任何人都可以连接数据库并且对数据库作出修改，建议断开对外端口，或者断开对外网线，最保险的办法就是断开对外网络同时登录服务器通过控制台操作 修改mysql的登录设置 修改配置文件 1vi /etc/my.cnf 在1234567&gt; skip-grant-tables * 重新启动mysqld```sh /etc/init.d/mysqld restart 登录并修改mysql密码 1234/usr/bin/mysql use mysql;update user set password=PASSWORD('p12#456') where user='root' and host='root' or host='localhost';flush privileges; 修改配置文件并重启服务 将刚才在[mysqld]的段中加上的skip-grant-tables删除 1/etc/init.d/mysqld restart]]></content>
      <categories>
        <category>数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CentOS 6.5通过源码安装nginx]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2015%2F05%2F12%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2015-05-12-CentOS6-5%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85nginx%2F</url>
    <content type="text"><![CDATA[1.下载nginx源码 官方网址：http://nginx.org/en/download.html 123cd /tmp# 文章写作时最新的稳定版本为1.8.0wget http://nginx.org/download/nginx-1.8.0.tar.gz 解压源码包 1tar -zxvf nginx-1.8.0.tar.gz 2.编译安装nginx 安装依赖包文件 1yum install openssl-devel pcre-devel zlib-devel pcre可用包 配置nginx编译选项 12cd /tmp/nginx-1.8.0./configure --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-http_ssl_module --with-http_realip_module --with-http_addition_module --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_random_index_module --with-http_secure_link_module --with-http_stub_status_module --with-http_auth_request_module --with-mail --with-mail_ssl_module --with-file-aio --with-ipv6 --with-http_spdy_module --with-cc-opt='-O2 -g -pipe -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -m64 -mtune=generic' 编译安装 1make &amp;&amp; make install 3. 启动测试nginx123/usr/sbin/nginx# 提示错误nginx: [emerg] getpwnam("nginx") failed 创建nginx用户和组 12groupadd -r nginxuseradd -r -g nginx -s /bin/false -M nginx 创建相应目录 1234# 启动错误nginx: [emerg] mkdir() &quot;/var/tmp/nginx/client/&quot; failed (2: No such file or directory)# 创建对应目录mkdir /var/tmp/nginx 启动nginx 1/usr/sbin/nginx 4. nginx 基本操作12345678910111213141516查看帮助/usr/local/nginx/sbin/nginx -h立即停止进程(TERM信号)/usr/local/nginx/sbin/nginx -s stop温和停止进程(QUIT信号)/usr/local/nginx/sbin/nginx -s quit重加载/etc/init.d/nginx reload #有init脚本情况下/usr/local/nginx/sbin/nginx -s reload #原生检测配置文件是否正确/usr/local/nginx/sbin/nginx -t #生产路径下的/usr/local/nginx/sbin/nginx -t -c /home/ken/tmp/test.conf #可以测试某个临时文件 5. HTTP基本配置5.1 配置说明123456注释，#每条指令总是以分号结束(;)配置继承：在一个区块中嵌套其他区段，那么被嵌套的区段会继承其父区段的设置字符串，可以没有引号，但是如果存在特殊字符（空格，分号，花括号）需要用引号引起单位：大小(k/K m/M) 时间值(ms/s/m/h/d/w/M/y 默认s)模块提供各种变量值，可以进行读取和赋值（每个模块提供变量列表需要自己去查） 5.2 配置文件目录结构123456789101112131415/usr/local/nginx/conf/- mime.types 一个文件扩展列表，它们与MIME类型关联- fastcgi.conf 与FastCGI相关的配置文件- proxy.conf 与Proxy相关的配置文件- nginx.conf 应用程序的基本配置文件- sites/ |- a.conf #允许给每个单独网站建立一个配置文件 |- b.conf |- dir/ |- c.conf需要在nginx.conf中使用包含命令include sites/*.conf;include sites/*/*.conf; 5.3 配置文件结构1234567891011121314151617181920212223242526272829303132333435http &#123; #嵌入配置文件的根部， 一个http里可以配置多个server server &#123; #声明一个站点 server_name www.website.com; #监听的主机名 listen 80; #监听套接字所使用的ip地址和端口号 error_page 404 /not_found.html; error_page 500 501 502 503 504 /server_error.html; index index.html; root /var/www/website/com/html; #定义文档的根目录 #location, 通过制定的模式与客户端请求的URI相匹配 location / &#123; #网站的特定位置 &#125; location /admin/ &#123; #网站的特定位置 # alias /var/www/locked/; #只能放在 location区段中，为指定路径提供别名 &#125; #操作符,匹配时跟定义顺序无关 location = /abcd &#123; #精确匹配，不能用正则 &#125; location /abc/ &#123; #url必须以指定模式开始，不能用正则 &#125; location ^~ /abcd$ &#123; #吴标致行为，URI定位必须以指定模式开始，如果匹配，停止搜索其他模式 &#125; location ~ ^/abcd$ &#123; #正则匹配，区分大小写 &#125; location ~* ^/abcd$ &#123; #正则匹配，不区分大小写 &#125; location @test &#123; #定义location区段名，客户端不能访问，内部产生的请求可以,例如try_files或error_page &#125; &#125;&#125; 6. 模块6.1 模块化nginx真正的魅力在于它的模块，整个应用程序建立在一个模块化系统之上，在编译时，可以对每一个模块进行启用或者禁用 6.2 index模块定义去哪里找index,可以定义多个，但是 nginx 只提供第一个找到的文件； 12index index.php index.html /data/website/index.html;#可以指定多个，但是ngxin提供第一个找到的文件 6.3 Log模块12access_log /file/path;error_log /file/path error; #level: debug/info/notice/warn/error/crit 日志格式 123log_format main $remote_addr - $remote_user [$time_local] &quot;$request&quot; $status $body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot; $http_x_forwarded_for;access_log /var/log/test.log main; 6.4 Real IP模块默认编译nginx不包含这个模块 当通过nginx将用户请求进行转发时，接收请求的应用要拿到用户的真实IP(经转发拿到的是服务器的IP) 1real_ip_header X-Forwarded-For; 6.5 Access模块可以禁用ip段, 语法： 123456789#如果规则之间有冲突，会以最前面匹配的规则为准deny IP;deny subnet;allow IP;allow subnet;# block all ipsdeny all;# allow all ipsallow all; 配置一个blockips.conf,然后在nginx.conf中include 例如： 1234location &#123; allow 127.0.0.1; #允许本地ip 注意顺序，allow要放在前面 deny all; #禁止其他ip&#125; 6.6 Rewrite模块作用：执行URL重定向,允许你去掉带有恶意的URL，包含多个参数（修改）利用正则的匹配，分组和引用，达到目的break/return/set等 123456rewrite A B option;options: last :表示完成rewrite break:本规则匹配完成后，终止匹配，不再匹配后面的规则 redirect:返回302临时重定向，地址栏会显示跳转后的地址 permanent:返回301永久重定向，地址栏会显示跳转后的地址 6.7 Proxy模块默认模块，允许你把客户端的HTTP请求转到后端服务器： 12345678location / &#123; proxy_pass_header Server; #该指令强制一些被忽略的头传递到客户端 proxy_redirect off; #允许改写出现在HTTP头却被后端服务器触发重定向的URL,对相应本身不做任何处理 proxy_set_header Host $http_host; #允许你重新定义代理header值再转到后端服务器.目标服务器可以看到客户端的原始主机名 proxy_set_header X-Real-IP $remote_addr; #目标服务器可以看到客户端的真实ip，而不是转发服务器的ip proxy_set_header X-Scheme $scheme; proxy_pass http://localhost:8080;&#125; upstream模块 123456upstream up_name &#123; server 192.168.0.1:9000 weight=5; #权重 server 192.168.0.2:9000 weight=5 max_fails=5 fail_timeout=60s; #在60s内，其错误通信超过5次,认为该服务失效 server 192.168.0.3:9000 down; #服务标记为离线，不再使用 server 192.168.0.4:9000 backup; #备份服务器，其他全部宕机了才启用&#125; 7. 配置静态化目录12345location /static/&#123; root /var/www/app/; autoindex off;&#125; 8. 负载均衡123456789101112131415161718192021222324252627http &#123; include mime.types; default_type application/octet-stream; keepalive_timeout 120; tcp_nodelay on; upstream up_localhost &#123; server 127.0.0.1:8000 weight=5; server 127.0.0.1:8001 weight=10; &#125; server &#123; listen 80; server_name localhost; location /&#123; proxy_pass http://up_localhost; proxy_set_header Host $host; proxy_set_header X-Real_IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; &#125;&#125; 9. 控制页面缓存123456789101112location ~ \.(htm|html|gif|jpg|jpeg|png|bmp|ico|css|js|txt)$ &#123; root /opt/webapp; expires 24h;&#125;expires 1 January, 1970, 00:00:01 GMT;expires 60s;expires 30m;expires 24h;expires 1d;expires max;expires off; 10. nginx的内置变量123456789101112131415161718192021222324252627282930$arg_PARAMETER 这个变量包含在查询字符串时GET请求PARAMETER的值。$args 这个变量等于请求行中的参数。$binary_remote_addr 二进制码形式的客户端地址。$body_bytes_sent$content_length 请求头中的Content-length字段。$content_type 请求头中的Content-Type字段。$cookie_COOKIE cookie COOKIE的值。$document_root 当前请求在root指令中指定的值。$document_uri 与$uri相同。$host 请求中的主机头字段，如果请求中的主机头不可用，则为服务器处理请求的服务器名称。$is_args 如果$args设置，值为&quot;?&quot;，否则为&quot;&quot;。$limit_rate 这个变量可以限制连接速率。$nginx_version 当前运行的nginx版本号。$query_string 与$args相同。$remote_addr 客户端的IP地址。$remote_port 客户端的端口。$remote_user 已经经过Auth Basic Module验证的用户名。$request_filename 当前连接请求的文件路径，由root或alias指令与URI请求生成。$request_body 这个变量（0.7.58+）包含请求的主要信息。在使用proxy_pass或fastcgi_pass指令的location中比较有意义。$request_body_file 客户端请求主体信息的临时文件名。$request_completion 请求完成$request_method 这个变量是客户端请求的动作，通常为GET或POST。包括0.8.20及之前的版本中，这个变量总为main request中的动作，如果当前请求是一个子请求，并不使用这个当前请求的动作。$request_uri 这个变量等于包含一些客户端请求参数的原始URI，它无法修改，请查看$uri更改或重写URI。$schemeHTTP 方法（如http，https）。按需使用，例：rewrite ^(.+)$ $scheme://example.com$1 redirect;$server_addr 服务器地址，在完成一次系统调用后可以确定这个值，如果要绕开系统调用，则必须在listen中指定地址并且使用bind参数。$server_name 服务器名称。$server_port 请求到达服务器的端口号。$server_protocol 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。$uri 请求中的当前URI(不带请求参数，参数位于$args)，可以不同于浏览器传递的$request_uri的值，它可以通过内部重定向，或者使用index指令进行修改。 参考链接： http://www.wklken.me/posts/2013/11/23/nginx-base.html]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CentOS 6.5安装配置MySQL数据库]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2015%2F05%2F04%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2015-05-04-CentOS6-5%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmysql%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[1.卸载原有数据库 1.1 查询是否安装了数据库 1rpm -qa | grep mysql 1.2卸载mysql数据库 12# 普通删除模式rpm -e mysql or 12# 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除rpm -e --nodeps mysql 1.3 检查是否卸载成功 1rpm -qa | grep mysql 2.mysql安装 2.1 查看可用的mysql版本 1yum list | grep mysql 2.2 更新YUM源 1234# 第一步 在这里http://dev.mysql.com/downloads/repo/yum/选择对应的版本链接# 第二步 更新源sudo rpm -Uvh 你选择的对应的连接 或者对于linux 6 (# wget http://dev.mysql.com/get/mysql57-community-release-el6-7.noarch.rpm # yum localinstall mysql57-community-release-el6-7.noarch.rpm)# 第三步 查看默认的安装状态 yum repolist all | grep mysql# 第四步 禁用和启用 yum-config-manager --disable mysql56-community 和 yum-config-manager --enable mysql57-community-dmr 2.3 安装数据库以及依赖文件 1yum install -y mysql-server mysql mysql-devel 2.4 查看安装mysql的状态 1rpm -qi mysql-server 3.mysql数据库的初始化及相关配置 3.1 启动数据库服务 12345678 service mysqld start``` &gt; * 3.2 设置开启自启动```sh # 检查是否开启自启动 chkconfig --list | grep mysqld and 12# 设置开机自启动chkconfig mysqld on 3.3 为root用户设置密码 12#通过该命令给root账号设置密码为 rootmysqladmin -u root password 'root' or 12# 为root账号设置密码/usr/bin/mysqladmin -u root password 'new-password' 特别说明5.7以后的版本的密码修改策略： 12345# 默认密码在日至文件里面# 第一步 获取默认随机密码 sudo grep 'temporary password' /var/log/mysqld.log# 第二步 登陆 mysql -uroot -p # 第三步 修改密码 ALTER USER 'root'@'localhost' IDENTIFIED BY 'MyNewPass4!'; # 然后给root用户进行权限配置 特别说明 mysql_secure_installation 只有在5.6版本的时候可以用。 4.mysql数据库配置文件说明 4.1 配置文件存放位置 1# 默认存放位置/etc/my.cnf 4.2 配置文件说明 1# 暂时先不写了]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windows64位python注册问题]]></title>
    <url>%2FPython%E5%AD%A6%E4%B9%A0%2F2015%2F04%2F20%2FPython%E5%AD%A6%E4%B9%A0-2015-04-20-windows64%E4%BD%8Dpython%E6%B3%A8%E5%86%8C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Windows 7 64位下安装了 Python 的64位安装包，再安装其他预编译的Library就会有找不到Python的错误。 应该是有些Key没有加入到注册表中，需要运行下面的脚本修正。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152## script to register Python 2.0 or later for use with win32all# and other extensions that require Python registry settings## written by Joakim Loew for Secret Labs AB / PythonWare## source:# http://www.pythonware.com/products/works/articles/regpy20.htm## modified by Valentine Gogichashvili as described in http://www.mail-archive.com/distutils-sig@python.org/msg10512.html import sys from _winreg import * # tweak as necessaryversion = sys.version[:3]installpath = sys.prefix regpath = "SOFTWARE\\Python\\Pythoncore\\%s\\" % (version)installkey = "InstallPath"pythonkey = "PythonPath"pythonpath = "%s;%s\\Lib\\;%s\\DLLs\\" % ( installpath, installpath, installpath) def RegisterPy(): try: reg = OpenKey(HKEY_CURRENT_USER, regpath) except EnvironmentError as e: try: reg = CreateKey(HKEY_CURRENT_USER, regpath) SetValue(reg, installkey, REG_SZ, installpath) SetValue(reg, pythonkey, REG_SZ, pythonpath) CloseKey(reg) except: print "*** Unable to register!" return print "--- Python", version, "is now registered!" return if (QueryValue(reg, installkey) == installpath and QueryValue(reg, pythonkey) == pythonpath): CloseKey(reg) print "=== Python", version, "is already registered!" return CloseKey(reg) print "*** Unable to register!" print "*** You probably have another Python installation!" if __name__ == "__main__": RegisterPy()]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redis配置文件说明]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%2F2015%2F04%2F15%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0-redis%E4%B8%93%E9%A2%98-2015-04-15-redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[redis info 123redis-cliauth 密码info [server] &gt;记录了 Redis 服务器的信息 名字 说明 redis_version redis服务器版本 redis_git_sha1 Git SHA1 redis_git_dirty Git dirty flag os Redis 服务器的宿主操作系统 arch_bits 架构（32 或 64 位） multiplexing_api Redis 所使用的事件处理机制 gcc_version 编译 Redis 时所使用的 GCC 版本 process_id 服务器进程的 PID run_id Redis 服务器的随机标识符（用于 Sentinel 和集群） tcp_port TCP/IP 监听端口 uptime_in_seconds 自 Redis 服务器启动以来，经过的秒数 uptime_in_days 自 Redis 服务器启动以来，经过的天数 lru_clock 以分钟为单位进行自增的时钟，用于 LRU 管理 [clients] &gt;记录了已链接客户端信息 名字 说明 connected_clients 已连接客户端的数量（不包括通过从属服务器连接的客户端） client_longest_output_list 当前连接的客户端当中，最长的输出列表 client_longest_input_buf 当前连接的客户端当中，最大输入缓存 blocked_clients 正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量 [memory] &gt;记录了服务器的内存信息 名字 说明 used_memory 由 Redis 分配器分配的内存总量，以字节（byte）为单位 used_memory_human 以人类可读的格式返回 Redis 分配的内存总量 used_memory_rss 从操作系统的角度，返回 Redis 已分配的内存总量（俗称常驻集大小）。这个值和 top 、 ps 等命令的输出一致 used_memory_peak Redis 的内存消耗峰值（以字节为单位） used_memory_peak_human 以人类可读的格式返回 Redis 的内存消耗峰值 used_memory_lua Lua 引擎所使用的内存大小（以字节为单位） mem_fragmentation_ratio used_memory_rss 和 used_memory 之间的比率 mem_allocator 在编译时指定的， Redis 所使用的内存分配器。可以是 libc 、 jemalloc 或者 tcmalloc [persistence] &gt;记录了跟 RDB 持久化和 AOF 持久化有关的信息 名字 说明 loading 一个标志值，记录了服务器是否正在载入持久化文件 rdb_changes_since_last_save 距离最近一次成功创建持久化文件之后，经过了多少秒 rdb_bgsave_in_progress 一个标志值，记录了服务器是否正在创建 RDB 文件 rdb_last_save_time 最近一次成功创建 RDB 文件的 UNIX 时间戳 rdb_last_bgsave_status 一个标志值，记录了最近一次创建 RDB 文件的结果是成功还是失败 rdb_last_bgsave_time_sec 记录了最近一次创建 RDB 文件耗费的秒数 rdb_current_bgsave_time_sec 如果服务器正在创建 RDB 文件，那么这个域记录的就是当前的创建操作已经耗费的秒数 aof_enabled 一个标志值，记录了 AOF 是否处于打开状态 aof_rewrite_in_progress 一个标志值，记录了服务器是否正在创建 AOF 文件 aof_rewrite_scheduled 一个标志值，记录了在 RDB 文件创建完毕之后，是否需要执行预约的 AOF 重写操作 aof_last_rewrite_time_sec 最近一次创建 AOF 文件耗费的时长 aof_current_rewrite_time_sec 如果服务器正在创建 AOF 文件，那么这个域记录的就是当前的创建操作已经耗费的秒数 aof_last_bgrewrite_status 一个标志值，记录了最近一次创建 AOF 文件的结果是成功还是失 aof_current_size AOF 持久化功能处于开启状态–AOF 文件目前的大小 aof_base_size AOF 持久化功能处于开启状态–服务器启动时或者 AOF 重写最近一次执行之后，AOF 文件的大小 aof_pending_rewrite AOF 持久化功能处于开启状态–一个标志值，记录了是否有 AOF 重写操作在等待 RDB 文件创建完毕之后执行 aof_buffer_length AOF 持久化功能处于开启状态–AOF 缓冲区的大小 aof_rewrite_buffer_length AOF 持久化功能处于开启状态–AOF 重写缓冲区的大小 aof_pending_bio_fsync AOF 持久化功能处于开启状态–后台 I/O 队列里面，等待执行的 fsync 调用数量 aof_delayed_fsync AOF 持久化功能处于开启状态–被延迟的 fsync 调用数量 [stats] &gt;记录了一般统计信息 名字 说明 total_connections_received 服务器已接受的连接请求数量 total_commands_processed 服务器已执行的命令数量 instantaneous_ops_per_sec 服务器每秒钟执行的命令数量 rejected_connections 因为最大客户端数量限制而被拒绝的连接请求数量 expired_keys 因为过期而被自动删除的数据库键数量 evicted_keys 因为最大内存容量限制而被驱逐（evict）的键数量 keyspace_hits 查找数据库键成功的次数 keyspace_misses 查找数据库键失败的次数 pubsub_channels 目前被订阅的频道数量 pubsub_patterns 目前被订阅的模式数量 latest_fork_usec 最近一次 fork() 操作耗费的毫秒数 [replication] &gt;主/从复制信息 名字 说明 role 如果当前服务器没有在复制任何其他服务器，那么这个域的值就是 master ；否则的话，这个域的值就是 slave 。注意，在创建复制链的时候，一个从服务器也可能是另一个服务器的主服务器 ter_host 从服务器—主服务器的 IP 地址 master_port 从服务器—主服务器的 TCP 监听端口号 master_link_status 从服务器—复制连接当前的状态， up 表示连接正常， down 表示连接断开 master_last_io_seconds_ago 从服务器—距离最近一次与主服务器进行通信已经过去了多少秒钟 master_sync_in_progress 从服务器—一个标志值，记录了主服务器是否正在与这个从服务器进行同步 master_sync_left_bytes 同步操作正在进行—距离同步完成还缺少多少字节数据 master_sync_last_io_seconds_ago 同步操作正在进行—距离最近一次因为 SYNC 操作而进行 I/O 已经过去了多少秒 master_link_down_since_seconds 断线状态—主从服务器连接断开了多少秒 connected_slaves 已连接的从服务器数量 [cpu] &gt;计算量统计信息 名字 说明 used_cpu_sys Redis 服务器耗费的系统 CPU used_cpu_user Redis 服务器耗费的用户 CPU used_cpu_sys_children 后台进程耗费的系统 CPU used_cpu_user_children 后台进程耗费的用户 CPU [keyspace] &gt;记录了数据库相关的统计信息，比如数据库的键数量、数据库已经被删除的过期键数量等]]></content>
      <categories>
        <category>数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[刀刀亮的书单]]></title>
    <url>%2F%E5%88%80%E5%88%80%E7%88%B1%E5%AD%A6%E4%B9%A0%2F2015%2F04%2F05%2F%E5%88%80%E5%88%80%E7%88%B1%E5%AD%A6%E4%B9%A0-2015-04-05-%E5%88%80%E5%88%80%E4%BA%AE%E7%9A%84%E4%B9%A6%E5%8D%95%2F</url>
    <content type="text"><![CDATA[1.《深入理解计算机系统》 2.《代码整洁之道》 3.《高性能MySql》]]></content>
      <categories>
        <category>刀刀爱学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redis常用命令总结]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%2F2015%2F04%2F02%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0-redis%E4%B8%93%E9%A2%98-2015-04-02-redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[系统类命令： quit：关闭连接（connection） auth：简单密码认证 save：将数据同步保存到磁盘 bgsave：将数据异步保存到磁盘 lastsave：返回上次成功将数据保存到磁盘的Unix时戳 shundown：将数据同步保存到磁盘，然后关闭服务 info：提供服务器的信息和统计 monitor：实时转储收到的请求 slaveof：改变复制策略设置 config：在运行时配置Redis服务器 对key操作的命令： exists(key)：确认一个key是否存在 del(key)：删除一个key type(key)：返回值的类型 keys(pattern)：返回满足给定pattern的所有key randomkey：随机返回key空间的一个 keyrename(oldname, newname)：重命名key dbsize：返回当前数据库中key的数目 expire：设定一个key的活动时间（s） ttl：获得一个key的活动时间 select(index)：按索引查询 move(key, dbindex)：移动当前数据库中的key到dbindex数据库 flushdb：删除当前选择数据库中的所有key flushall：删除所有数据库中的所有key 对string操作的命令： set(key, value)：给数据库中名称为key的string赋予值value get(key)：返回数据库中名称为key的string的value getset(key, value)：给名称为key的string赋予上一次的value mget(key1, key2,…, key N)：返回库中多个string的value setnx(key, value)：添加string，名称为key，值为value setex(key, time, value)：向库中添加string，设定过期时间time mset(key N, value N)：批量设置多个string的值 msetnx(key N, value N)：如果所有名称为key i的string都不存在 incr(key)：名称为key的string增1操作 incrby(key, integer)：名称为key的string增加integer decr(key)：名称为key的string减1操作 decrby(key, integer)：名称为key的string减少integer append(key, value)：名称为key的string的值附加value substr(key, start, end)：返回名称为key的string的value的子串 对List操作的命令： rpush(key, value)：在名称为key的list尾添加一个值为value的元素 lpush(key, value)：在名称为key的list头添加一个值为value的 元素 llen(key)：返回名称为key的list的长度 lrange(key, start, end)：返回名称为key的list中start至end之间的元素 ltrim(key, start, end)：截取名称为key的list lindex(key, index)：返回名称为key的list中index位置的元素 lset(key, index, value)：给名称为key的list中index位置的元素赋值 lrem(key, count, value)：删除count个key的list中值为value的元素 lpop(key)：返回并删除名称为key的list中的首元素 rpop(key)：返回并删除名称为key的list中的尾元素 blpop(key1, key2,… key N, timeout)：lpop命令的block版本。 brpop(key1, key2,… key N, timeout)：rpop的block版本。 rpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部 对Set操作的命令： sadd(key, member)：向名称为key的set中添加元素member srem(key, member) ：删除名称为key的set中的元素member spop(key) ：随机返回并删除名称为key的set中一个元素 smove(srckey, dstkey, member) ：移到集合元素 scard(key) ：返回名称为key的set的基数 sismember(key, member) ：member是否是名称为key的set的元素 sinter(key1, key2,…key N) ：求交集 sinterstore(dstkey, (keys)) ：求交集并将交集保存到dstkey的集合 sunion(key1, (keys)) ：求并集 sunionstore(dstkey, (keys)) ：求并集并将并集保存到dstkey的集合 sdiff(key1, (keys))：求差集 sdiffstore(dstkey, (keys)) ：求差集并将差集保存到dstkey的集合 smembers(key) ：返回名称为key的set的所有元素 srandmember(key) ：随机返回名称为key的set的一个元素 对Hash操作的命令： hset(key, field, value)：向名称为key的hash中添加元素field hget(key, field)：返回名称为key的hash中field对应的value hmget(key, (fields))：返回名称为key的hash中field i对应的value hmset(key, (fields))：向名称为key的hash中添加元素field hincrby(key, field, integer)：将名称为key的hash中field的value增加integer hexists(key, field)：名称为key的hash中是否存在键为field的域 hdel(key, field)：删除名称为key的hash中键为field的域 hlen(key)：返回名称为key的hash中元素个数 hkeys(key)：返回名称为key的hash中所有键 hvals(key)：返回名称为key的hash中所有键对应的value hgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value]]></content>
      <categories>
        <category>数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql远程表链接]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%2F2015%2F04%2F02%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0-mysql%E4%B8%93%E9%A2%98-2015-04-02-mysql%E8%BF%9C%E7%A8%8B%E8%A1%A8%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[FEDERATED简介FEDERATED存储引擎是访问远程数据库中的表，在平时开发中可以用此特性来访问远程库中的参数表之类的，还是非常方便的。使用时直接在本地构建一个federated表来链接远程数据表，配置好之后本地数据库可以直接和远程数据表进行同步，实际上这个数据库并不是真实存放数据，所需要的数据都是存放在远程服务器上。 配置条件 mysql版本需要5.1以上； 在安装是需要把federated引擎已经安装; 配置步骤 1.开启federated引擎； 在mysql终端执行: 1show engines; 若是引擎关闭则需要配置开启，方式如下； 修改mysql的配置文件： &gt;在my.ini中[mysqld]标签下下直接加上一行 federated重启数据库服务即可 2.建立远程表连接 12345CREATE TABLE table_test ( id BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT, name varchar(255) not null, PRIMARY KEY (`id`) ) ENGINE=FEDERATED DEFAULT CHARSET=utf8 CONNECTION='mysql://root:abc@192.168.88.16:3306/dbname/tablename' 注意 1.本地的表结构必须与远程的完全一样。 2.远程数据库目前仅限MySQL 3.不支持事务 4.不支持表结构修改]]></content>
      <categories>
        <category>数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下redis环境搭建]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2015%2F03%2F24%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2015-03-24-ubuntu%E4%B8%8Bredis%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[ubuntu下redis环境搭建1. 下载安装1wget http://download.redis.io/redis-stable.tar.gz 然后 12345sudo tar -zxvf redis-stable.tar.gzcd redis-stablesudo makesudo make testsudo make install 通常在make test时发现以下错误： 12You need tcl 8.5 or newer in order to run the Redis testmake: *** [test] Error 1 则需要安装tcl 参考这个网址 2. 创建redis文件夹12sudo mkdir /etc/redissudo mkdir /var/redis 3. 复制修改启动脚本 将启动脚本复制到/etc/init.d目录下 1sudo cp utils/redis_init_script /etc/init.d/redis_6379 修改启动脚本 1sudo vim /etc/init.d/redis_6379 修改其中的REDIS_PORT为自己需要的端口，同时在脚本顶部加上： 12#chkconfig: 2345 80 90#description:auto_run 以确保服务支持chkconfig 4. 创建redis的工作目录1sudo mkdir /var/redis/6379 5. 修改配置文件 将redis的配置文件拷贝到/etc/redis目录下，并修改或确认参数 1234567sudo cp redis.conf /etc/redis/6379.conf#设置daemonize为true#设置pidfile为/var/run/redis_6379.pid#设置loglevel#设置logfile为/var/log/redis_6379.log#设置dir为/var/redis/6379# requirepass foobared去掉注释，foobared改为自己的密码 6. 设置启动脚本1/sbin/chkconfig --add redis_6379 &amp;&amp; /sbin/chkconfig redis_6379 on 7. 启动redis1sudo /etc/init.d/redis_6379 start 8. 开启防火墙的6379端口1这里就不在赘述了，前面的博客有写的～～]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux下mysql定时备份]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%2F2015%2F03%2F24%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0-mysql%E4%B8%93%E9%A2%98-2015-03-24-linux%E4%B8%8B%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BDmysql%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[1. 在服务器上建立备份文件的存放文件夹1sudo mkdir /usr/local/dbbackup 2. 编写备份脚本1vi dbbackup.sh 在里面编写如下内容 12345mysqldump -uroot -p1W8a6N0g1Y3i3F1a1N99 cusflo | gzip &gt; /usr/local/cusflo-dbback/cusflo`date +%Y-%m-%d_%H%M%S`.sql.gzcd /usr/local/cusflo-dbback/rm -rf `find . -name &apos;*.sql.gz&apos; -mtime 30` 3.更改备份脚本权限1sudo chmod +x dbbackup.sh 4.修改crontab定时执行脚本1crontab -e 若每天晚上23点30备份，添加如下代码:130 23 * * * /usr/local/dbbackscripts/dbbackup.sh]]></content>
      <categories>
        <category>数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[gcc常见编译错误以及解决方案]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2015%2F03%2F23%2Flinux%E5%AD%A6%E4%B9%A0-2015-03-23-gcc%E5%B8%B8%E8%A7%81%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[1. gcc: error trying to exec ‘cc1plus’: execvp: 没有那个文件或目录 该错误原因一般为没有安装g++或者g++版本和Gcc版本不统一所致，解决方案如下： 更新软件版本并安装g++ 12sudo apt-get install gcc-c++sudo apt-get update 2. configure: error: You need a C++ compiler for C++ support. 该错误是在centos6.5进行构建某个包的源码时报错，解决方案如下： 安装gcc和个g++ 1yum install -y gcc gcc-c++]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux服务器监控psdash配置]]></title>
    <url>%2FPython%E5%AD%A6%E4%B9%A0%2F2015%2F03%2F21%2FPython%E5%AD%A6%E4%B9%A0-2015-03-21-linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%91%E6%8E%A7psdash%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[psdash是一款linux下的系统资源监控的web版本，和其相似的还有linux-dash. 1.安装前的环境准备 安装python,我用的环境是python 2. 7. 9 12sudo apt-get install python-pipsudo pip install python-dev 2.安装psdash 可以直接用pip进行安装 1sudo pip install psdash 或者用安装脚本 123sudo git clone https://github.com/daodaoliang/psdash.gitsudo cd psdashsudo python setup.py install 也可以直接启用python 123sudo git clone https://github.com/daodaoliang/psdash.gitsudo cd psdashsudo python ./psdash/run.py 3. 启动测试 直接测试 1sudo psdash -p 5000 -l '/var/log/*.log' 打开浏览器进行测试 1http://127.0.0.1:5000]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SSH免密码登陆]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2015%2F03%2F19%2Flinux%E5%AD%A6%E4%B9%A0-2015-03-19-%E4%BD%BF%E7%94%A8SSH%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[前期准备 Server端需要安装并开启SSH服务 Client端需要支持ssh-keygen命令 确认两台机器能够连接到Internet 1. 检测SSH安装是否成功 1ssh -V 若是不成功显示版本信息则需要按照平台的不同进行相关的SSH的安装。 2. Client端产生密钥对 在Client端执行 1ssh-keygen 执行过程中，它先要求你确认保存公钥的位置（默认为：.ssh/id_rsa），然后它会让你重复输入一个密码两次，如果不想在使用公钥的时候输入密码，可以留空，执行完毕后，就会生成数据Client端的一对密钥。 查看Client端的用户目录下～/.ssh，看有没有用 xxx_rsa 和 xxx_rsa.pub 来命名的一对文件，有 .pub 后缀的文件就是公钥，另一个文件则是密钥。 公钥是公开的，不需要保密，而私钥是由个人自己持有，并且必须妥善保管和注意保密。 3. 将Client生成的公钥复制到Server端 登陆到Server端查阅 ~/.ssh目录下是否有authorized_keys文件。 若是没有创建它 1touch authorized_keys 将复制到的Client端公钥内容，粘贴至Server端刚才创建的 authorized_keys 文件中，保存文件。 更改 authorized_keys 文件的权限 1chmod 600 authorized_keys 3. 验证无密码登陆 在Client端命令行执行如下命令： 1ssh root@114.113.158.119 直接登陆至Server端，表示验证成功。 4. 注意事项 ssh-keygen执行完毕后一定要检查下phenix用户家目录下.ssh目录中是否有一对密钥 在将公钥粘贴至Server端后，一定要修改authorized_keys文件的权限为600，否则认证会失败 Server端需要开启SSH服务，不然客户端使用ssh连接不上]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[少年行]]></title>
    <url>%2F%E5%BF%83%E4%B8%96%E7%95%8C%2F2015%2F02%2F10%2F%E6%96%B0%E4%B8%96%E7%95%8C-2015-02-10-%E5%B0%91%E5%B9%B4%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[###少年行 其一 12新丰美酒斗十千，咸阳游侠多少年。相逢意气为君饮，系马高楼垂柳边。 其二 12出身仕汉羽林郎，初随骠骑战渔阳。孰知不向边庭苦，纵死犹闻侠骨香。 其三 12一身能擘两雕弧，虏骑千重只似无。偏坐金鞍调白羽，纷纷射杀五单于。 其四 12汉家君臣欢宴终，高议云台论战功。天子临轩赐侯印，将军佩出明光宫。]]></content>
      <categories>
        <category>心世界</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux安装脚本]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2015%2F02%2F05%2Flinux%E5%AD%A6%E4%B9%A0-2015-02-05-%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#!/bin/bash# user can config the following configs, then package.INSTALL=/usr/local/cusflo-serverok_msg() &#123; echo -e "$&#123;1&#125;$&#123;POS&#125;$&#123;BLACK&#125;[$&#123;GREEN&#125; OK $&#123;BLACK&#125;]"&#125;failed_msg() &#123; echo -e "$&#123;1&#125;$&#123;POS&#125;$&#123;BLACK&#125;[$&#123;RED&#125;FAILED$&#123;BLACK&#125;]"&#125;# discover the current work dir, the log and access.echo "argv[0]=$0"if [[ ! -f $0 ]]; then echo "directly execute the scripts on shell."; work_dir=`pwd`else echo "execute scripts in file: $0"; work_dir=`dirname $0`; work_dir=`(cd $&#123;work_dir&#125; &amp;&amp; pwd)`fiproduct_dir=$work_dir# user must stop service first.ok_msg "check previous install"if [[ -f /etc/init.d/cusflo-server-moon ]]; then /etc/init.d/cusflo-server-moon status &gt;/dev/null 2&gt;&amp;1 ret=$?; if [[ 0 -eq $&#123;ret&#125; ]]; then failed_msg "you must stop the service first: sudo /etc/init.d/cusflo-server-moon stop"; exit 1; fifiok_msg "previous install checked"# backup old srsok_msg "backup old cusflo-server-moon"install_root=$INSTALLinstall_bin=$install_root/if [[ -d $install_root ]]; then backup_dir=$&#123;install_root&#125;.`date "+%Y-%m-%d_%H-%M-%S"` ok_msg "backup installed dir" ok_msg " to=$backup_dir" mv $install_root $backup_dir 2&gt;&amp;1 ret=$?; if [[ 0 -ne $&#123;ret&#125; ]]; then failed_msg "backup installed dir failed"; exit $ret; fi ok_msg "backup installed dir success"fiok_msg "old srs backuped"# copy core filesok_msg "copy core components"( mkdir -p $install_root cp -r $work_dir/conf $install_root &amp;&amp; cp -r $work_dir/dog $install_root &amp;&amp; cp -r $work_dir/log $install_root &amp;&amp; cp -r $work_dir/moon $install_root &amp;&amp; cp -r $work_dir/scripts $install_root) 2&gt;&amp;1ret=$?; if [[ 0 -ne $&#123;ret&#125; ]]; then failed_msg "copy core components failed"; exit $ret; fiok_msg "copy core components success"# install init.d scriptsok_msg "install init.d scripts"( rm -rf /etc/init.d/cusflo-server-moon &amp;&amp; ln -sf $install_root/scripts/cusflo-server-moon /etc/init.d/cusflo-server-moon) 2&gt;&amp;1ret=$?; if [[ 0 -ne $&#123;ret&#125; ]]; then failed_msg "install init.d scripts failed"; exit $ret; fiok_msg "install init.d scripts success"# install system servicelsb_release --id|grep "CentOS" &gt;/dev/null 2&gt;&amp;1; os_id_centos=$?lsb_release --id|grep "Ubuntu" &gt;/dev/null 2&gt;&amp;1; os_id_ubuntu=$?lsb_release --id|grep "Debian" &gt;/dev/null 2&gt;&amp;1; os_id_debian=$?lsb_release --id|grep "Raspbian" &gt;/dev/null 2&gt;&amp;1; os_id_rasabian=$?if [[ 0 -eq $os_id_centos ]]; then ok_msg "install system service for CentOS" /sbin/chkconfig --add cusflo-server-moon &amp;&amp; /sbin/chkconfig cusflo-server-moon on ret=$?; if [[ 0 -ne $&#123;ret&#125; ]]; then failed_msg "install system service failed"; exit $ret; fi ok_msg "install system service success"elif [[ 0 -eq $os_id_ubuntu ]]; then ok_msg "install system service for Ubuntu" update-rc.d cusflo-server-moon defaults ret=$?; if [[ 0 -ne $&#123;ret&#125; ]]; then failed_msg "install system service failed"; exit $ret; fi ok_msg "install system service success"elif [[ 0 -eq $os_id_debian ]]; then ok_msg "install system service for Debian" update-rc.d cusflo-server-moon defaults ret=$?; if [[ 0 -ne $&#123;ret&#125; ]]; then failed_msg "install system service failed"; exit $ret; fi ok_msg "install system service success"elif [[ 0 -eq $os_id_rasabian ]]; then ok_msg "install system service for RaspberryPi" update-rc.d cusflo-server-moon defaults ret=$?; if [[ 0 -ne $&#123;ret&#125; ]]; then failed_msg "install system service failed"; exit $ret; fi ok_msg "install system service success"else warn_msg "ignore and donot install system service for `lsb_release --id|awk '&#123;print $3&#125;'`."fiecho ""echo "install success, you can:"echo -e "$&#123;GREEN&#125; sudo ./moon/scripts/cusflo-server-moon start$&#123;BLACK&#125;"echo "cusflo-server-moon root is $&#123;INSTALL&#125;"exit 0]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux服务脚本编写]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2015%2F02%2F04%2Flinux%E5%AD%A6%E4%B9%A0-2015-02-04-%E6%9C%8D%E5%8A%A1%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#!/bin/bash### BEGIN INIT INFO# Provides: 应用程序开发者# RequiRED-Start: $all# RequiRED-Stop: $all# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: 简短应用程序描述# Description: 详细应用程序描述### END INIT INFO# 程序文件目录ROOT="/work/code/cusflo-server-moon"# 程序文件APP="./dog/client_update_dog.py"# 程序配置文件CONFIG="./server_config.ini"# 服务日志DEFAULT_LOG_FILE='./daodaoliang.log'# 样式定制RED="\\e[31m"GREEN="\\e[32m"YELLOW="\\e[33m"BLACK="\\e[0m"POS="\\e[60G"ok_msg() &#123; echo -e "$&#123;1&#125;$&#123;POS&#125;$&#123;BLACK&#125;[$&#123;GREEN&#125; OK $&#123;BLACK&#125;]"&#125;failed_msg() &#123; echo -e "$&#123;1&#125;$&#123;POS&#125;$&#123;BLACK&#125;[$&#123;RED&#125;FAILED$&#123;BLACK&#125;]"&#125;# load process info of app# exist return 0# no exist return 1load_process_info() &#123; # get pid app_pid=$(ps -ef|grep $&#123;APP&#125;|gawk '$0 !~/grep/ &#123;print $2&#125;' |tr -s '\n' ' ') # check pid again ps -p $&#123;app_pid&#125; &gt;/dev/null 2&gt;/dev/null ret=$?; if [[ 0 -ne $ret ]]; then error_msg="process $app_pid does not exists"; return 1; fi return 0;&#125;start() &#123; # if exists, exit. load_process_info if [[ 0 -eq $? ]]; then failed_msg "$&#123;APP&#125; started(pid $&#123;app_pid&#125;), should not start it again."; return 0; fi # not exists, start server ok_msg "Starting $&#123;APP&#125;..." # get log file log_file=`cd $&#123;ROOT&#125; &amp;&amp; cat $&#123;CONFIG&#125; |grep '^log_file'| awk '&#123;print $2&#125;'| awk -F ';' '&#123;print $1&#125;'` if [[ -z $log_file ]]; then log_file=$&#123;DEFAULT_LOG_FILE&#125;; fi # get abs path log_dir=`dirname $log_file` log_file=`(cd $&#123;ROOT&#125; &amp;&amp; cd $log_dir &amp;&amp; pwd)`/`basename $log_file` # TODO: FIXME: set limit by, for instance, "ulimit -HSn 10000" if [[ -z $log_file ]]; then (cd $&#123;ROOT&#125;;nohup python $&#123;APP&#125; &gt;/dev/null 2&gt;&amp;1 &amp;) else (cd $&#123;ROOT&#125;;nohup python $&#123;APP&#125; &gt;/dev.null &gt;&gt; $log_file 2&gt;&amp;1 &amp;) fi # check again after start server for ((i = 0; i &lt; 5; i++)); do # sleep a little while, for app may start then crash. sleep 0.1 load_process_info ret=$?; if [[ 0 -ne $ret ]]; then failed_msg "$&#123;APP&#125; start failed"; failed_msg "see $log_file"; return $ret; fi done # check whether started. load_process_info ret=$?; if [[ 0 -eq $? ]]; then ok_msg "$&#123;APP&#125; started(pid $&#123;app_pid&#125;)"; return 0; fi failed_msg "$&#123;APP&#125; not started" return $ret&#125;stop() &#123; # not start, exit load_process_info if [[ 0 -ne $? ]]; then failed_msg "$&#123;APP&#125; not start."; return 0; fi ok_msg "Stopping $&#123;APP&#125;(pid $&#123;app_pid&#125;)..." # process exists, try to kill to stop normally for((i=0;i&lt;30;i++)); do load_process_info if [[ 0 -eq $? ]]; then kill -s SIGTERM $&#123;app_pid&#125; 2&gt;/dev/null ret=$?; if [[ 0 -ne $ret ]]; then failed_msg "send signal SIGTERM failed ret=$ret"; return $ret; fi sleep 0.1 else ok_msg "$&#123;APP&#125; stopped by SIGTERM" # delete the pid file when stop success. rm -f $&#123;pid_file&#125; break; fi done # process exists, use kill -9 to force to exit load_process_info if [[ 0 -eq $? ]]; then kill -s SIGKILL $&#123;app_pid&#125; 2&gt;/dev/null ret=$?; if [[ 0 -ne $ret ]]; then failed_msg "send signal SIGKILL failed ret=$ret"; return $ret; fi ok_msg "$&#123;APP&#125; stopped by SIGKILL" else # delete the pid file when stop success. rm -f $&#123;pid_file&#125; fi sleep 0.1 return 0&#125;# get the status of srs process# @return 0 if srs is running; otherwise, 1 for stopped.status() &#123; load_process_info ret=$?; if [[ 0 -eq $ret ]]; then echo "$&#123;APP&#125;(pid $&#123;app_pid&#125;) is running."; return 0; fi echo "$&#123;APP&#125; is stopped, $error_msg" return 1&#125;menu() &#123; case "$1" in start) start ;; stop) stop ;; restart) stop start ;; status) status ;; *) echo "Usage: $0 &#123;start|stop|status|restart&#125;" return 1 ;; esac&#125;menu $1code=$?exit $&#123;code&#125;]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python包管理]]></title>
    <url>%2FPython%E5%AD%A6%E4%B9%A0%2F2015%2F02%2F04%2FPython%E5%AD%A6%E4%B9%A0-2015-02-04-python%E7%AE%A1%E7%90%86%E5%8C%85%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[安装setuptoolslpython中的easy_install工具，类似于Php中的pear，或者Ruby中的gem，或者Perl中的cpan 12wget -q http://peak.telecommunity.com/dist/ez_setup.pypython ez_setup.py 或者 1apt-get install python-setuptools 安装pip1easy_install pip 或者 1sudo apt-get python-pip 或者 12wget https://bootstrap.pypa.io/get-pip.py --no-check-certificatepython get-pip.py]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Simple-RTMP-Server 服务器搭建]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2015%2F02%2F03%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2015-02-02-SRS%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Simple-RTMP-Server 服务器搭建1. 服务器镜像获取 github源码地址 1git clone https://github.com/winlinvip/simple-rtmp-server.git CSDN镜像地址 1git clone https://code.csdn.net/winlinvip/srs-csdn.git OSChina镜像 1git clone https://git.oschina.net/winlinvip/srs.oschina.git 2. 关闭防火墙和selinux或者开放端口 关闭防火墙 123# disable the firewallsudo /etc/init.d/iptables stopsudo /sbin/chkconfig iptables off 使selinux失败 编辑配置文件：sudo vi /etc/sysconfig/selinux 把SELINUX的值改为disabled：SELINUX=disabled 重启系统：sudo init 6 3. 编译系统1./configure --disable-all --with-ssl --with-hls --with-nginx --with-ffmpeg --with-transcode 1make &amp;&amp; sudo make install 安装命令会将SRS默认安装到/usr/local/srs中，可以在configure时指定其他目录，譬如./configure --prefix=pwd/_release 可以安装到当前的_release目录(可以不用sudo安装，直接用make install即可安装) 4. 建立启动服务4.1 建立软连接 1sudo ln -sf /usr/local/srs/etc/init.d/srs /etc/init.d/srs 备注：若SRS安装到其他目录，将/usr/local/srs替换成其他目录。 备注：也可以使用其他的名称，譬如/etc/init.d/srs，可以任意名称，启动时也用该名称。 4.2 添加服务 12#centos 6sudo /sbin/chkconfig --add srs 或者 12#ubuntu12sudo update-rc.d srs defaults 4.3 使用init.d脚本管理SRS 查看SRS状态： 1/etc/init.d/srs status 启动SRS： 1/etc/init.d/srs start 停止SRS： 1/etc/init.d/srs stop 重启SRS： 1/etc/init.d/srs restart Reload SRS： 1/etc/init.d/srs reload 5. 启动分发hls（m3u8/ts）的nginx1sudo ./objs/nginx/sbin/nginx 6. 编写SRS配置文件将以下内容保存为文件，譬如conf/transcode2hls.audio.only.conf，服务器启动时指定该配置文件(srs的conf文件夹有该文件)。 1234567891011121314151617181920212223242526272829303132333435363738# conf/transcode2hls.audio.only.conflisten 1935;max_connections 1000;http_stream &#123; # whether http streaming service is enabled. # default: off enabled on; # the http streaming port # @remark, if use lower port, for instance 80, user must start srs by root. # default: 8080 listen 8080; # the default dir for http root. # default: ./objs/nginx/html dir ./objs/nginx/html;&#125;vhost __defaultVhost__ &#123; hls &#123; enabled on; hls_path ./objs/nginx/html; hls_fragment 10; hls_window 60; &#125; transcode &#123; enabled on; ffmpeg ./objs/ffmpeg/bin/ffmpeg; engine ff &#123; enabled on; vcodec copy; acodec libaacplus; abitrate 45; asample_rate 44100; achannels 2; aparams &#123; &#125; output rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine]; &#125; &#125;&#125; 备注：这个配置使用只转码音频，因为视频是h.264符合要求 7. 启动SRS1./objs/srs -c conf/transcode2hls.audio.only.conf 或者使用服务进行启动 8. 启动推流编码器使用FFMPEG命令推流： 123456for((;;)); do \ ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.200kbps.768x320.flv \ -vcodec copy -acodec copy \ -f flv -y rtmp://192.168.1.170/live/livestream; \ sleep 1; \done 或使用FMLE推流： 12FMS URL: rtmp://192.168.1.170/liveStream: livestream 生成的流地址为： RTMP流地址为（FMLE推流无HLS地址）：rtmp://192.168.1.170/live/livestream 转码后的RTMP流地址为：rtmp://192.168.1.170/live/livestream_ff 转码后的HLS流地址为： http://192.168.1.170/live/livestream_ff.m3u8 备注：因为FMLE推上来的音频有问题，不是aac，所以srs会报错（当然啦，不然就不用转码了）。这个错误可以忽略，srs是说，rtmp流没有问题，但是无法切片为hls，因为音频编码不对。没有关系，ffmpeg会转码后重新推一路流给srs。 备注：如何只对符合要求的流切hls？可以用vhost。默认的vhost不切hls，将转码后的流推送到另外一个vhost，这个vhost切hls。 9. 观看RTMP流 RTMP流地址为：rtmp://192.168.1.170/live/livestream_ff 播放器:VLC 或者： http://winlinvip.github.io/srs.release/trunk/research/players/srs_player.html?vhost=defaultVhost&amp;autostart=true&amp;server=192.168.1.170&amp;app=live&amp;stream=livestream_ff HLS流地址为： http://192.168.1.170/live/livestream_ff.m3u8 播放器VLC 或者 http://winlinvip.github.io/srs.release/trunk/research/players/jwplayer6.html?vhost=defaultVhost&amp;hls_autostart=true&amp;server=192.168.1.170&amp;app=live&amp;stream=livestream_ff 10. 手机端查看10.1 Android 12345&lt;video width="640" height="360" autoplay controls autobuffer src="http://127.0.0.1/live/livestream.m3u8" type="application/vnd.apple.mpegurl"&gt;&lt;/video&gt; 10.2 IOS 1http://127.0.0.1/live/livestream.m3u8]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux下ffmpeg安装与开发配置]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2015%2F02%2F03%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2015-02-03-Linux%E4%B8%8Bffmpeg%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[ffmpeg安装删除已安装的文件，避免冲突 12sudo apt-get remove ffmpeg x264sudo apt-get autoremove 安装需要的支持 1sudo apt-get install make automake g++ bzip2 python unzip patch subversion ruby build-essential git-core checkinstall yasm texi2html libfaac-dev libmp3lame-dev libopencore-amrnb-dev libopencore-amrwb-dev libsdl1.2-dev libtheora-dev libvdpau-dev libvorbis-dev libvpx-dev libx11-dev libxfixes-dev libxvidcore-dev zlib1g-dev 安装 x264 （自己选择是否安装） x264 依赖于yasm，而且版本较高。 123456sudo git clone git://git.videolan.org/x264.gitcd x264sudo ./configure --enable-shared --prefix=/usr/localsudo makesudo make installcd .. 安装FFMPEG 123sudo wget http://ffmpeg.org/releases/ffmpeg-2.5.3.tar.bz2sudo tar xvjf ffmpeg-2.5.3.tar.bz2cd ffmpeg-2.5.3 1./configure --enable-gpl --enable-version3 --enable-nonfree --enable-postproc --enable-libfaac --enable-libmp3lame --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-libtheora --enable-libvorbis --enable-libvpx --enable-libx264 --enable-libxvid --enable-shared --prefix=/usr/local 123sudo makesudo make installcd .. configure过程根据自己的情况开启某部分功能。 常见错误 1ffmpeg: error while loading shared libraries: libavdevice.so.53: cannot open shared object file: No such file or directory 解决办法： 123vi /etc/ld.so.conf加入：/usr/local/lib执行ldconfig]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[P2P的NAT穿越方案]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F2015%2F02%2F02%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-NAT%E4%B8%93%E9%A2%98-2015-02-01-p2p%E7%9A%84NAT%E7%A9%BF%E8%B6%8A%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[NAT专题之P2P的NAT穿越方案1.P2P简介&gt;P2P即点对点通信，或称为对等联网，与传统的服务器客户端模式有着明显的区别，传统的服务器客户端模型如图2所示。P2P这一术语在不同的上下文环境里可能有不同的内涵，它可以指一种通信模式、一种逻辑网络模型、一种技术、甚至一种理念。在P2P网络中如图1所示，所有通信节点的地位都是对等的，每个节点都扮演着客户机和服务器双重角色，节点之间通过直接通信实现文件信息、处理器运算能力、存储空间等资源的共享。P2P网络具有分散性、可扩展性、健壮性等特点，这使得P2P技术在信息共享、实时通信、协同工作、分布式计算、网络存储等领域都有广阔的应用; 图1 P2P结构模型 图2 CS模式 2.NAT简介目前,IPV4地址资源的紧缺使得NAT技术获得了广泛的应用，NAT技术是一种把内部网络(简称内网)私有IP地址转换为外部网络(简称为外网)公共IP地址的技术，它使得一定范围内的多台主机志李永一个公共IP地址链接到外网，可以在很大成都上缓解公网IP地址紧缺的问题。 3.NAT对P2P通信的影响NAT技术虽然在一定成都上解决了IPV4地址短缺的问题，在构建防火墙，保证网络安全方面都发挥了一定的作用，却破坏了端到段的网络通信，NAT阻碍朱姐进行p2p通信的主要原因时NAT不允许外网主机主动访问内网诸暨，因为NAT设备上没有先关转发表项，要在NAT网络环境中进行有效的p2p通信，就必须寻找相应的解决方案，本文就着重介绍几种常见的解决方案。 4.p2p穿越NAT的几种方案4.1 反向链接技术 当通信双方中一方位于NAT之后时，他们可以利用反向链接技术来进行p2p通信，图中的clientA(拥有内网地址10.0.0.1)位于NAT之后，它通过TCP端口1234连接到服务器(拥有外网IP地址)的TCP端口1235上,NAT设备(拥有外网地址:155.99.25.11)味这个链接重新分配了TCP端口62000，clientB(拥有外网IP地址138.76.29.7)叶通过TCP端口1234连接到服务器1235上，clientA和clientB从服务器除货值的对网的外网地址二元组{IP地址:端口号}分别为{138.76.29.7:1234}和{155.99.25.11:62000}.他们在各自的本地端口上进行侦听。 由于clientB拥有外网IP地址，所以clientA可以直接通过TCP发起与clientB的链接，但如果clientB尝试通过TCP链接到clientA进行P2P通信，则会失败，原因是clientA位于NAT设备后，虽然clientB发出的TCP SYN请求能够到达NAT设备的端口62000，但NAT设备会拒绝这个链接请求，要想与clientA通信，clientB要通过服务器给clientA转发一个链接请求，反过来请求clientA连接到clientB(即进行反向链接),从而建立起他们之间的TCP链接。 4.2 UDP打洞技术 如果两个客户端窦唯与NAT设备后面，想要进行P2P通信，那又该如何解决呢?UDP打洞技术就是为解决这个问题应运而生的，它能够通过中间服务器实现P2P客户端互联，该技术在在线游戏协议中已经的到了应用 4.2.1集中服务器 打洞技术嘉定客户端A和客户端B都可以与公网内的已知集中服务器建立UDP链接，一个客户端在集中服务器上登陆的时候，服务器记录下改客户端的两对地址二元组信息{IP地址:UDP端口}，一对是该客户端与集中服务器进行通信的自身的地址和端口号，另外一对是集中服务器记录下的由服务器观察到的改客户端实际与自己所使用的地址和端口号，我们可以把前一对地址二元组看作是客户端的内网地址和端口号，把后一对地址二元组看作是客户端的内网地址和端口号经过NAT转换后的外网地址和端口号，集中服务器可以从客户端的登录消息中的到客户端内网相关信息，还可以通过消息的IP头和UDP头得到改客户端的外网相关信息，如果该客户端不是位于NAT设备后面，那么采用上述方法得到的两对地址二元组信息是完全相同的。 4.2.2建立p2p session假定客户端A要发起客户端B的直接链接，具体的打洞过程如下: 客户端A最初不知道如何向客户端B发起链接，于是客户端A向集中服务器发送消息，请求集中服务器帮助建立与客户端B的UDP链接。 集中服务器将含有客户端B的外网和内网地址二元组发送给客户端A，同时，集中服务器将包含将包含有客户端A的外网和内网地址二元组信息发送给客户端B，这样以来,客户端A与客户端B就都知道对方外网和内网的地址二元组信息了。 当客户端A收到有集中服务器发来的包含客户端B的外网和内网的地址二元组信息后，客户端A开始向客户端B的地址二元组发送UDP数据包，并且客户端A会自动锁定第一个给出相应的客户端B的地址二元组，同理，当客户端B收到由集中服务器发来的客户端A的地址二元组信息后，也会开始向客户端A的外网和内网的地址二元组发送UDP数据包，并且 自动锁定第一个得到的客户端A回应的二元组，由于客户端A与客户端B互相向对方发送UDP数据包的操作是异步的，所以客户端A和客户端B发送数据包的时间先后没有时序要求。 下面来看下这三者之间时如何进行UDP打洞的,在这我们分三种具体情景来讨论： 两个客户端都唯一同一个NAT设备后面，即位于同一个内网中； 两个客户端分别位于不同的NAT设备后面，分属于不容的内网; 两个客户端位于两层NAT设备之后,通常最上层的NAT是由网络提供商提供的，第二层NAT时家用的NAT路由器之类的设备提供的； 4.2.3 p2p的两个客户端位于同一个NAT设备后面首先假设两个客户端位于同一个NAT后面，并且位于内网，如图所示，客户端A与集中服务器建立UDP链接，经过NAT转换后，A的公网端口被映射为62000，客户端B同样与集中服务器建立了UDP链接,公网端口映射为62005; 假设客户端A向通过集中服务器，发起对客户端B的链接，客户端A向集中服务器发出消息请求与客户端B进行链接，集中服务器将客户端B的外网地址二元组以及内网地址二元组发送给客户端A,同时把客户端A的相关二元组信息发给B，。客户端A和客户端B发往对方公网地址二元组兵一定会被对方收到，这取决于当前的NAT设备是否支持不同端口之间的UDP数据包能够到达，即Harrpin转换特性，无论如何客户端Ａ发往客户端B的内网地址二元组的UDP数据包一定可以到达，内网数据包不需要路由，且速度更快，客户端A与客户端B推荐采用内网地址二元组信息进行常规p2p通信。 假定NAT设备支持Hairpin转换，具体的Hairpin转换详见其他文章，应用程序也应该忽略与内网地址二元组的链接，如果客户端A和客户端B采用外网的地址二元组作为p2p通信的链接，这势必会造成数据包无谓的经过NAT设备，这是一种对资源的浪费，就目前的网络情况而言，应用程序在”打洞”的时候，最好还是把外网和内网地址二元组都尝试一下，如果都能成功，有限以内网地址进行链接。 4.2.4 P2P客户端位于不同NAT设备后面 假定客户端A与客户端B在不容的NAT设备后面，分属于不同的内网，如图所示，客户端A与客户端B都经由个子的NAT设备与集中服务器建立了UDP链接，客户端A与客户端B的本地端口好均为4321，集中服务器的公网端口号为1234，在向外的回话中，客户端A的外网IP被映射为159.99.25.11，外网端口为62000，客户端B的外网IP被映射为138.76.29.7，外网端口为31000. 如下图所示： 客户端A -&gt; 本地IP:10.0.0.1,本地端口4321, 外网IP:155.99.25.11,外网端口62000 客户端B -&gt; 本地IP:10.1.1.3,本地端口4321, 外网IP:138.76.29.7, 外网端口31000 在客户端A或者B向集中服务器发送登陆消息时，服务器会记录下客户端的内外网的二元组信息，后期无论是A与B二者中的任何乙方向服务器发送P2P请求，服务器都会将记录下来的上述信息发送给A或B. A,B分属于不同的内网，他们彼此的内网地址在外网中时没有路由的，所以发往各自内网地址的UDP数据包回发送到错误的主机或者根本不存在的主机上，现在假定A的第一个消息将发往B的外网地址，如图所示，该消息途径A的NAT设备，并在该设备上生成一个回话表项，该会话表项源地址二元组信息时{10.0.0.1:4321}，该地址二元组信息和客户端A与服务器建立连接的时候NAT生成的源地址二元组信息一样，但他的目的地址不同，如果A的NAT设备给出的响应是OK的，那么A的NAT设备将保留A的内网地址二元组信息，并且所有来自A的源地址二元组信息为{10.0.0.1:4321}的数据包都沿用A与集中服务器事先建立起来的回话，外网地址二元组信息均为{155.99.25.11:62000}. A向B的外网地址发送消息的过程就是”打洞”的过程，从A的内网的角度来看应为从{10.0.0.1:4321}发往{138.76.29.7:31000},从A在其NAT设备上建立的回话来看，是从{155.99.25.11:62000}发到{138.76.29.7:31000}. 如果A发送给B的外网地址二元组的信息包在B向A发送消息包之前到达B的NAT设备，B的NAT设备会认为A发过来的消息是未授权的外网消息，会丢弃该数据包.B发往A的消息与上述过程一样，会在B的NAT设备上建立一个{10.1.1.3:4321,155.99.25.11:62000}的会话(通常也会沿用B与集中服务器链接时建立的会话，只是该会话现在不仅接受服务器发给B的消息，还接受从A的NAT设备155.99.25.11:62000发来的消息),一旦A与B都想对方的NAT设备在外网上的地址二元组发送了数据包，就打开了A与Ｂ之间的洞，A与B向对方的外网地址发送数据，等效为向对方的客户端直接发送UDP数据包了，一旦应用程序确认已经可以通过往对方的外网地址发送数据包的方式让数据到达NAT后面的目的应用程序，程序会自动停止继续发送用于打洞的数据包，转而开始真正的p2p数据传输； 4.2.5 P2P客户端位于多层NAT设备后面 有的网络拓扑结构包含了多个NAT设备，如果没有掌握该拓扑结构的详细信息，两个客户端之间是无法建立”最优化”的P2P路由的，现在我们来讨论最后一种情况。如图所示，假定NAT C是由ISP提供的NAT设备，NAT C提供多个用户节点映射到有限的几个公网IP的服务，NAT A和NAT B作为NAT C的内网节点将把用户的家庭网络或内部网络接入NAT C的内网，然后用户的内部网络就可以经由NAT C访问公网了，从这种拓扑结构来看，只有服务器与NAT C时真正拥有公网可路由IP地址的设备，而NAT A和NAT B所使用的公网IP地址，实际上石油ISP服务提供商设定的(相对于NAT C而言)内网地址(本文的后续部分把这个由ISP提供的内网地址相对于NAT C称之为”伪”公网地址)，同理隶属于NAT A与NAT B的客户端,相对于NAT A,NAT B而言，他们处于NAT A,NAT B的内网，以此类推，客户端可以放到多层NAT设备后面，客户端A和客户端B发去对于服务器S的链接的时候，就会以此在NAT A和NAT B上建立向外的Session，而NAT A，NAT B要联入公网的时候，会在NAT C上在建立想歪的Session; 现在假定客户端A和B希望通过UDP”打洞”完成两个客户端的P2P直连，最优化的路由策略时客户端A向客户端B的伪公网IP上发送数据包，即ISP服务器提供商指定的内网IP,NAT B的伪公网地址二元组{10.0.1.2:55000},由于从服务器的角度只能观察到真正的公网地址，也就是 NAT A,NAT B在NAT C建立session的真正的公网地址{155.99.25.11:62000}以及{155.99.25.11:62005},非常不幸的时客户端A与客户端B是无法通过服务器知道这些伪公网地址，而且即使客户端A和B通过某种手段得到NAT A和NAT B的伪公网地址，我们仍然不建议采用上述的最优化的打洞方式，这是因为这些地址是由ISP服务器提供商提供的或许会存在与客户端本身所在的内网地址重复的可能性(例如：NAT A的内网的IP地址域恰好与NAT A 在NAT C的伪公网IP地址域重复，这样就导致打洞数据包无法发出的问题)，因此客户端别无选择，只能使用由公网服务器观察到的A,B二元组进行打洞操作，用于打洞的数据包将由NAT C进行转发。 当客户端A向客户端B的公网地址二元组{155.99.25.11:62005}发送UDP数据包的时候，NAT A首先把数据包的源地址二元组由A的内网地址二元组{10.0.0.1:4321}转换为伪公网地址二元组{10.0.1.1:45000},现在数据包到了NAT C,NAT C应该可以是别处来该数据包是要发往自身转换过得公网地址二元组，如果NAT C可以给出”合理”相应的话，NAT C将把该数据包的源地址二元组改为{155.99.25.11:62000}，目的地址二元组改为{10.0.1.2:55000},即NAT B的”伪公网”地址二元组，NAT B最后会将数据包发往客户端B,同样，由B发往A的数据包也会经过类似的过程，目前也有很多NAT设备不支持类似这样的Hairpin转换，但是意境有越来越多的NAT设备商开始加入对该转换的支持中来。 4.2.6 UDP在空闲状态下的超时问题由于UDP转换协议提供的“洞”不是绝对可靠的，多数NAT设备内部都有一个UDP转换的空闲状态计时器，如果在一段时间内没有UDP数据通信，NAT设备会关掉由“打洞”操作打出来的“洞”，作为应用程序来讲如果想要做到与设备无关，就最好在穿越NAT以后设定一个穿越的有效期。很遗憾目前没有标准有效期，这个有效期与NAT设备内部的配置有关，某些设备上最短的只有20秒左右。在这个有效期内，即使没有P2P数据包需要传输，应用程序为了维持该“洞”可以正常工作，也必须向对方发送“打洞”心跳包。这个心跳包是需要双方应用程序都发送的，只有一方发送不会维持另一方的Session正常工作。除了频繁发送“打洞”心跳包以外，还有一个方法就是在当前的“洞”超时之前，P2P客户端双方重新“打洞”，丢弃原有的“洞”，这也不失为一个有效的方法。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2>&1详解]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2015%2F01%2F28%2Flinux%E5%AD%A6%E4%B9%A0-2015-01-28-shell%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Shell: /dev/null 2&gt;&amp;1详解可以将/dev/null看作”黑洞”. 它非常等价于一个只写文件. 所有写入它的内容都会永远丢失. 而尝试从它那儿读取内容则什么也读不到. 然而, /dev/null对命令行和脚本都非常的有用. 用处: 禁止标准输出. 1 cat $filename &gt;/dev/null # 文件内容丢失，而不会输出到标准输出. 禁止标准错误. 2&gt;/dev/null 这样错误信息[标准错误]就被丢到太平洋去了. &gt; 代表重定向到哪里，例如：echo “123” &gt; /home/123.txt 1 表示stdout标准输出，系统默认值是1，所以”&gt;/dev/null”等同于”1&gt;/dev/null” 2 表示stderr标准错误 &amp; 表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1 那么本文标题的语句： 1&gt;/dev/null 首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。 2&gt;&amp;1 接着，标准错误输出重定向等同于 标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[crtmpserver配置文件说明]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2015%2F01%2F28%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2015-01-28-crtmpserver%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[配置文件说明配置文件实际上是一个Lua脚本，它包含至少一个configuration的对象，从而为程序提供灵活的扩展和定制功能。除了configuration对象外，还可以有函数，Lua库等。 主结构12345678910111213configuration=&#123; daemon=false, pathSeparator="/", logAppenders= &#123; -- content removed for clarity &#125;, applications= &#123; -- content removed for clarity &#125;&#125; key type mandatory description daemon boolean yes true 表示 服务以后台方式启动;false 表示 服务以控制台模式启动(以用于开发); pathSeparator string(1) yes 用来分隔路径; 例如，在UNIX-like是 /, Windows是\; logAppenders object yes 配置日志追加的容器 applications object yes 配置加载各种应用的容器 服务启动时，将按顺序执行下列操作: 配置文件加载后，首先做的就是对配置文件进行校验，如果配置文件有错误，将会有错误提示并停止启动，可进行修改后再启动; 读取 daemon 值，判断服务是以后台方式启动还是以控制台方式启动; 读取日志追加器，用来配置日志记录并启动到运行状态，依据日志追加器，可以看到更多的日志信息; 最后的应用加载，只到这一步完成后，服务和应用才在线，并准备就绪; 日志追加器这部分包含了一个日志追加器的列表。整个日志追加器的添加是在加载时配置，依据日志级别，追加器可以选择是否有日志消息输出到指定目的处； 1234567891011121314logAppenders=&#123; &#123; name="console appender", type="coloredConsole", level=6 &#125;, &#123; name="file appender", type="file", level=6, fileName="/tmp/crtmpserver.log" &#125;&#125;, logAppenders structure key type mandatory description name string yes 追加器的名字. type string yes 追加器的类型可以是控制台，带颜色控制台或文件;控制台和带颜色控制台都会将日志消息输出到控制台，不同之处在于带颜色控制台会依据日志级别进行颜色标记；文件类型则会将所有消息输出到指定的文件； level number yes 日志的级别可见下表中的级别定义；\n只有小于或等于这个级别的日志消息会被记录，高于这个级别则都被丢弃；例如:级别为0时，只记录 FATAL 消息；级别为3时，只记录 FATAL, ERROR, WARNING, INFO 消息； fileName string yes 如果追加器类型为文件，则在此处指定日志文件和路径 Log levels name value 0 FATAL 1 ERROR 2 WARNING 3 INFO 4 DEBUG 5 FINE 6 FINEST PS: 当使用后台模式时，所有的控制台追加消息将会被忽略。 应用这部分用来配置各种应用，并设置这些应用的属性；每个应用的属性都对应了这个应用的指定功能； 12345678910111213141516applications=&#123; rootDirectory="applications", &#123; -- settings for application 1 -- content removed for clarity &#125;, &#123; -- settings for application 2 -- content removed for clarity &#125;, &#123; -- settings for application 3 -- content removed for clarity &#125;&#125; applications structure key type mandatory description rootDirectory string true 这个目录包含了应用的子目录；如果路径以 / 或 \ 开始， 则视其为绝对路径，否则视为启动服务时所在的相对路径； rootDirectory 之后，是应用的集合；每个应用都定义了一个有特定属性的对象；细节如下所示； 应用定义 这些目录用来定义应用.自从790版本后，添加了一新的功能：mediaStorage; 这个功能能使应用可以有多个mediaFolder，并且可以将.seek/.meta文件和媒体文件分开存储在不同的文件夹中； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&#123; name="flvplayback", protocol="dynamiclinklibrary", description="FLV Playback Sample", default=false, validateHandshake=true, enableCheckBandwidth=true, -- this settings are now part of mediaStorage setting -- keyframeSeek=true, -- seekGranularity=1.5, -- clientSideBuffer=12, -- generateMetaFiles=true, -- renameBadFiles=true, aliases= &#123; "simpleLive", "vod", "live", "WeeklyQuest", "SOSample", "oflaDemo", "chat", &#125;, acceptors = &#123; &#123; -- acceptor 1 -- content removed for clarity &#125;, &#123; -- acceptor 2 -- content removed for clarity &#125;, &#123; -- acceptor n -- content removed for clarity &#125;, &#125;, -- new feature mediaStorage mediaStorage = &#123; namedStorage1=&#123; description="Main storage", mediaFolder="/usr/main_storage/media", -- only this parameter IS MANDATORY metaFolder="/usr/main_storage/metadata", -- if you have static large file to stream it is good to know that for a file around 500MB -- it's .seek file has around 16MB; so it would be preffer to designate metafolder into a system -- partition which has enough space... for no surprises... :) statsFolder="/usr/main_storage/statsFolder", enableStats=true, clientSideBuffer=16, keyframeSeek=false, -- should crtmpdserver DO SEEK ONLY IN key-frame (true/false)? -- very useful to know in situations like play/pause/resume (meaning pause/seek/play) seekGranularity=1, generateMetaFiles=false, renameBadFiles=false, &#125;, --[[&#123; -- here is another example of storage; it does not start with name=&#123;...&#125; description="Second storage of same application", mediaFolder="/usr/second_storage/media/flv", metaFolder="/usr/second_storage/metadata", statsFolder="/usr/second_storage/statsFolder", &#125;,]]-- &#125;, externalStreams = &#123; &#123; -- stream 1 -- content removed for clarity &#125;, &#123; -- stream 2 -- content removed for clarity &#125;, &#123; -- stream n -- content removed for clarity &#125;, &#125;, authentication= &#123; -- content removed for clarity &#125;&#125; application structure key type mandatory description name string yes 应用的名称 protocol string yes 应用的类型值为 dynamiclinklibrary 意即 应用是一个共享库 description string no 应用的描述信息 default string no 这个标志指定了默认应用；默认应用负责分析连接请求并将连接分配到正确的应用 validateHandshake boolean no 通知服务器在进行下一步前要对客户端的握手进行验证；这是一个可选项，其默认值为真。如果这个值为真 且 握手失败，服务器就放弃这个连接;如果这个值为假，则不会进行强制的握手验证，所有的连接都会被接受； keyframeSeek boolean no 这个属性指定了流生成器只在关键帧搜索，如果是直播流，则忽略这个值 seekGranularity double no 搜索的精细度，以秒为单位, 值域定义在 0.1 ~ 600; 例如：如果粒度定义为10秒，并期望定位到 t= 2:34; 则实际上是会定位到 t= 2:30. 60秒被认定为完整的电影长度，1秒为电影片断； clientSideBuffer double no 每个连接在客户端的缓冲秒数，值定义在5 ~ 30 秒； generateMetaFiles boolean no 在应用启动前生成 seek/meta文件 renameBadFiles boolean no 如果这上值为真且媒体文件是不能被解析的，则媒体文件被重命名为 *.bad，否则这样的文件将不做处理 aliases object no 应用的别名 acceptors object no 接受器保持这个服务并让服务器托管；应用可以有它自己的接受器，但这个是可选的； externalStreams object no authentication object no mediaFolder string yes 当定义了 mediaStorage时，这个域用来指定媒体文件的物理位置； metaFolder string no 指定用来存放 .seek/.meta文件的位置； statsFolder string no 服状态文件的位置 acceptor structure key type mandatory description ip string yes 服务所在的IP, 0.0.0.0表示所有接口和所有IP; port string yes 服务监听的端口号 protocol string yes 对应 ip:port的服务的协议]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python CRC32]]></title>
    <url>%2FPython%E5%AD%A6%E4%B9%A0%2F2015%2F01%2F28%2FPython%E5%AD%A6%E4%B9%A0-2015-01-30-python-CRC32%2F</url>
    <content type="text"><![CDATA[python CRC32方法123456def _crc32(self, v): """ Generates the crc32 hash of the v. @return: str, the str value for the crc32 of the v """ return '0x%x' % (binascii.crc32(v) &amp; 0xffffffff)]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python 看门狗]]></title>
    <url>%2FPython%E5%AD%A6%E4%B9%A0%2F2015%2F01%2F28%2FPython%E5%AD%A6%E4%B9%A0-2015-01-28-python%E7%9C%8B%E9%97%A8%E7%8B%97%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[python看门狗123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283# -*- coding: utf-8 -*-import timeimport osimport sysimport signalimport socket# set the default encoding to utf-8# reload sys model to enable the getdefaultencoding method.reload(sys)# using exec to set the encoding, to avoid error in IDE.exec "sys.setdefaultencoding('utf-8')"assert sys.getdefaultencoding().lower() == "utf-8"# TODO: check python version, &gt;=2.6 requires.def handler(signum, frame): print 'usr press ctrl+c, exit' sys.exit(0)signal.signal(signal.SIGINT, handler)# the command to get and check the My server statuscheck_My_server_command = "sudo /etc/init.d/daodaoliang status"# when server stopped, restart it.start_My_server_command = "sudo /etc/init.d/daodaoliang start"# the interval to check the server.check_My_server_interval_seconds = 5# sleep seconds when main function exceptionmain_function_exception_sleep_seconds = 10# email to user listto_user = ["88341189@qq.com", "wangxkww@163.com"]# constsMy_server_dir = "/work/code//work/code/cusflo-server-moon"My_server_version_command = "%s/dog/client_update_dog.py" % My_server_dirMy_server_conf_file = "%s/conf/My_server.conf" % My_server_dirMy_server_log_prefix = "daodaoliang.log"import smtplibfrom email.mime.text import MIMETextdef send_mail(smtp_server, username, password, to_user, subject, content): msg = MIMEText(content, _subtype='html', _charset='gb2312') msg['Subject'] = subject msg['From'] = username msg['To'] = ";".join(to_user) try: smtp = smtplib.SMTP() smtp.connect(smtp_server) smtp.login(username, password) smtp.sendmail(username, to_user, msg.as_string()) smtp.close() return 0 except Exception, ex: print "send email failed: %s" % ex return 1if len(sys.argv) &lt;= 3: print """Usage: %s &lt;email_smtp_server&gt; &lt;email_username&gt; &lt;email_password&gt; email_smtp_server the smtp server. eg. smtp.126.com email_username the email user to login to smtp server. eg. mymail@126.com email_password the email user password to login. e.g xxxxxFor example: %s smtp.126.com mymail@126.com xxxxx""" % (sys.argv[0], sys.argv[0]) sys.exit(1)(email_smtp_server, email_username, email_password) = sys.argv[1:]print "email_smtp_server=%s, email_username=%s, email_password=%s" % ( email_smtp_server, email_username, email_password)def strip_execute_command_get_output(cmd): output = execute_command_get_output(cmd) output = [x.strip() for x in output] return outputdef execute_command_get_output(cmd): try: pipe = os.popen(cmd) output = pipe.readlines() pipe.close() return output except Exception, ex: print "execute cmd %s failed: %s" % (cmd, ex) return "error"hostname = socket.gethostname()iplist = strip_execute_command_get_output( '''ifconfig 2&gt;/dev/null |grep "inet addr"|awk '&#123;print $2&#125;'|awk -F ':' '&#123;print $2&#125;'|grep -v "127.0.0.1"''')sysinfo = "%s %s" % (sys.platform, sys.version.replace("\n", " "))print "hostname=%s, iplist=%s, sysinfo=%s" % (hostname, iplist, sysinfo)def generate_content_then_start_server(): basic_cmd = time.strftime('%Y-%m-%d %X', time.localtime()) basic_info = "%s\n%s\n%s" % (hostname, " ".join(iplist), sysinfo) version_cmd = "%s -v 2&gt;&amp;1" % My_server_version_command version_info = execute_command_get_output(version_cmd) ls_cmd = "ls -lh %s 2&gt;&amp;1; ls -lh %s/log 2&gt;&amp;1" % (My_server_dir, My_server_dir) ls_info = execute_command_get_output(ls_cmd) lsbrelease_cmd = "lsb_release -a 2&gt;&amp;1" lsbrelease_info = execute_command_get_output(lsbrelease_cmd) uname_cmd = "uname -a 2&gt;&amp;1" uname_info = execute_command_get_output(uname_cmd) ccamr_cmd = "ccamr list 2&gt;&amp;1" ccamr_info = execute_command_get_output(ccamr_cmd) ps_cmd = "ps aux|grep My|grep -v Myd|grep -v grep 2&gt;&amp;1" ps_info = execute_command_get_output(ps_cmd) df_cmd = "df -h 2&gt;&amp;1" df_info = execute_command_get_output(df_cmd) free_cmd = "free -m 2&gt;&amp;1" free_info = execute_command_get_output(free_cmd) conf_cmd = "cat %s 2&gt;&amp;1" % My_server_conf_file conf_info = execute_command_get_output(conf_cmd) top_cmd = "top -c -n 1 -b 2&gt;&amp;1" top_info = execute_command_get_output(top_cmd) vmstat_cmd = "vmstat 1 3 2&gt;&amp;1" vmstat_info = execute_command_get_output(vmstat_cmd) iostat_cmd = "iostat 1 3 2&gt;&amp;1" iostat_info = execute_command_get_output(iostat_cmd) print "dump info success" # old logs old_logs = strip_execute_command_get_output( "(cd %s/log/ &amp;&amp; ls |grep %s) 2&gt;&amp;1" % (My_server_dir, My_server_log_prefix)) # start server. start_cmd = "%s 2&gt;&amp;1" % start_My_server_command start_info = execute_command_get_output(start_cmd) print "try start server completed" # get the system start logs newlogs_cmd = "(cd %s/log/ &amp;&amp; ls |grep %s" % (My_server_dir, My_server_log_prefix) for i in old_logs: newlogs_cmd = "%s| grep -v %s" % (newlogs_cmd, i) newlogs_cmd = "%s| xargs cat) 2&gt;&amp;1" % newlogs_cmd newlogs_info = execute_command_get_output(newlogs_cmd) content = ''' &lt;style&gt; div.cmd&#123; background-color: #00E000; font-size: 15px; font-weight: bold; padding: 2px 3px 2px 5px; &#125; div.info&#123; background-color: #CCCCCC; margin-top: 0px; margin-bottom: 10px; margin-left: 10px; font-size: 12px; padding: 2px 3px 2px 5px; &#125; &lt;/style&gt; &lt;!-- basic --&gt; &lt;div&gt; &lt;div class='cmd'&gt;%s&lt;/div&gt; &lt;div class='info'&gt;%s&lt;/div&gt; &lt;/div&gt; &lt;!-- version --&gt; &lt;div&gt; &lt;div class='cmd'&gt;%s&lt;/div&gt; &lt;div class='info'&gt;%s&lt;/div&gt; &lt;/div&gt; &lt;!-- ls --&gt; &lt;div&gt; &lt;div class='cmd'&gt;%s&lt;/div&gt; &lt;div class='info'&gt;%s&lt;/div&gt; &lt;/div&gt; &lt;!-- lsbrelease --&gt; &lt;div&gt; &lt;div class='cmd'&gt;%s&lt;/div&gt; &lt;div class='info'&gt;%s&lt;/div&gt; &lt;/div&gt; &lt;!-- uname --&gt; &lt;div&gt; &lt;div class='cmd'&gt;%s&lt;/div&gt; &lt;div class='info'&gt;%s&lt;/div&gt; &lt;/div&gt; &lt;!-- ccamr --&gt; &lt;div&gt; &lt;div class='cmd'&gt;%s&lt;/div&gt; &lt;div class='info'&gt;%s&lt;/div&gt; &lt;/div&gt; &lt;!-- ps --&gt; &lt;div&gt; &lt;div class='cmd'&gt;%s&lt;/div&gt; &lt;div class='info'&gt;%s&lt;/div&gt; &lt;/div&gt; &lt;!-- df --&gt; &lt;div&gt; &lt;div class='cmd'&gt;%s&lt;/div&gt; &lt;div class='info'&gt;%s&lt;/div&gt; &lt;/div&gt; &lt;!-- free --&gt; &lt;div&gt; &lt;div class='cmd'&gt;%s&lt;/div&gt; &lt;div class='info'&gt;%s&lt;/div&gt; &lt;/div&gt; &lt;!-- conf --&gt; &lt;div&gt; &lt;div class='cmd'&gt;%s&lt;/div&gt; &lt;div class='info'&gt;%s&lt;/div&gt; &lt;/div&gt; &lt;!-- top --&gt; &lt;div&gt; &lt;div class='cmd'&gt;%s&lt;/div&gt; &lt;div class='info'&gt;%s&lt;/div&gt; &lt;/div&gt; &lt;!-- vmstat --&gt; &lt;div&gt; &lt;div class='cmd'&gt;%s&lt;/div&gt; &lt;div class='info'&gt;%s&lt;/div&gt; &lt;/div&gt; &lt;!-- iostat --&gt; &lt;div&gt; &lt;div class='cmd'&gt;%s&lt;/div&gt; &lt;div class='info'&gt;%s&lt;/div&gt; &lt;/div&gt; &lt;!-- start server --&gt; &lt;div&gt; &lt;div class='cmd'&gt;%s&lt;/div&gt; &lt;div class='info'&gt;%s&lt;/div&gt; &lt;/div&gt; &lt;!-- server log --&gt; &lt;div&gt; &lt;div class='cmd'&gt;%s&lt;/div&gt; &lt;div class='info'&gt;%s&lt;/div&gt; &lt;/div&gt; ''' % (basic_cmd, "&lt;pre&gt;%s&lt;/pre&gt;" % "".join(basic_info), version_cmd, "&lt;pre&gt;%s&lt;/pre&gt;" % "".join(version_info), ls_cmd, "&lt;pre&gt;%s&lt;/pre&gt;" % "".join(ls_info), lsbrelease_cmd, "&lt;pre&gt;%s&lt;/pre&gt;" % "".join(lsbrelease_info), uname_cmd, "&lt;pre&gt;%s&lt;/pre&gt;" % "".join(uname_info), ccamr_cmd, "&lt;pre&gt;%s&lt;/pre&gt;" % "".join(ccamr_info), ps_cmd, "&lt;pre&gt;%s&lt;/pre&gt;" % "".join(ps_info), df_cmd, "&lt;pre&gt;%s&lt;/pre&gt;" % "".join(df_info), free_cmd, "&lt;pre&gt;%s&lt;/pre&gt;" % "".join(free_info), conf_cmd, "&lt;pre&gt;%s&lt;/pre&gt;" % "".join(conf_info), top_cmd, "&lt;pre&gt;%s&lt;/pre&gt;" % "".join(top_info), vmstat_cmd, "&lt;pre&gt;%s&lt;/pre&gt;" % "".join(vmstat_info), iostat_cmd, "&lt;pre&gt;%s&lt;/pre&gt;" % "".join(iostat_info), start_cmd, "&lt;pre&gt;%s&lt;/pre&gt;" % "".join(start_info), newlogs_cmd, "&lt;pre&gt;%s&lt;/pre&gt;" % "".join(newlogs_info) ) # print content; return contentdef main(): while True: print "start check server status" ret = os.system("%s &gt; /dev/null 2&gt;&amp;1" % check_My_server_command) if ret != 0: print "server crash, ret=%s" % ret subject = "[MyServer] watchdog server %s crash" % hostname content = generate_content_then_start_server() print "email to %s" % to_user if 0 == send_mail(email_smtp_server, email_username, email_password, to_user, subject, content): print "email success" else: print "server is ok" time.sleep(check_My_server_interval_seconds)while True: try: main() except Exception, ex: print "main function exception: %s" % ex time.sleep(main_function_exception_sleep_seconds)]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CentOS6.5安装crtmpserver搭建RTMP流媒体服务器]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2015%2F01%2F28%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2015-01-28-CentOS6-5%E5%AE%89%E8%A3%85crtmpserver%E6%90%AD%E5%BB%BARTMP%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[1. crtmpserver简介 支持推送给rtmp流的接受与播放器请求的分发； rtmp流媒体服务器树状网络集群的构建； 支持 和 ```android```;1234567891011PS:[官网应用介绍](http://www.rtmpd.com/)## ***2. crtmpserver流媒体服务器的搭建(centOS6.5)***### ***2.1 cmake的安装***下载最新的cmake```sh yum install cmake 2.2 openssl的安装12345wget -o openssl-0.9.8t.tar.gz http://www.openssl.org/source/openssl-0.9.8ze.tar.gzcd openssl-0.9.8t./configmake .make install 2.3 crtmpserver的编译与安装1234567svn co --username anonymous --password "" https://svn.rtmpd.com/crtmpserver/branches/1.0 crtmpservercd crtmpserversh ./cleanup.shcd builders/cmakecmake .make./crtmpserver/crtmpserver ./crtmpserver/crtmpserver.lua PS: 最后一行命令“”#./crtmpserver/crtmpserver ./crtmpserver/crtmpserver.lua”意思是：使用“./crtmpserver/crtmpserver.lua”为配置脚本，启动“crtmpserver”服务; 最后一行命令的目录是在”builders/cmake”下; 3. 脚本的自启动和静默运行1nohup ./crtmpserver/crtmpserver ./crtmpserver/crtmpserver.lua &amp; 4. JWPlayer直播方案搭建4.1 搭建http server略 4.2 下载JWPlayer并部署到http server上JWPlayer官网JWPlayer下载页面以上链接不能用的话我自己网盘里面有ｏ（╯□╰）ｏ下载解压后，将jwplayer整个文件夹内容放到网站指定目录下如根目录下的jwplayer文件夹; 4.3 新建播放器的html页面test.html 1234567891011&lt;html&gt; &lt;head&gt; &lt;script src="/jwplayer/jwplayer.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='my-video'&gt;&lt;/div&gt; &lt;script type='text/javascript'&gt; jwplayer('my-video').setup(&#123;file:'rtmp://127.0.0.1/live/livestream',width: '640', height: '480'&#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 4.4 使用Flash Media Live Encoder推送直播源 设置好后，点start即可 4.5 浏览器中查看1http://127.0.0.1/jwplayer/test.html 4.6 使用ffmpeg做为直播源 不能直接使用ffmpeg的rtmp模块进行流推送需要使用librtmp才能进行正常的流推送和观看； 原始的lua可以不用做修改,示例命令如下： 1./ffmpeg -re -i c1.flv -acodec copy -vcodec copy -f flv rtmp://127.0.0.1/live/livestream]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[netstat命令学习]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2015%2F01%2F27%2Flinux%E5%AD%A6%E4%B9%A0-2015-01-27-netstat%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[netstat 命令简介Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。 参数解析123456789101112131415161718192021222324252627282930313233usage: netstat [-vWeenNcCF] [&lt;Af&gt;] -r netstat &#123;-V|--version|-h|--help&#125; netstat [-vWnNcaeol] [&lt;Socket&gt; ...] netstat &#123; [-vWeenNac] -i | [-cWnNe] -M | -s &#125; -r, --route 显示路由表 -i, --interfaces display interface table -g, --groups display multicast group memberships -s, --statistics display networking statistics (like SNMP) -M, --masquerade display masqueraded connections -v, --verbose 显示详细信息 -W, --wide don't truncate IP addresses -n, --numeric 不解析名称 --numeric-hosts 不解析主机名 --numeric-ports 忽略端口名称 --numeric-users 忽略用户名 -N, --symbolic resolve hardware names -e, --extend 显示更多信息 -p, --programs display PID/Program name for sockets -c, --continuous continuous listing -l, --listening display listening server sockets -a, --all, --listening display all sockets (default: connected) -o, --timers display timers -F, --fib display Forwarding Information Base (default) -C, --cache display routing cache instead of FIB &lt;Socket&gt;=&#123;-t|--tcp&#125; &#123;-u|--udp&#125; &#123;-w|--raw&#125; &#123;-x|--unix&#125; --ax25 --ipx --netrom &lt;AF&gt;=Use '-6|-4' or '-A &lt;af&gt;' or '--&lt;af&gt;'；默认： inet 列出所有支持的协议： inet (DARPA Internet) inet6 (IPv6) ax25 (AMPR AX.25) netrom (AMPR NET/ROM) ipx (Novell IPX) ddp (Appletalk DDP) x25 (CCITT X.25) -a (all)显示所有选项，默认不显示LISTEN相关 -t (tcp)仅显示tcp相关选项 -u (udp)仅显示udp相关选项 -n 拒绝显示别名，能显示数字的全部转化成数字。 -l 仅列出有在 Listen (监听) 的服務状态 -p 显示建立相关链接的程序名 -r 显示路由信息，路由表 -e 显示扩展信息，例如uid等 -s 按各个协议进行统计 -c 每隔一个固定时间，执行该netstat命令。 提示：LISTEN和LISTENING的状态只有用-a或者-l才能看到 列出所有端口(包括监听的没监听的)列出所有tcp端口 netstat -at列出所有udp端口 netstat -au 列出所有处于监听状态的Sockets只显示监听端口 netstat -l只列出所有监听tcp端口 netstat -lt只列出所有监听udp端口 netstat -lu只列出所有监听unix端口 netstat -lx 显示每个协议的统计信息显示所有端口的统计信息 netstat -s显示TCP或者UDP端口的统计信息 netstat -st 或者 netstat -su 在netstat输出中显示PID和进程名称 netstat -p在netstat输出中不显示主机，端口和用户名 # netstat -an持续输出netstat信息 netstat -c找出程序运行的端口 netstat -ap | grep ssh显示网络接口列表 netstat -i]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CentOS6.5安装DSS搭建RTSP流媒体服务器]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2015%2F01%2F27%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2015-01-27-CentOS6-5%E5%AE%89%E8%A3%85DSS%E6%90%AD%E5%BB%BARTSP%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[1. 下载Darwin Streaming Server v5.5.5 Linux安装包 下载 http://dss.macosforge.org/downloads/DarwinStreamingSrvr5.5.5-Linux.tar.gz，然后通过SFTP或者FTP上传到服务器上。 如果服务器可以上网，也可以直接用wget命令下载： 1wget http://dss.macosforge.org/downloads/DarwinStreamingSrvr5.5.5-Linux.tar.gz 2. 解包DarwinStreamingSrvr5.5.5-Linux.tar.gz文件 执行解压命令 1tar -zxvf DarwinStreamingSrvr5.5.5-Linux.tar.gz 3. 安装DSS cd到DarwinStreamingSrvrlinux-Linux目录 1cd DarwinStreamingSrvrlinux-Linux 安装Darwin Streaming Server v5.5.5 1./Install 4. 配置测试 打开浏览器，访问Darwin Streaming Server WEB界面（ip换成你服务器的IP） 1http://ip:1220/ 初始设置向导 Setup Assistant MP3 Broadcast Password：这里重复输入你的密码，然后点Next下一步； Setup Assistant Secure Administration：不用勾选，直接点Next下一步； Setup Assistant Media Folder:默认为/usr/local/movies，不建议修改，直接点Next下一步； Setup Assistant Streaming on Port 80：不建议改端口，点Finish完成设置向导; 测试RTSP流媒体服务是否可用： 现在可以打开QuickTime 播放了，选择url播放，由于我播放列表中是sample_100kbit.mp4，所以在url中输入： 1rtsp://172.16.31.141/sample_100kbit.mp4，172.16.31.141是我linux机器的地址。 5. 视频转换 如果要用自己的多媒体文件来测试程序，传到流媒体服务器上后，用模拟器测试是无法播放的，程序会报 1CommandPLAYER_INIT completed with an error or infoPVMFFailure 流媒体是需要先hint的。所谓hint只是在原有的视音频轨道上增加一些流化信息。 hint的具体解释可以参考下面这段英文： 123456789101112131415161718192021Hint tracks are a series of instructions in a mp4 container file that tell a server how to transmit packets. Hint tracks always refer to another track, most likely an audio or video media track. This series of instructions tells the server when to send the packet, what type of RTP header to add, if there is any extra data in the packet, and how much data to send in the packet. To save on space, a hint can contain a pointer to the media track, instead of duplicating that data. It will also tell what SDP to add for the track that is referenced. So, a file that is hinted should have a media track, and an associated hint track for that media track. There are some mp4 container files that just have hint tracks - these are called "fat hints " and are usually not playable locally. These are illegal in ISMA, so we won 't talk about them. To create hint tracks for a mp4 file is fairly simple with the mp4creator program. Just execute the: mp4creator -hint= &lt;track to hint track number&gt; &lt;mp4file&gt; 示例 没有流化过的mp4文件，用mp4info查看文件信息(如果mp4info没有安装，就用apt-getinstall mp4info安装一下 ) 123456mp4info ./test.mp4 mp4info version 1.6./test.mp4:Track Type Info1 audio MPEG-4 AAC LC, 662.165 secs, 121 kbps, 48000 Hz2 video H264 Main@5.1, 662.562 secs, 1756 kbps, 640x368 @ 29.970025 fps hint音频： 1mp4creator -hint=1 ./test.mp4 (如果mp4creator没有安装，就用apt-get install mp4creator安装一下 ) hint视频 1mp4creator -hint=2 ./test.mp4 查看流化后的信息： 123456789mp4info ./test.mp4 mp4info version 1.6./test.mp4:Track Type Info1 audio MPEG-4 AAC LC, 662.165 secs, 121 kbps, 48000 Hz2 video H264 Main@5.1, 662.562 secs, 1756 kbps, 640x368 @ 29.970025 fps3 hint Payload mpeg4-generic for track 14 hint Payload H264 for track 2Tool: mp4creator 1.5.0.1]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql insert into和replace into以及insert ignore的区别]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%2F2015%2F01%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0-mysql%E4%B8%93%E9%A2%98-2015-01-22-mysql%E4%B8%89%E7%A7%8D%E6%8F%92%E5%85%A5%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[insert into into``` 表示插入数据，数据会检查主键(PrimaryKey),如果出现重复会报错；1234567891011121314151617181920212223242526272829***replace into***```replace into``` 表示插入替换数据，需求表中有```PrimaryKey```,或者```Unique```索引的话，如果数据库已经存在数据，则用新数据替换，如果没有数据效果跟```insert into```一样，```replace```语句会返回一个数，来指示受影响的行的数目，该数目时被删除和被插入的行数的和，如果对应一个单行```replace```该数为１，则一行被插入，同时没有行被删除，如果该数大于１，则在新行被插入前，有一个或者多个旧行被删除，如果表包含多个唯一索引，并且新行复制了在不同的唯一索引中的不同旧行的值，则有可能是一个单一行替换了多个旧行；***insert ignore into***```indert ignore```表示，如果中已经存在相同的记录，则忽略当前新数据；示例：```mysql create table test_table ( id int not null primary key, name varchar(20), age int ) insert into test_table (id,name,age) values (1,&quot;111&quot;,111); select * from test_table; insert ignore into test_table (id,name,age) values (1,&quot;222&quot;,11); select * from test_table; //因为id是主键，出现主键重复但使用了ignore则错误被忽略 replace into test_table (id,name,age) values (1,&quot;222&quot;,12); select * from test_table; //数据变成 1,&quot;222&quot;,12]]></content>
      <categories>
        <category>数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux下定时任务]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2015%2F01%2F22%2Flinux%E5%AD%A6%E4%B9%A0-2015-01-22-linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[crontab 定时任务命令 12345crontab命令选项 -U指定一个用户 -l列出某个用户的任务计划 -r删除某个用户的计划 -e编辑某个用户的任务(/var/) cron文件语法 分 小时 日 月 星期 命令 0-59 0-23 1-12 0-6 command 特殊符号含义: “*” 代表取值范围内的数字 “/“ 代表每 “-“ 代表从某个数字到某个数字 “,” 分开几个离散的数字 每个字段代表的含义如下: 字段 含义 minute 每小时的第几分钟执行该任务 hour 每天的第几个小时执行该任务 day 每月第几天执行该任务 month 每年的第几个月执行该任务 dayofweek 每周第几天执行该任务 command 指定要执行的程序 例子: 123456789105 * * * * ls 指定每小时的第五分钟执行一次ls命令30 5 * * * ls 指定每天5:30执行ls命令30 7 8 * * ls 执行每月8号7:30分执行ls命令30 5 8 6 * ls 每年的6月8号5:30执行ls命令30 6 * * 0 ls 指定每星期日的6:30执行ls命令[0代表星期天以此类推]30 3 10,20 * * ls 每月10号及20号的3:30执行命令ls[","用来链接多个不连续的时段]25 8-11 * * * ls 每天8-11点的第25分钟执行ls命令["-"用来链接连续的时段]*/15 * * * * ls 每15分钟执行一次ls命令[即每个小时的第0 15 30 45 60分钟执行ls命令]30 6 */10 * * ls 每隔10天6:30执行一次ls命令[即每月1,11,21,31日的6:30执行一次ls]50 7 * * * root run-parts /etc/cron.daily &#123;run-parts 参数表示,执行后面目录中的所有可执行文件&#125; 增加任务调度 在命令行输入:crontab -e 然后添加相应的任务,wq存盘退出; 直接编辑 /etc/crontab文件,即vi /etc/crontab,添加相应的任务; 查看调度任务 crontab -l //列出当前的所有调度任务 crontab -l u daodaoliang //列出用户daodaoliang所有调度任务 删除调度任务 crontab -r //删除所有任务调度工作]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql TIMESTAMPDIFF]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%2F2015%2F01%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0-mysql%E4%B8%93%E9%A2%98-2015-01-22-Mysql-TIMESTAMPDIFF%2F</url>
    <content type="text"><![CDATA[TIMESTAMPDIFF语法: 1TIMESTAMPDIFF(interval,datetime_expr1,datetime_expr2) 说明: 返回日期或者日期时间的表达式datetime_expr1和datetime_expr2之间的整数差,期结果的单位由interval参数给出,该参数必须时以下值的其中一个: FRAC_SECOND 毫秒 SECOND 秒 MINUTE 分钟 HOUR 小时 DAY 天 WEEK 星期 MONTH 月 QUARTER 季度 YEAR 年 TIMESTAMPADD语法： 1TIMESTAMPADD(interval,int_expr,datetime_expr) 说明：将整型表达式inter_expr天价到日期或者日期时间表达式datetime＿expr中，式中的interval和上下文中列举的取值时一样的结果]]></content>
      <categories>
        <category>数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[php mysql数据库处理]]></title>
    <url>%2FPHP%E5%AD%A6%E4%B9%A0%2F2015%2F01%2F20%2FPHP%E5%AD%A6%E4%B9%A0-2015-01-20-PHP-Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[PHP 数据库处理安装 首先安装mysql和php; 安装PHP5-mysql; 安装PHP5-gd; 链接到一个mysql 数据库 语法: 1mysql_connect(servername,username,password); 参数 描述 servername 可选,规定要链接服务器,默认是”localhost3306” username 可选,规定登陆所使用的用户名.默认值时拥有服务器进程的用户的名称 password 可选,规定登陆所用的密码,默认是”” 关闭链接 用法: 1mysql_close(connecttion); 示例: 1234567&lt;?php$con=mysql_connect("localhost","daodaoliang","123");if (!$con)&#123; die("coould not connect:".mysql_error());&#125;mysql_close($con);?&gt; 创建数据库和创建表 示例: 12345678910111213141516171819&lt;?php $con = mysql_connect("localhost","daodaoliang","123"); if (!$con)&#123; die("could not connect".mysql_error()); &#125; if (mysql_query("create database my_db",$con)) &#123; echo "database created"; &#125; else &#123; echo "error creating database:".mysql_error(); &#125; mysql_select_db("my_db",$con); $sql = "create table test ( column varchar(10) not null auto_increment, column2 int(11), primary key(column) )"; mysql_query($sql,$con); mysql_close($con);?&gt; 从数据库中获取数据 示例: 12345678910111213141516171819202122&lt;?php $con = mysql_connect("localhost","daodaoliang","123"); if (!$con) &#123; die("could not connect :".mysql_error()); &#125; mysql_select_db("my_db",$con); $result = mysql_query("select * from test_table"); echo "&lt;table border = '1'&gt; &lt;tr&gt; &lt;th&gt;column&lt;/th&gt; &lt;th&gt;eloumn2&lt;/th&gt; &lt;/th&gt; "; while ($row = mysql_fetch_array($result))&#123; echo "&lt;tr&gt;"; echo "&lt;td&gt;".$row['column']."&lt;/td&gt;"; echo "&lt;td&gt;".$row['column2']."&lt;/td&gt;"; echo "&lt;/tr&gt;" &#125; echo "&lt;/table&gt;"; mysql_close($con);?&gt;]]></content>
      <categories>
        <category>PHP学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[php文件处理]]></title>
    <url>%2FPHP%E5%AD%A6%E4%B9%A0%2F2015%2F01%2F19%2FPHP%E5%AD%A6%E4%B9%A0-2015-01-19-PHP%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[PHP 文件处理PHP Open File —- fopen() 说明： fopen 的第一个参数包含被打开的文件名，第二个参数规定打开文件的模式，如果fopen()没能打开指定文件，下面的例子回升呈一段消息： 1234&lt;?php$myfile = fopen("daodaoliang.txt",'r') or die("Unable to open file");fclose($myfile);?&gt; 文件打开模式如下： 模式 描述 r 打开文件为只读,文件指针在文件的开头开始 w 打开文件为只写,删除文件的内容或创建一个新的文件，如果他不存在．文件指针在文件的开头开始 a 打开文件为只写，文件中的现有数据会被保留，文件指针在文件结尾开始，创建新的文件，如果文件不存在 x 创建新文件为只写，返回false和错误，如果文件已存在 r+ 打开文件为读写方式，文件指针在文件开头开始 w+ 打开文件为读写，删除文件内容或创建新文件，如果它不存在，文件指针在文件开头开始 a+ 打开文件为读写，文件中已有的数据会被保留，文件指针在文件结尾开始，创建新文件，如果他不存在 x+ 创建新文件为读写，返回false和错误．如果文件已存在 PHP fread() fread() 函数读取打开的文件 fread()的第一个参数包含待读取文件的文件名．第二个参数规定待读取的最大字节数． 示例： 123&lt;?php fread($myfile,filesize("daodoaliang.txt"));?&gt; PHP 检查文件结尾 feof() 函数检查是否已达到”end-of-file”(EOF) feof()对于遍历未知长度的数据很有用 示例： 1234567&lt;?php$myfile=fopen("daodaoliang.txt","r") or die("Unable to open file!");while(!feof($myfile)) &#123; echo fgets($myfile)."&lt;br&gt;";&#125;fclose($myfile);?&gt; PHP 文件上传 通过PHP的全局数组 12345678910111213141516171819202122第一个参数是表单的 input name,第二个下标可以是&quot;name&quot;,&quot;type&quot;,&quot;size&quot;,&quot;tmp_name&quot;,&quot;error&quot;:* $_FILES[&quot;file&quot;][&quot;name&quot;]-被上传文件的名称；* $_FILES[&quot;file&quot;][&quot;type&quot;]-被上传文件的类型；* $_FILES[&quot;file&quot;][&quot;size&quot;]-被上传文件的大小．以字节计；* $_FILES[&quot;file&quot;][&quot;tmp＿name&quot;]-存储在服务器的文件的临时副本名称* $_FILES[&quot;file&quot;][&quot;error&quot;]-由文件上传导致的错误代码示例：```html&lt;html&gt; &lt;body&gt; &lt;form action=&quot;upload_file.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;label for=&quot;file&quot;&gt;Filename&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324&lt;?phpif ((($_FILES["file"]["type"] == "image/gif") || ($_FILES["files"]["type"] == "image/jpeg") || ($_FILES["file"]["type"] == "image/pjpeg")) &amp;&amp; ($_FILES["file"]["size"] &lt; 20000))&#123; if ($_FILES["file"]["error"] &gt; 0)&#123; echo "Return Code:".$_FILES["file"]["error"]."&lt;br/&gt;"; &#125; else &#123; echo "Upload:".$_FILES["file"]["name"]."&lt;br/&gt;"; echo "Type:".$_FILES["file"]["name"]."&lt;br/&gt;"; echo "Size:".($_FILES["file"]["size"] / 1024)."&lt;br/&gt;"; echo "Temp file:".$_FILES["file"]["temp_name"]."&lt;br/&gt;"; if (file_exists("upload/".$_FILES["file"]["name"]))&#123; echo $_FILES["file"]["name"]."already exists."; &#125; else &#123; move_upload_file($_FILES["file"]["tmp_name"],"upload/".$_FILES["file"]["name"]); echo "Store in: "."upload/".$_FILES["file"]["name"]; &#125; &#125;&#125; else &#123; echo "Invalid file";&#125;?&gt; PHP 文件引用 include 和 require include 语句引用某个文件并且PHP无法找到它时，脚本会继续执行； require 语句引用某个文件并且PHP无法找到它时，脚本会终止运行； 示例： test.php 1234&lt;?php$daodaoliang = "xiaobai";$wangxiaowei = "wangxiaowei";?&gt; 1234&lt;?phpinclude "test.php";echo "daodaoliang:".$daodaoliang."wangxiaowei:".$wangxiaowei;?&gt;]]></content>
      <categories>
        <category>PHP学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[php异常]]></title>
    <url>%2FPHP%E5%AD%A6%E4%B9%A0%2F2015%2F01%2F19%2FPHP%E5%AD%A6%E4%B9%A0-2015-01-19-PHP%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[PHP 异常处理暂时没有用到,先不用更新了o(╯□╰)o(就是这么任性,你咬我啊~)]]></content>
      <categories>
        <category>PHP学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[php时间处理]]></title>
    <url>%2FPHP%E5%AD%A6%E4%B9%A0%2F2015%2F01%2F17%2FPHP%E5%AD%A6%E4%B9%A0-2015-01-17-PHP%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[PHP 日期和时间PHP Date() 函数 PHP Date() 函数把时间戳格式化为更易读的日期和时间． 语法： 1date(format,timestamp); 参数 描述 format 必需，规定时间戳的格式 timestamp 可选，规定时间戳，默认是当前时间和日期 注释 时间戳时一种字符序列，他表示具体时间发生的日期和事件 format d - 表示月里的某天(01-31) m - 表示月(01-12) Y - 表示年(四位数) y - 表示年(两位数) h - 带有首位零的12小时格式 i - 带有首位零的分钟 s - 带有首位零的秒(0-59) a - 小写的午前和午后 时区处理 如果从代码返回的时不正确的时间，有可能时因为您的服务器位于其他国家或者被设置为不同时区，因此，如果您需要基于具体位置的准确时间，您可以设置要用的时区 示例： 1234&lt;?phpdate_default_timezone_set("Asia/Shanghai");echo "当前时间时 "．date('h:i:s');?&gt; mktime()创建日期 date() 函数中可选的时间戳参数规定时间戳，如果没有规定时间戳，则使用当前的时间戳，00:00:00 GMT)12345语法：```php mktime(huor,minute,second,month,day,year); 实例： 1234&lt;?php $d = mktime(9,31,21,30,1,2015); echo "创建的日期是：".date(y-m-d h-i-s,$d);?&gt; 通过字符串创建日期 语法： 1strtotime(time,now); 实例： 1234&lt;?php $d=strtotime("10:38pm April 15 2015"); echo "创建的日期是：".date("y-m-d h:i:s",$d);?&gt;]]></content>
      <categories>
        <category>PHP学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[php运算逻辑说明]]></title>
    <url>%2FPHP%E5%AD%A6%E4%B9%A0%2F2015%2F01%2F16%2FPHP%E5%AD%A6%E4%B9%A0-2015-01-16-PHP%E8%BF%90%E7%AE%97%E9%80%BB%E8%BE%91%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[PHP 运算逻辑说明PHP if…elseif…else 语句 示例说明: 123456789&lt;?phpif(condition_001)&#123; 语句;&#125; elseif (condition_002)&#123; 语句;&#125; else &#123; 语句;&#125;?&gt; PHP Switch语句 示例说明: 123456789101112131415&lt;?phpswitch (expression)&#123;case label1: code to be executed if expression = label1; break;case label2: code to be executed of expression = label2; break;default: code to be executed if expression is different from both label1 and label2;&#125;?&gt; 注意这个匹配语句不仅仅匹配数值和逻辑符类型,还可以匹配字符串类型; PHP while语句 示例: 123456&lt;?phpwhile (条件为真)&#123; 要执行的代码;&#125;?&gt; PHP for 语句 示例: 12345&lt;?phpfor(init counter; test counter; increment counter)&#123; code to be executed;&#125;?&gt; 参数: init counter:初始化循环计数器的值 test counter: 评估每个循环迭代,如果值为TRUE.继续循环,如果它的值为FALSE,循环结束. increment counter : 增加循环计数器的值 PHP foreach 语句 foreach 循环只适用于数据,病用于便利数组中的每个键/值对; 示例: 12345&lt;?phpforeach ($arrary as $value)&#123; code to be executed;&#125;?&gt; PHP 函数语句 在PHP中创建用于定义函数 示例: 1234567891011&lt;?phpfunction functionName()&#123; 要执行的代码;&#125;**注意**:* 定义函数的声明需要以"function"开头;* 函数名能够以字母或者下划线(而非数字);* 函数名对大小写敏感(变量名字也是对大小写敏感的,PHP内建关键字不区分大小写)?&gt; PHP 函数参数 示例1: 12345678&lt;?phpfunction setHeight($minHeight=50)&#123; echo "The height is : $minHeight &lt;br&gt;";&#125;setHeight(350);setHeight(); //将使用默认参数50?&gt;]]></content>
      <categories>
        <category>PHP学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[php表单处理]]></title>
    <url>%2FPHP%E5%AD%A6%E4%B9%A0%2F2015%2F01%2F16%2FPHP%E5%AD%A6%E4%B9%A0-2015-01-16-PHP%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[表单处理一个简单的表单 123456789&lt;html&gt; &lt;body&gt; &lt;form action="welcome.php" method="post"&gt; Name: &lt;input type="text" name="name"&gt;&lt;br&gt; E-mail: &lt;input type="text" name="email"&gt;&lt;br&gt; &lt;input type="submit"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; welcome.php脚本源码 123456&lt;html&gt; &lt;body&gt; Welcom &lt;?php echo $_POST['name'];?&gt;&lt;br&gt; Your email address is:&lt;?php echo $_POST['email'];?&gt; &lt;/body&gt;&lt;/html&gt; GET vs POST GET 和 POST 都创建数组(例如，array(key=&gt;balue,key2=&gt;value2,key3=&gt;value3,…)).次数组包含键/值对，其中的键时表单控件的名称，而值时来自用户输入的数据． GET 和 POST 被视作$_GET 和 $_POST.它们是超全局变量，这意味着对他们的访问无需考虑作用域，无需特殊代码，能够从任何函数,类，或者文件访问它们； $_GET是通过URl参数传递到当前脚本的变量数组； $_POST是通过HTTP POST 传递到当前脚本的变量数组； 带有验证的表单 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; .error &#123;color:#FF0000;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;?php $nameErr = $emailErr = $genderErr = $websiteErr = ""; $name = $email = $gender = $comment = $website = ""; if ($_SERVER[REQUEST_METHOD] == "POST") &#123; if (empty($_POST['name']))&#123; $nameErr = "姓名时必填的"; &#125; else &#123; $name = test_input($_POST['name']); &#125; if (empty($_POST['email'])) &#123; $emailErr = "电邮是必填的"; &#125; else &#123; $email = test_input($_POST['email']); &#125; if (empty($_POST['website'])) &#123; $website = ""; &#125; else &#123; $website = test_input($_POST['website']); &#125; if (empty($_post['comment'])) &#123; $comment = ""; &#125; else &#123; $commment = test_input($_POST['comment']); &#125; if (empty($_POST['gender'])) &#123; $genderErr = "性别是必须的"； &#125; else &#123; $gender = test_input($_POST['gender']); &#125; &#125; function test_input($data) &#123; $data = trim($data); $data = stripslashes($data); $data = htmlspecoalchars($data); return $data; &#125; ?&gt; &lt;h2PHP 测试例子&lt;/h2&gt; &lt;p&gt;&lt;span class="error"&gt; * 必需字段&lt;/span&gt;&lt;/p&gt; &lt;form method = "post" action = "&lt;?php echo htmlspecialchars($_SERVER[PHP_SELF]);?&gt;"&gt; 姓名：&lt;input type = "text" name = "name"&gt; &lt;span class = "error"&gt; * &lt;?php echo $nameErr;?&gt; &lt;/span&gt; &lt;br&gt;&lt;br&gt; 电邮：&lt;input type = "text" name = "email"&gt; &lt;span class = "error"&gt;* &lt;?php echo $emailErr;?&gt; &lt;/span&gt; &lt;br&gt;&lt;br&gt; 网址：&lt;input type = "text" name = "website"&gt; &lt;span class = "error"&gt;&lt;?php echo $websiteErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; 评论：&lt;testarea name = "comment" rows = "5" cols = "40"&gt;&lt;/textarea&gt; &lt;br&gt;&lt;br&gt; 性别： &lt;input type = "radio" name="gender" value="female"&gt;女性 &lt;input type = "radio" name="gender" value="male"&gt;男性 &lt;span class="error"&gt;* &lt;?php echo $genderErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; &lt;input type = "submit" name = "submit" value = "提交"&gt; &lt;/form&gt; &lt;?php echo "&lt;h2&gt;您的输入：&lt;/h2&gt;"; echo $name; echo "&lt;br&gt;"; echo $email; echo "&lt;br&gt;"; echo $website; echo "&lt;br&gt;"; echo $comment; echo "&lt;br&gt;"; echo $gender; ?&gt; &lt;/body&gt;&lt;/html&gt; PHP - 验证 Name,E-mail,以及URL 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?php$nameErr = $emailErr = $genderErr = $websiteErr = "";$name = $email = $gender = $comment = $website = "";if ($_SERVER["REQUEST_METHOD"] == "POST")&#123; if (empty($_POST['name']))&#123; $nameErr = "name is required"; &#125; else &#123; $name = test_input($_POST['name']); if (!preg_match("/^[a-zA-Z ]*$/",$name)) &#123; $nameErr = "Only letters and white space allowed"; &#125; &#125; if (empty($_POST['email']))&#123; $emailErr = "Email is required"; &#125; else &#123; #email = test_input($_POST['email']); if (!preg_match("/([\w\-]+\@[\w\-]+\.[\w\-]+)/",$email)) &#123; $emailErr = "Invaild email format"; &#125; &#125; if (empty($_POST['website']))&#123; $website = ""; &#125; else &#123; $website = test_input($_POST['website']); if (!preg_match("/\b(?:(?:https?|ftp):\/\/|www\.)[-a-z0-9+&amp;@#\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\/%=~_|]/i",$website)) &#123; $websiteErr ＝"Invaild URL"; &#125; &#125; if (empty($_POST['comment'])) &#123; $comment = ""; &#125; else &#123; $comment = test_input($_POST['comment']); &#125; if (empty($_POST['gender'])) &#123; $genderErr = "Gender is required"; &#125; else &#123; $gender = test_input($_POST['gender']); &#125;&#125;?&gt;]]></content>
      <categories>
        <category>PHP学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[php数组]]></title>
    <url>%2FPHP%E5%AD%A6%E4%B9%A0%2F2015%2F01%2F16%2FPHP%E5%AD%A6%E4%B9%A0-2015-01-16-PHP%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[在PHP 中创建数组在 PHP 中,array()函数用于创建数组: 1array(); 在 PHP 中,有三种数组类型: 123456789* ```关联数组```-带有指定键的是数组* ```多维数组```-包含一个或多个数组的数组索引数组示例:```php&lt;?php$cars=array(&quot;volvo&quot;,&quot;BMW&quot;,&quot;SAAB&quot;);?&gt; 或者 123$car[0]="volov";$car[2]="BMW";$car[3]="SAAB"; 关联数组示例: 123&lt;?php$age=array("daodaolang"=&gt;"10","wangxiaowei"=&gt;"12");?&gt; 或者 1234&lt;?php$age["daodaoliang"] = "23";$age["wangxiaowei"] = 22;?&gt; 遍历数组遍历索引数组 123456&lt;?php$test_array = array("daodaoliang","test","test2");foreach($test_array as $value)&#123;echo $value;&#125;?&gt; 或 123456&lt;?php$test_array = array("test1","test2","test3");for($index=0;$index &lt; count($test_array);++$index)&#123; echo $test_array[$index];&#125;?&gt; 遍历索引数组 123456&lt;?php$age=array("daodaoliang"=&gt;23,"wangxiaowei"=&gt;34);foreach($age as $key =&gt; $value)&#123; echo "key=".$x."value=".$value;&#125;?&gt; PHP 数据排序 sort() 以剩下对数组进行排序 rsprt() 以降序对数组排序 asort() 根据值,以升序对关联数组进行排序 ksort() 根据健,以升序对关联数组进行排序 arosrt() 根据值,以降序对关联书序进行排序 krsort() 根据健,以降序对关联数组进行排序]]></content>
      <categories>
        <category>PHP学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[php超全局变量]]></title>
    <url>%2FPHP%E5%AD%A6%E4%B9%A0%2F2015%2F01%2F16%2FPHP%E5%AD%A6%E4%B9%A0-2015-01-16-PHP%E8%B6%85%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[PHP 全局变量-超全局变量PHP 中的许多预定义变量都是”超全局的”,这意味着他们在一个脚本的全部作用域都可用.在函数或方法中无需执行 $variable```,就可以访问他们.1234这些超全局变量是:* ```$GLOBALS 1* ```$_REQUEST 1* ```$_GET 1* ```$_ENV 1* ```$_SESSION $GLOBAL —引用全局作用域中可用的全部变量 这种全局变量用于在PHP脚本中的任意未知访问全局变量(从函数或方法中均可).PHP在名为$GLOBAL[index]的数组中存储了所有的全局变量,变量的名字就是数组的键.123456789101112131415示例:```php&lt;?php$x = 75;$y = 25;function addition()&#123; $GLOBALS[&apos;z&apos;] = $GLOBALS[&apos;x&apos;] + $GLOBALS[&apos;y&apos;];&#125;addition();echo $z;?&gt; $_SERVER $_SERVER 这种超全局变量保存关于报头,路径和脚本位置的信息. 元素/代码 描述 $_SERVER[‘PHP_SELF’] 返回当前执行脚本的文件名 $_SERVER[‘GATWAY_INTERFACE’] 返回服务器使用的CGI规范的版本 $_SERVER[‘SERVER_ADDR’] 返回当前运行脚本所在服务器的IP地址 $_SERVER[‘SERVER_NAME’] 返回当前运行脚本所在服务器的主机名（比如 daodaoliang.github.io） $_SERVER[‘SERVER_SOFTWARE’] 返回服务器标识字符串(比如Apache/2.2.24) $_SERVER[‘SERVER_PROTOCOL’] 返回当前通信协议的名称和版本(例如：”HTTP/1.0”) $SERVER[‘REQUEST_METHOD’] 返回访问页面使用的请求方法(例如POST) $SERVER[‘REQUEST_TIME’] 返回请求开始时间戳例如1575457898 $SERVER[‘QUERY_STRING’] 返回查询字符串，如果时通过查询字符串访问此页面 $SERVER[‘HTTP_ACCEPT’] 返回来自当前请求的请求头 $SERVER[‘HTTP_ACCEPT_CHARSET’] 返回来自当前请求的accept＿charset头(例如 utf-8,ISO-8859-1) $SERVER[‘HTTP_HOST’] 返回当前请求的Host头 $SERVER[‘HTTP_REFERER’] 放回当前页面完整的ＵＲＬ(不可靠，因为不是所有用户代理都支持) $SERVER[‘HTTPS’] 是否通过安全HTTP协议查询脚本 $SERVER[‘REMOVE_ADDR’] 返回浏览当前页面的用户的IP地址 $SERVER[‘REMOVE_HOST’] 返回当前页面的用户的主机名 $SERVER[‘REMOVE_PORT’] 返回用户级其上链接到ＷＥＢ服务器所使用的端口号 $SERVER[‘SCRIPT_FILENAME’] 当前当前执行脚本的绝对路径 $SERVER[‘SERVER_ADMIN’] 该值致命了Apache服务器配置文件中的SERVR_ADMIN参数 $SERVER[‘SERVER_PORT’] 返回服务器使用的端口，默认时’80’ $SERVER[‘SERVER_SIGNATURE’] 返回服务器版本和虚拟主机名 $SERVER[‘PATH_TRANSLATED’] 当前脚本所在文件系统(非文档根目录)的基本路径 $SERVER[‘SCRIPT_NAME’] 返回当前脚本的路径 $SERVER[‘SCRIPT_URL’] 返回当前页面的URL _REQUEST PHP $＿REQUEST 用于收集HTML 表单提交的数据 示例： 123456789101112&lt;html&gt;&lt;body&gt;&lt;form method="post" action="&lt;?php echo $_SERVER[PHP_SELF];?&gt;"&gt;Name:&lt;input type="text" name="fname"&gt;&lt;input type="submit"&gt;&lt;/form&gt;&lt;?php$name = $_REQUEST['fname'];echo $name?&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>PHP学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[php运算符说明]]></title>
    <url>%2FPHP%E5%AD%A6%E4%B9%A0%2F2015%2F01%2F15%2FPHP%E5%AD%A6%E4%B9%A0-2015-01-15-PHP%E8%BF%90%E7%AE%97%E9%80%BB%E8%BE%91%E7%AC%A6%E5%8F%B7%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[PHP 算数运算符 运算符 名称 例子 结果 + 加法 $x + $y $x 与 $y 求和 - 减法 $x - $y $x 与 $y 的差值 * 乘法 $x * $y $x 与 $y 的乘积 / 除法 $x / $y $x 与 $y 的商数 % 模数 $X % $y $x 与 $y 的模数 PHP 赋值运算符 赋值 等同于 描述 x = y x = y 右侧表达式为左侧运算数设置数 x += y x = x + y 加 x -= y x = x - y 减 x *= y x = x * y 乘 x /= y x = x / y 除 x %= y x = x % y 模数 PHP 字符串运算符 运算符 名称 例子 结果 . 串接 $txt1 = “hello”; $txt2 = $txt1.”world”; 现在 $txt2 包含 “helloworld” .= 串接赋值 $txt1 = “hello”; $txt1 .= “world”; 现在 $txt1 包含 “helloworld” PHP 递增/递减运算符 运算符 名称 描述 ++$x 前递增 $x 加一递增,然后返回$x $x++ 后递增 返回$x 然后$x 加一递增 –$x 前递减 $x 减一递减 然后返回$x $x– 后递减 返回$x 然后$x 减一递减 PHP比较运算符 运算符 名称 例子 结果 == 等于 $x == $y 如果 $x 等于 $y 则返回 true === 全等(完全相同) $x === $y 如果 $x 等于 $y 且他们类型相同则返回true != 不等于 $x != $y 如果 $x 不等于 $y 则返回true &lt;&gt; 不等于 $x != $y 如果 $x 不等于 $y 则返回true !== 不全等(完全不同) $x !== $y 如果$x 不等于 $y 则返回true &gt; 大于 $x &gt; $y 如果 $x 大于 $y 则返回true &lt; 小于 $x &lt; $y 如果 $x 小于 $y 则返回true &gt;= 大于等于 $x &gt;= $y 如果 $x 大于等于 $y 则返回true &lt;= 小于或等 $x &lt;= $y 如果 $x 小于等于 $y 则返回true PHP 逻辑运算符 运算符 名称 例子 结果 and 与 $x and $y 如果 $x 和 $y 都为true 则返回true or 或 $x or $y 如果 $x 或者 $y 有一个为true 则返回 true xor 异或 $x xor $y 如果$x和$y仅有一个为true则返回true &amp;&amp; 与 $x &amp;&amp; $y 如果$x 和 $y 都为true 则返回true ! 非 !$x 如果$x不为true则返回true]]></content>
      <categories>
        <category>PHP学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[php变量类型说明]]></title>
    <url>%2FPHP%E5%AD%A6%E4%B9%A0%2F2015%2F01%2F15%2FPHP%E5%AD%A6%E4%B9%A0-2015-01-15-PHP%E5%8F%98%E9%87%8F%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[PHP 变量1.变量的相关规则 变量以1234567891011121314151617* 变量名称必须以字母或者下划线开头,不能已数字开头* 变量名称只能包含字母数字字符和下划线(A-z,0-9以及_)* 变量名称对大小写敏感($x与$y是两个不同的变量)**注意** PHP变量对大小写敏感,PHP保留字对大小写不敏感,PHP变量时一门弱类型的语言;**2.PHP变量作用域** 在PHP中,可以在脚本的任意位置对变量进行声明,变量的作用域指的是变量能够被引用的那部分脚本,PHP有三种不容的变量作用域:* ```local```(局部)* ```global```(全局)* ```static```(静态)**注意** * 默认创建的变量都是```local 若是需要在函数内部访问全局的变量,则需要在函数内部声明123456789101112131415161718192021222324* 函数在执行完后会删除变量,若是想要不删除变量则需要定义```static```关键字**3.PHP数据类型*** 字符串* 整数* 浮点数* 逻辑* 数组* 对象* NULL**3.1字符串**字符串是字符序列,比如&quot;hello,world&quot;,字符串可以是引号内的任何文本,您可以使用单引号或双引号.```php&lt;?php$x = &quot;hello world!&quot;;echo $x;echo &quot;&lt;br&gt;&quot;;$x = &apos;hello world&apos;;echo $x;?&gt; 3.2 整数 可以用三种格式规定整数:十进制,十六进制(前缀是0x)或八进制(前缀0) 例如下(PHP中用12345678910111213141516171819```php&lt;?php$x = 1234;var_dump($x);echo &quot;&lt;br&gt;&quot;;$x = -1234;var_dump($x);echo &quot;&lt;br&gt;&quot;;$x = 0x1234c;var_dump($x);echo &quot;&lt;br&gt;&quot;;$x = 01234;var_dump($x);echo &quot;br&quot;;?&gt; 3.3 浮点数 12345678910111213&lt;?php$x = 10.123;var_dump($x);echo "&lt;br&gt;";$x = 2.4e3;var_dump($x);echo "&lt;br&gt;";$x = 8E-5;var_dump($x);echo "&lt;br&gt;";?&gt; 3.4 逻辑符 1234&lt;?php$x = true;$y = false;?&gt; 3.4 PHP 数组 实例: 1234&lt;?php$car = array("liujian" , "shi","shabi");var_dump($car);?&gt; 3.5PHP对象 对象是存储数据和数据处理的方法,类比其他语言的类. 123456789101112&lt;?phpclass Car&#123; var $color; function car($color = "green")&#123; $this-&gt;color = $color; &#125; function what_color()&#123; return $this-&gt;color; &#125;&#125;?&gt; 3.6 NULL值 用于初始化或者清空变量 12345&lt;?php$x = "hello world";$x = null;var_dump($x);?&gt; PHP 常量与变量不同,常量贯穿整个脚本时自动全局的,定义常量的方法如下: define() 1.首个参数定义常量的名称 2.第二个参数定义常量的值 3.可选的第三个参数规定常量名是否对大小写敏感,默认时false 实例: 1234&lt;?phpdrfine("test","IamTestData",true);echo test;?&gt;]]></content>
      <categories>
        <category>PHP学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python twisted模块之安装部署]]></title>
    <url>%2FPython%E5%AD%A6%E4%B9%A0%2F2015%2F01%2F14%2FPython%E5%AD%A6%E4%B9%A0-2015-01-14-python%E7%9A%84Twisted%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Twisted 相关资源 官方下载网址 Twisted 安装1sudo apt-get install python-twisted 服务端测试例子1234567891011121314151617181920212223242526272829303132333435363738394041import sysfrom twisted.internet.protocol import ServerFactoryfrom twisted.protocols.basic import LineReceiverfrom twisted.python import logfrom twisted.internet import reactorclass CmdProtocol(LineReceiver): delimiter = '\n' def connectionMade(self): self.client_ip = self.transport.getPeer()[1] log.msg("Client connection from %s" % self.client_ip) if len(self.factory.clients) &gt;= self.factory.clients_max: log.msg("Too many connections. bye !") self.client_ip = None self.transport.loseConnection() else: self.factory.clients.append(self.client_ip) def connectionLost(self, reason): log.msg('Lost client connection. Reason: %s' % reason) if self.client_ip: self.factory.clients.remove(self.client_ip) def lineReceived(self, line): log.msg('Cmd received from %s : %s' % (self.client_ip, line))class MyFactory(ServerFactory): protocol = CmdProtocol def __init__(self, clients_max=10): self.clients_max = clients_max self.clients = []if __name__ =="__main__" log.startLogging(sys.stdout) reactor.listenTCP(9999, MyFactory(2)) reactor.run()]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql基础知识]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%2F2015%2F01%2F13%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0-mysql%E4%B8%93%E9%A2%98-2015-01-13-Mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Mysql 数据类型1.整型 MySQL数据类型 含义(有符号) tinyint(m) 1个字节 范围(-128~127) smallint(m) 2个字节 范围(-32768~32767) mediumint(m) 3个字节 范围(-8388608~8388607) int(m) 4个字节 范围(-2147483648~2147483647) bigint(m) 8个字节 范围(+-9.22*10的18次方) 取值范围如果增加了unsigned,则最大值翻倍，如tinyint unsigned的取值范围为(0~256).int(m)里的m是表示select查询结果集中的显示宽度，并不影响实际的取值范围，没有影响到显示的宽度，不知道这个m有什么用。 2.浮点型(float和double) MySQL数据类型 含义 float(m,d) 单精度浮点型 8位精度(4字节) m总个数，d小数位 double(m,d) 双精度浮点型 16位精度(8字节) m总个数, d小数位 设一个字段定义为float(5,3) ,如果插入一个数123.456789，实际存的数据会是99.999,因为5-3=2,2为其整数部分最大长度。 3.定点数浮点型在数据库中存在的是近似值，而定点类型在数据库中存放的时精确值，decimal(m,d)参数m&lt;65是m&lt;65是总个数，d&lt;30且d&lt;m是小数位。 4.字符串(char,varchar,_test) MySQL数据类型 含义 char(n) 固定长度，最多255个字符 varchar(n) 固定长度，最多65535个字符 tinytext 可变长度，最多255个字符 text 可变长度，最多65535个字符 mediumtext 可变长度，最多2的24次方-1个字符 longtext 可变长度，最多2的32次方-1个字符 char 和 varchar： char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以char类型存储的字符串末尾不能有空格，varchar不限于此。 char(n) 固定长度，char(4)不管是存入几个字符，都将占用4个字节，varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)，所以varchar(4),存入3个字符将占用4个字节。 char类型的字符串检索速度要比varchar类型的快。 varchar和text： varchar可指定n，text不能指定，内部存储varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)，text是实际字符数+2个字节。 text类型不能有默认值。 varchar可直接创建索引，text创建索引要指定前多少个字符。varchar查询速度快于text,在都创建索引的情况下，text的索引似乎不起作用。 5.二进制数据(_Blob) _BLOB和_text存储方式不同，_TEXT以文本方式存储，英文存储区分大小写，而_Blob是以二进制方式存储，不分大小写。 _BLOB存储的数据只能整体读出。 _TEXT可以指定字符集，_BLOB不用指定字符集。 6.日期时间类型 MySQL数据类型 含义 date 日期 ‘2008-12-2′ time 时间 ’12:25:36′ datetime 日期时间 ‘2008-12-2 22:06:44′ timestamp 自动存储记录修改时间 若定义一个字段为timestamp，这个字段里的时间数据会随其他字段修改的时候自动刷新，所以这个数据类型的字段可以存放这条记录最后被修改的时间。 数据类型的属性 Mysql关键字 含义 NULL 数据列可包含NULL值 NOT NULL 数据列不允许包含NULL值 DEFAULT 默认值 PRIMARY KEY 主键 AUTO_INCREMENT 自动递增，适用于整数类型 UNSIGNED 无符号 CHARACTER SET name 指定一个字符集]]></content>
      <categories>
        <category>数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL语法学习]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%2F2015%2F01%2F08%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-2015-01-08-SQL%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1. TOP 子句SQLServer的例子 1select top number|percent column_name(s) from table_name; 其中top number代表几条数据,top number percent 代表百分之几的数据; 例如:前50%条 1SELECT TOP 50 PERCENT * FROM Persons; 例如:前50条 1SELECT TOP 50 * FROM Persons mysql 的例子 1SELECT column_name(s) FROM table_name LIMIT number; 例如:前50条 1select * from table limit 50; 2. SQL LIKE 操作符1select coloumn_name(s) from table_name where column_name like pattern; like 用在操作符用于在where子句中搜索列中的指定模式. 其中通配符部分解释 通配符 描述 % 替代一个或者多个字符 _ 仅替代一个字符 [charlist] 字符列表中的任何一个字符 [^charlist]或者[!charlist] 不在字符列表中的任何一个字符 3. IN 操作符IN操作符允许我们在where子句中规定多个值 1select column_name(s) from table_name in (value1,value2,value3); 4. 列或者表的指定别名(Alias)表的别名语法 1select column_name(s) from table_name as alias_name; 列的别名用法 1select column_name(s) as alias_name from table_name; 需要注意的时.列的别名在结果集中会有所体现; 5. SQL JOIN 语法 join类型 描述 inner join 如果表中有至少一个匹配,则返回行 left join 即使右表中没有匹配,也从左表中返回所有行 right join 即使左表中没有匹配,也从右表中返回所有行 full join 只要其中一个表存在匹配,就返回行 inner join 语法 1select column_name(s) from table_name1 inner join table_name2 on table_name1.column_name = table_name2_.column_name order by table_name1.column_name; left join语法 1select column_name(s) from table_name1 left join table_name2 on table_name1.column_name1 = table_name2.column_name2; right join 语法 1select column_name(s) from table_name1 right join table_name2 on table_name1.column1 = table_name2.column2; 6. SQL UNION 和 UNION ALLUNION 操作符用于合并两个或者多个select 语句的结果集, Union 内部的 select 语句必须有相同数量的列.列也必须有相似的数据类型.同时,每条select 语句中的列的顺序必须相同. 123select column_name(s) from table_name1union select column_name(s) from table_name2 注意 UINION ALL 命令和 UNION 命令几乎就是等效的,不过UNION ALL 命令会列出所有的值. 7. SQL SELECT INTO 语句SELECT INTO 语句从一个表中选择数据,然后吧数据插入另外一个表中.SELECT INTO 语句常用与创建表的备份复件或者用于对记录进行存档. 1select column_name(s) into table_name from old_tablename; data_type 数据类型 描述 integer(size) 仅容纳整数.在括号内规定数字的最大位数 int(size) 同上 smallint(size) 同上 tinyint(size) 同上 decimal(size,d) 容纳带有小数的数字,”size” 规定数字的最大位数,”d”规定小数点右侧的最大位数. numeric(size,d) 同上 char(size) 容纳固定长度的字符串(可容纳字母,数字以及特殊字符),在括号中规定字符串的长度 varchar(size) 容纳可变长度的字符串(可容纳字母,数字以及特殊字符),在括号中规定字符串的最大长度 date(yyyymmdd) 容纳日期 CREATE TABLE 语法1234567CREATE TABLE 表名(列名字 数据类型,列名字2 数据类型,列名字3 数据类型,...) SQL 约束(Constraints)NOT NULL NOT NULL 约束子昂之字段始终包含值,这意味着,如果不想字段添加值,就无法插入新纪录或者更新记录. unique 约束 unique 和 primary 约束的区别,都是进行唯一性约束,但是一张表只能有一个primary约束,但是可以有多个unique约束; mysql 例子 12345create table test_table(test_column int(12),unique (test_column)) sqlserver 例子 1234create table test_table(test_column int(10) unique) SQL INDEX 语句索引可以被创建的表中列上,以便于快速搞笑的查询数据,用户无法看到索引,他们只能被用来加速搜索/查询. 注意 更新一个包含索引的表需要比更新一个没有索引的表更多的时间,这是由于索引本身也需要更新,因此,理想的做法是仅仅在常常被搜索的列(以及表)上面创建索引. 1create index index_name on table_name (column_name) SQL 撤销索引,表以及数据库撤销索引 MS SQL 1drop index table_name.index_name; MySQL 1alter table table_name drop index index_name; 撤销表 1drop table 表名字 撤销数据库 1drop database 数据库名字 ALTER 语句alter table 用于在已有的表中添加,修改,删除列. 添加列的语法 1alter table table_name add column_name datatype 删除列的语法 1alter table table_name drop column column_name Auto-increment 语法我们通常希望在每次插入新纪录时,自动创建主键字段,可以使用auto-increment字段; Mysql 语法 123456create table test_table( column_name1 int not null auto_increment, column_name2 varchar(200) null, primary key (column_name1)) 注意 mysql的默认开始值为1,每条记录递增1.]]></content>
      <categories>
        <category>数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python 的日志logging模块学习]]></title>
    <url>%2FPython%E5%AD%A6%E4%B9%A0%2F2014%2F12%2F22%2FPython%E5%AD%A6%E4%B9%A0-2014-12-22-python%E7%9A%84%E6%97%A5%E5%BF%97logging%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1.简单的将日志打印到屏幕12345import logginglogging.debug('This is debug message')logging.info('This is info message')logging.warning('This is warning message') 屏幕上打印: WARNING:root:This is warning message 默认情况下，logging将日志打印到屏幕，日志级别为WARNING；日志级别大小关系为：CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG &gt; NOTSET，当然也可以自己定义日志级别。 2.通过logging.basicConfig函数对日志的输出格式及方式做相关配置123456789101112import logginglogging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s', datefmt='%a, %d %b %Y %H:%M:%S', filename='test.log', filemode='w') logging.debug('This is debug message')logging.info('This is info message')logging.warning('This is warning message') ./test.log 文件中内容为: &gt;Sun, 24 May 2009 21:48:54 demo2.py[line:11] DEBUG This is debug messageSun, 24 May 2009 21:48:54 demo2.py[line:12] INFO This is info messageSun, 24 May 2009 21:48:54 demo2.py[line:13] WARNING This is warning message logging.basicConfig函数各参数: &gt;filename: 指定日志文件名filemode: 和file函数意义相同，指定日志文件的打开模式，’w’或’a’format: 指定输出的格式和内容，format可以输出很多有用信息，如上例所示: %(levelno)s: 打印日志级别的数值 %(levelname)s: 打印日志级别名称 %(pathname)s: 打印当前执行程序的路径，其实就是sys.argv[0] %(filename)s: 打印当前执行程序名 %(funcName)s: 打印日志的当前函数 %(lineno)d: 打印日志的当前行号 %(asctime)s: 打印日志的时间 %(thread)d: 打印线程ID %(threadName)s: 打印线程名称 %(process)d: 打印进程ID %(message)s: 打印日志信息datefmt: 指定时间格式，同time.strftime()level: 设置日志级别，默认为logging.WARNINGstream: 指定将日志的输出流，可以指定输出到sys.stderr,sys.stdout或者文件，默认输出到sys.stderr，当stream和filename同时指定时，stream被忽略 3.将日志同时输出到文件和屏幕1234567891011121314151617181920import logginglogging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s', datefmt='%a, %d %b %Y %H:%M:%S', filename='test.log', filemode='w')##################################################################################################定义一个StreamHandler，将INFO级别或更高的日志信息打印到标准错误，并将其添加到当前的日志处理对象#console = logging.StreamHandler()console.setLevel(logging.INFO)formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')console.setFormatter(formatter)logging.getLogger('').addHandler(console)#################################################################################################logging.debug('This is debug message')logging.info('This is info message')logging.warning('This is warning message') 屏幕上打印: &gt;root : INFO This is info messageroot : WARNING This is warning message ./test.log日之中显示: &gt;Sun, 24 May 2009 21:48:54 demo2.py[line:11] DEBUG This is debug messageSun, 24 May 2009 21:48:54 demo2.py[line:12] INFO This is info messageSun, 24 May 2009 21:48:54 demo2.py[line:13] WARNING This is warning message 4.logging之日志回滚1234567891011import loggingfrom logging.handlers import RotatingFileHandler##################################################################################################定义一个RotatingFileHandler，最多备份5个日志文件，每个日志文件最大10MRthandler = RotatingFileHandler('myapp.log', maxBytes=10*1024*1024,backupCount=5)Rthandler.setLevel(logging.INFO)formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')Rthandler.setFormatter(formatter)logging.getLogger('').addHandler(Rthandler)################################################################################################ 从上例和本例可以看出，logging有一个日志处理的主对象，其它处理方式都是通过addHandler添加进去的。logging的几种handle方式如下： &gt;logging.StreamHandler: 日志输出到流，可以是sys.stderr、sys.stdout或者文件logging.FileHandler: 日志输出到文件日志回滚方式，实际使用时用RotatingFileHandler和TimedRotatingFileHandlerlogging.handlers.BaseRotatingHandlerlogging.handlers.RotatingFileHandlerlogging.handlers.TimedRotatingFileHandlerlogging.handlers.SocketHandler: 远程输出日志到TCP/IP socketslogging.handlers.DatagramHandler: 远程输出日志到UDP socketslogging.handlers.SMTPHandler: 远程输出日志到邮件地址logging.handlers.SysLogHandler: 日志输出到sysloglogging.handlers.NTEventLogHandler: 远程输出日志到Windows NT/2000/XP的事件日志logging.handlers.MemoryHandler: 日志输出到内存中的制定bufferlogging.handlers.HTTPHandler: 通过”GET”或”POST”远程输出到HTTP服务器 由于StreamHandler和FileHandler是常用的日志处理方式，所以直接包含在logging模块中，而其他方式则包含在logging.handlers模块中，上述其它处理方式的使用请参见python2.5手册！ 5.通过logging.config模块配置日志123456789101112131415161718192021222324252627282930313233343536373839404142#logger.conf###############################################[loggers]keys=root,example01,example02[logger_root]level=DEBUGhandlers=hand01,hand02[logger_example01]handlers=hand01,hand02qualname=example01propagate=0[logger_example02]handlers=hand01,hand03qualname=example02propagate=0###############################################[handlers]keys=hand01,hand02,hand03[handler_hand01]class=StreamHandlerlevel=INFOformatter=form02args=(sys.stderr,)[handler_hand02]class=FileHandlerlevel=DEBUGformatter=form01args=('myapp.log', 'a')[handler_hand03]class=handlers.RotatingFileHandlerlevel=INFOformatter=form02args=('myapp.log', 'a', 10*1024*1024, 5)###############################################[formatters]keys=form01,form02[formatter_form01]format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)sdatefmt=%a, %d %b %Y %H:%M:%S[formatter_form02]format=%(name)-12s: %(levelname)-8s %(message)sdatefmt= 例子1: 123456789import loggingimport logging.configlogging.config.fileConfig("logger.conf")logger = logging.getLogger("example01")logger.debug('This is debug message')logger.info('This is info message')logger.warning('This is warning message') 例子2: 123456789import loggingimport logging.configlogging.config.fileConfig("logger.conf")logger = logging.getLogger("example02")logger.debug('This is debug message')logger.info('This is info message')logger.warning('This is warning message') 6.logging是线程安全的]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql用户账号操作]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%2F2014%2F12%2F21%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0-mysql%E4%B8%93%E9%A2%98-2014-12-21-Mysql%E7%94%A8%E6%88%B7%E8%B4%A6%E5%8F%B7%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[作者: daodaoliang 日期: 2016-5-18 版本: 0.0.2 邮箱: daodaoliang@yeah.net 0x01 新建用户 登陆mysql 1mysql -u root -p 创建用户 1234567mysql&gt; insert into mysql.user(Host,User,Password) values("localhost","用户名",password("密码"));ormysql&gt; CREATE USER 'username'@'host' IDENTIFIED BY 'password';mysql&gt;flush privileges; 这样就创建了用户,可以登陆试一下; 0x02 为用户授权登陆mysql 1mysql -u root -p 授权用户拥有数据库的所有权限。 12grant all privileges on *.* to 用户名@'地址' identified by '密码';flush privileges; 指定部分权限的话,可以这样子写: 12grant select,update on *.* to 用户名@'地址' identified by '密码';flush privileges; 特别注意: 格式：grant 权限 on 数据库名.表名 to 用户@登录主机 identified by “用户密码”; @ 后面是访问mysql的客户端IP地址（或是 主机名） % 代表任意的客户端，如果填写 localhost 为本地访问（那此用户就不能远程访问该mysql数据库了）。 0x03 删除用户登陆mysql后 12mysql&gt;DELETE FROM user WHERE User="phplamp" and Host="localhost";mysql&gt;flush privileges; 或者 1drop user daodaoliang@&apos;%&apos; 0x04 修改指定用户密码 用UPDATE直接编辑user表 12mysql&gt;update mysql.user set password=password('新密码') where User="phplamp";mysql&gt;flush privileges; 用mysqladmin 123mysqladmin -u root password "newpass"# 若设置过root密码,采用如下方法mysqladmin -u root password oldpass "newpass" 用SET PASSWORD命令 1SET PASSWORD FOR 'root'@'localhost' = PASSWORD('newpass'); 0x05 修改或者忘记ROOT密码 停止数据库服务 1/etc/init.d/mysql stop 跳过权限表安全启动 1mysqld_safe --user=mysql --skip-grant-tables --skip-networking &amp; 重新登录mysql 1mysql -u root mysql 修改root密码 12UPDATE user SET Password=PASSWORD('my_password') where USER='root'; FLUSH PRIVILEGES; 重新启动mysql服务 1/etc/init.d/mysql restart 0x06 重命名用户账号1rename user daodaoliang@&apos;%&apos; to nami@&apos;%&apos;]]></content>
      <categories>
        <category>数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux下进程的结束]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2014%2F12%2F21%2Flinux%E5%AD%A6%E4%B9%A0-2014-12-22-%E6%A0%B9%E6%8D%AE%E8%BF%9B%E7%A8%8B%E5%90%8D%E6%9D%80%E6%AD%BB%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[根据进程名杀死进程 方法一 1kill -9 $(ps -ef|grep 进程名关键字|gawk '$0 !~/grep/ &#123;print $2&#125;' |tr -s '\n' ' ') 这个是利用管道和替换将 进程名对应的进程号提出来作为kill的参数。 方法二 1killall 进程关键字 停止和重启有时候只想简单的停止和重启进程。如下： 获取进程的PID或者PPID 1$(ps -ef|grep 进程名关键字|gawk '$0 !~/grep/ &#123;print $2&#125;' |tr -s '\n' ' ') 然后 1kill -HUP 进程PID 绝杀这个强大和危险的命令迫使进程在运行时突然终止，进程在结束后不能自我清理。危害是导致系统资源无法正常释放，一般不推荐使用，除非其他办法都无效。 当使用此命令时，一定要通过ps -ef确认没有剩下任何僵尸进程。只能通过终止父进程来消除僵尸进程。如果僵尸进程被init收养，问题就比较严重了。杀死init进程意味着关闭系统。 如果系统中有僵尸进程，并且其父进程是init，而且僵尸进程占用了大量的系统资源，那么就需要在某个时候重]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux软连接和硬链接的学习]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2014%2F12%2F19%2Flinux%E5%AD%A6%E4%B9%A0-2014-12-19-linux%E8%BD%AF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述：&gt;linux的inode这里就不在重复赘述，若感兴趣可以自行google或者baidu,在linux系统中可以通过ln命令对一个已经存在的文件在建立一个新的链接，而不复制文件的内容，链接有软连接和硬链接之分。 硬链接： 硬链接指通过索引节点来进行的链接，源文件名和链接文件名都指向相同的物理地址，目录不能有硬链接，硬链接不能跨越文件系统(不能跨越不同的分区)文件再磁盘中只有一个拷贝，节省硬盘空间，防止文件被误删，之删除一个链接并不影响索引节点本身和其他连接，只有最后一个链接被删除以后文件数据块以及目录的链接才会被释放，才算是真正的被删除； 软链接 软链接是一种特殊的文件，作用可以理解为一个指针，作用在这个文件上的操作出了删除都直接转向实际指向文件，类似windows的快捷方式； ln命令详解 1234567891011121314ln [options] source dist，其中 option 的格式为 : [-bdfinsvF] [-S backup-suffix] [-V &#123;numbered,existing,simple&#125;] [--help] [--version] [--] -f : 链结时先将与 dist 同档名的档案删除 -d : 允许系统管理者硬链结自己的目录 -i : 在删除与 dist 同档名的档案时先进行询问 -n : 在进行软连结时，将 dist 视为一般的档案 -s : 进行软链结(symbolic link) -v : 在连结之前显示其档名 -b : 将在链结时会被覆写或删除的档案进行备份 -S SUFFIX : 将备份的档案都加上 SUFFIX 的字尾 -V METHOD : 指定备份的方式 --help : 显示辅助说明 --version : 显示版本 &gt;说明 : Linux/Unix 档案系统中，有所谓的连结(link)，我们可以将其视为档案的别名，而连结又可分为两种 : 硬连结(hard link)与软连结(symbolic link)，硬连结的意思是一个档案可以有多个名称，而软连结的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬连结是存在同一个档 案系统中，而软连结却可以跨越不同的档案系统。ln source dist 是产生一个连结(dist)到 source，至于使用硬连结或软链结则由参数决定。不论是硬连结或软链结都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[InnoSetup提升系统管理员权限]]></title>
    <url>%2F%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86%2F2014%2F11%2F26%2F%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86-2014-11-26-InnoSetup%E6%8F%90%E5%8D%87%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[在12&gt; PrivilegesRequired=admin12345找到```INNO```安装目录下的```SetupLdr.e32```文件(其实就是一个exe程序),将程序中的```Manifest```内的 &gt;``` &lt;requestedExecutionLevel level=&quot;asInvoker&quot; uiAccess=&quot;false&quot;/&gt;&lt;/requestedPrivileges&gt; 改为 &gt;level="requireAdministrator" uiAccess="false"/> ```12345678910此处需要一个工具才能修改：Resource Hacker**应用程序运行时申请管理员权限，如下图所示即可：**![示意图](/res/img/blog/程序打包/2014-04-04_151006.png)**或者在pro中添加：**&gt; QMAKE_LFLAGS += /MANIFESTUAC:”level=’requireAdministrator’uiAccess=’false’”```]]></content>
      <categories>
        <category>项目工程管理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[shell学习简介]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F2014%2F11%2F07%2Flinux%E5%AD%A6%E4%B9%A0-2014-11-07-shell%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[学习背景]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql给用户赋予最高权限]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%2F2014%2F11%2F07%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0-mysql%E4%B8%93%E9%A2%98-2014-11-07-Mysql%E7%BB%99%E7%94%A8%E6%88%B7%E8%B5%8B%E4%BA%88%E6%9C%80%E9%AB%98%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[给予Root用户最高权限 mysql 1449 ： The user specified as a definer (‘root’@’%’) does not exist 解决方法 12345mysql&gt; grant all privileges on *.* to root@"%" identified by "."; Query OK, 0 rows affected (0.00 sec)mysql&gt; flush privileges; Query OK, 0 rows affected (0.00 sec)]]></content>
      <categories>
        <category>数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CentOS6.5升级Python版本]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2014%2F11%2F07%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2014-12-16-CentOS6-5%E5%8D%87%E7%BA%A7Python%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[查看服务器端的python 版本 1python -V 显示： 1python 2.6.6 下载Python-2.7.9 1wget https://www.python.org/ftp/python/2.7.9/Python-2.7.9.tgz --no-check-certificate 解压更改工作目录 12tar zxvf Python-2.7.9.tgzcd Python-2.7.9 安装 12345./configuremake allmake installmake cleanmake distclean 查看版本信息 1/usr/local/bin/python2.7 -V 建立软连接，是系统默认的python 指向python2.7 12mv /usr/bin/python /usr/bin/python2.6.6ln -s /usr/local/bin/python2.7 /usr/bin/python 重新检验python 版本 1python -V 修改yum和iBUS的python版本 yum配置 系统 Python 软链接指向 Python2.7 版本后，因为yum是不兼容 Python 2.7的，所以yum不能正常工作，我们需要指定 yum 的Python版本 1vi /usr/bin/yum 将文件头部的： 1#!/usr/bin/python 改成 1#!/usr/bin/python2.6.6 iBUS配置 分别用 vi 打开下面两个文件，找到 exec python 那一行，把exec python 改为 exec python2.6 保存，重启。 12vi /usr/bin/ibus-setupvi /usr/libexec/ibus-ui-gtk]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[为人处世的细节(转自知乎)]]></title>
    <url>%2F%E5%BF%83%E4%B8%96%E7%95%8C%2F2014%2F11%2F07%2F%E6%96%B0%E4%B8%96%E7%95%8C-2014-11-07-%E4%B8%BA%E4%BA%BA%E5%A4%84%E4%B8%96%E7%9A%84%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[哪里拿的东西放回哪儿去。 不随地吐痰。打喷嚏要遮住口鼻。 不说话大声，不打电话大声，办公室接私人电话要出去。 不八卦，不对任何人妄加评论。 不问蠢问题，比如：你工资多少？你有女/男朋友吗？怎么还不结婚？你们xx那里一定很xx吧？ 不是很熟的人不要问私人电话号码/微信/邮箱等。 走路靠边走，给走的快的人让路。 走路不玩儿手机/看书。 上地铁/公交如果站着的话，而且人多，把背包摘下来放地上或者背在胸前。 办公室里手机静音。 培养环绕式目光，不横冲直撞，周围有人/车什么的要注意点。你说你因为走路玩儿手机而踩到别人了还不知道道歉算怎么回事？ 地铁先下后上，公交前门上后门下。 打伞走路的时候注意点儿周围，遇到身高差距大的尤其注意。 走路的时候突然要停下来的话注意缓冲，以免后面的人撞到你。 饭前便后要洗手，用香皂/洗手液。(这个我实在无力吐槽…) 学会收发邮件。标点，大小写什么的很重要。邮件内容按金字塔原则写，最重要的放前面。学会利用抄送功能，或者密送功能。检查邮件要频繁。 说话讲重点，礼貌用语可以有，但是不要说废话，比如：怎么说呢？其实吧，我是这样看的，事情是这样的，这个问题我是这样想的，以前遇到过类似的问题，那个时候…烦死！ 用！除！臭！剂！或！者！香！水！！很多人不知道自己身上有味道是吧？很多人以为只有狐臭才算味道是吧？ 别总麻烦别人，麻烦过之后要谢谢，并且学会自己做。并且，麻烦别人的时候别道德绑架，又撒娇又诉苦的，弄的别人不帮你好像是犯错误一样。没有谁一定要帮你。 学会合理委婉地拒绝别人。碍于面子大包大揽地帮忙对谁都不好。 如果有人追求你，你不喜欢，赶紧拒绝，别暧昧。谁跟你拉大锯呢？ 多读书。它改变不了你的气质，但是可以改变你的人生观。但是不要酸腐。 不要和人强行讨论别人不喜欢的话题。 不要逮谁跟谁诉苦。 对待服务员的态度真的很影响我对一个人的判断。 不提当年勇，不吹牛逼，“我一朋友blablabla…”, “我关注一牛人blablabla”. 不炫富， 不哭穷。 不要以为外国人都不会汉语，人在你旁边呢你就议论。 不盯着人看，无论这个人多么英俊/美丽/奇怪/丑陋。 非工作时间不要打扰别人关于工作的事，急事的话也要道歉再三，事后买个咖啡啥的作为补偿。 不是很熟的人，别脏话挂嘴边。 网络词语在日常中使用注意场合，屌丝，黑木耳，土豪啥的听多了闹心。更何况过时的网络词语你还拿来用，比如浮云什么的你现在还用…. 说中文别夹英文或其他外文，千万。除非行业内术语。没事team来，team去的很烦。如果你中文不好，那也是你高级的中文词不会说，而不是低级的中文词不会。delay, team, meeting这种低级词并且对应的中文也很简单的还拿来说啥？ 别人委婉地要拒绝或者面有难色的时候，你要知道在他心里说的是不，所以就别强求了。 不在公共场合吃有刺激味道的东西。不只限于榴莲和臭豆腐，麻辣烫多大味儿你知道不？]]></content>
      <categories>
        <category>心世界</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习计划表]]></title>
    <url>%2F%E5%BF%83%E4%B8%96%E7%95%8C%2F2014%2F11%2F04%2F%E6%96%B0%E4%B8%96%E7%95%8C-2014-11-17-%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[思而不学则罔，学而不思则殆 说明 这里的计划表我已经单独开一个项目请移步这里]]></content>
      <categories>
        <category>心世界</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OpenWrt开发环境搭建(转载)]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2014%2F10%2F31%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2014-10-31-OpenWrt%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[原文在这里 openWRT中文wiki 第一部分：搭建编译环境 1、安装Ubuntu（编译需要Linux环境），到其官网下载，版本根据自己所需选择即可。可以选择安装到虚拟机或者物理机，图形化安装而且是中文版，连安装都搞不定的，可以关闭本页面了； 2、切记不要改动软件源，同时按住Ctrl + Alt + T，调出终端； 3、逐条输入下列命令（及时验证是否安装成功）： 1234567891011121314151617181920sudo apt-get install g++sudo apt-get install libncurses5-devsudo apt-get install zlib1g-devsudo apt-get install bisonsudo apt-get install flexsudo apt-get install unzipsudo apt-get install autoconfsudo apt-get install gawksudo apt-get install makesudo apt-get install gettextsudo apt-get install gccsudo apt-get install binutilssudo apt-get install patchsudo apt-get install bzip2sudo apt-get install libz-devsudo apt-get install asciidocsudo apt-get install subversionsudo apt-get install sphinxsearchsudo apt-get install libtoolsudo apt-get install sphinx-common 至此编译环境搭建完成。 第二部分：下载OpenWrt源码并编译 OpenWrt源码分两种，一种是最新但不是最稳定的Trunk开发版，一种是最稳定的Backfire版，建议下载官方源码。下载前先在本地创建文件夹： 123mkdir openwrtsudo chmod 777 openwrtcd openwrt 选择你想要的版本然后执行下载命令，下载结束会显示版本号： (Barrier Breaker)版下载命令： 1git clone git://git.openwrt.org/14.07/openwrt.git 添加软件扩展包，将feeds.conf.default修改为feeds.conf： 1cp feeds.conf.default feeds.conf 更新扩展，安装扩展： 12./scripts/feeds update -a./scripts/feeds install -a 注：如果不是刚下载的源码，为保持代码为最新状态，应定期运行svn update命令更新源码。 测试编译环境： 12make defconfigmake prereq 到这里就可以开始编译自己的固件了。进入定制界面： 1make menuconfig 如果一切正常，会出现一个配置菜单，可以选择要编译的固件平台（芯片类型）、型号，还能选择固件中要添加的功能和组件，配置好后保存并退出菜单即可。如果你想修改源码，应该在此步进行，如支持大容量Flash之类的修改，自己上网查到修改什么文件什么地方后，就在ubuntu图形界面上进去找到文件，双击打开文本编辑器修改保存。 开始编译： 1make 或者 1make V=99 或者 1make -j V=99 make是编译命令，V=99表示输出debug信息，V一定要大写，如果要让CPU全速编译，就加上 -j 参数，第一次编译最好不带-j参数。 编译过程要保持联网，最好是通过VPN或者代理翻墙，会从网上下载一些源码包，所以断网可能会造成编译中断，编译所需时间与电脑CPU以及网络环境有很大的关系，第一次编译时间较久，编译完成后在源码文件里米拿出现bin文件夹，如果你手里的路由是原版固件需要刷openWRT需要选用xxx-factory.bin固件，如果路由已经刷了openWRT，选用升级固件xxx-sysupdrade.bin升级用，在升级界面升级即可。进到文件夹找到所需固件传出，即可刷机。 第三部分：将OpenWrt刷入路由器要在路由器上使用openWRT，首先要将路由器刷新为openWRT,即向耽于openWRT系统的安装，不同型号的路由器的安装方法可能也会不一样，但一般常用的有三种方法： Web固件上传 PFTP上传固件更新 编程器写入固件 具体型号的路由器适用于哪种或哪几种方法，可自行尝试。 第四部分：开始使用OpenWrt要对OpenWrt进行配置，一般有两条途径： SSH登录通过命令行控制 Web登录通过Web界面设置 首次安装openWRT后，需要设置密码才可以使用SSH登录，方法是使用telnet登录或者WEB登录设置密码，登录时使用: 1ssh root@192.168.1.1 openWRT使用的命令和常见Linux发行版命令相似，包管理器使用的Debian风格的底层包管理器dpkg，常用操作命令: opkg udate //更新软件包列表 opkg install //在线安装软件包 opkg remove //移除软件包 也可以看我的另一篇博客 登录WEB管理界面，前提是该openWRT系统中要安装了WEB界面,一般是Luci,登录方式与普通路由器无异，打开浏览器输入路由器IP即可进入登录界面，openWRT的默认IP是192.168.1.1 到此，OpenWrt的大门已为你敞开。接下来，开始尝试利用OpenWrt实现更多智能应用吧，比如单号多拨榨取运营商带宽、绑定域名远程控制、挂载大容量硬盘、搭建BT下载机、搭建网络摄像头、Samba/DLNA家庭NAS共享、私有云同步、FTP、个人网站/服务器…]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Qt常见皮肤qss代码]]></title>
    <url>%2FQt%E5%AD%A6%E4%B9%A0%2F2014%2F10%2F30%2FQt%E5%AD%A6%E4%B9%A0-2014-10-30-Qt%E5%B8%B8%E8%A7%81%E7%9A%AE%E8%82%A4%E7%9A%84QSS%2F</url>
    <content type="text"><![CDATA[##QTabWidget 淡蓝色效果TabWidget(属性值lightblue) 1234567891011121314151617181920212223242526272829303132QTabWidget[lightblue = "true"] QTabBar::tab&#123; border-top:1px solid rgb(249,249,249); border-top-left-radius: 4px; border-top-right-radius: 4px; max-height:20px; min-height:20px; min-width:95px; font-family:microsoft yahei; color:rgb(50,50,50); font-size:13px; padding:0px 0px 0px 0px; border-image:url(); margin: 0px; padding-bottom:15px;&#125;QTabWidget[lightblue = "true"] QTabBar::tab:selected&#123; border-left:1px solid rgb(192,215,250); border-right:1px solid rgb(192,215,250); border-top:1px solid rgb(192,215,250); color:rgb(50,50,50); background-color:rgb(249,249,249); font-size:13px; border-image:url(); margin: 0px;&#125;QTabWidget[lightblue = "true"]::pane &#123; border-top: 1px solid rgb(192,215,250); position: absolute; top: -1px;&#125; 效果如下图所示： ##QLabel 蓝色标题Label(属性值blueTitle) 12345678QLabel[blueTitle="true"]&#123; font-size:18px; font-family:Microsoft YaHei; color:rgb(255,255,255); background-color:rgb(5 ,112, 183 ); padding-left:25px;&#125; 效果图如下所示： 淡灰色标题Label(属性值lightgrayTitle) 1234567QLabel[lightgrayTitle="true"]&#123; font-family:Microsoft YaHei; font-size:16px; background-color: rgb(207, 207, 207); padding-left: 25px;&#125; 效果图如下所示： ##QPushbutton 蓝色按钮(属性值blueButton) 123456789101112131415QPushButton[blueButton="true"]&#123; color:rgb(255,255,255); border-radius:3px; background-color:rgb(0,109,204); font-family:Arial;&#125;QPushButton[blueButton="true"]:hover&#123; background-color:rgb(0 ,119, 224 );&#125;QPushButton[blueButton="true"]:pressed&#123; background-color:rgb(0 ,149 ,255 );&#125; 效果图如下所示： 蓝框按钮(属性值) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748QPushButton[blueBorderButton = "true"]&#123; border:1px solid; border-color:#afafaf; font-family:microsoft yahei; color:#555555&#125;QPushButton[blueBorderButton = "true"]:hover&#123; border:1px solid; border-color:#11a9d6; font-family:microsoft yahei; color:#555555&#125;QPushButton[blueBorderButton = "true"]:pressed&#123; background-color:#11a9d6; border:1px solid; border-color:#afafaf; font-family:microsoft yahei; color:white&#125;``` 效果图如下所示：* * ![blueButton](/res/img/blog/皮肤模块说明文档的资源文件/blueBorderButton.png) ![blueBorderButton_normal](/res/img/blog/皮肤模块说明文档的资源文件/blueBorderButton_normal.png) ![blueBorderButton_push](/res/img/blog/皮肤模块说明文档的资源文件/blueBorderButton_push.png) ## QProgressBar&gt; * 淡红色进度条```cssQProgressBar[redProgressBar = "true"]&#123; color : solid gray; border: 2px solid gray; border-radius: 5px; background: transparent; padding: 0px; text-align : center ; &#125; QProgressBar[redProgressBar = "true"]::chunk&#123; background: #B22222; &#125;]]></content>
      <categories>
        <category>Qt学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[QT在release版本产生pdb文件]]></title>
    <url>%2FQt%E5%AD%A6%E4%B9%A0%2F2014%2F10%2F30%2FQt%E5%AD%A6%E4%B9%A0-2014-10-30-Qt-msvc%E7%BC%96%E8%AF%91%E5%99%A8%E5%A6%82%E4%BD%95%E5%9C%A8Release%E4%B8%8B%E4%BA%A7%E7%94%9Fpdb%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[##环境说明 QtCreator QtLibrary 编译器 Qt Creator 2.7.0 4.8.4-msvc msvc9.0(VS2008) ##背景说明 &gt;项目中需要对发布版本追踪崩溃问题，我们在项目中利用Qtbreakpoint来产生崩溃文件```*.pdb``` 文件，但是在```Qt```的Release版本下默认是不产生```*.pdb```文件12345678910##如何配置* 方案1 修改编译环境，对所有项目的release都产生```*.pdb```文件,步骤如下： * 1. 找到编译器对应的配置文件，如我的系统安装的是VS2008则我需要找**Qt的安装目录/4.8.4/\mkspecs\win32-msvc2008\qmake.conf** * 2. 增加如下两行配置项到文件并保存 ```sh QMAKE_CFLAGS_RELEASE = -O2 -MD -Zi QMAKE_LFLAGS_RELEASE = /INCREMENTAL:NO /DEBUG 保存后重启Qtcreator或者直接重新新编译 缺陷是编译后的PDB文件不能自己修改名字和拷贝到二进制所在的目录 方案2 修改程序的工程文件 *.pro ，增加如下：* QMAKE_LFLAGS_RELEASE += /MAP QMAKE_CFLAGS_RELEASE += /Zi QMAKE_LFLAGS_RELEASE += /debug /opt:ref 建议使用此种方式]]></content>
      <categories>
        <category>Qt学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[软件加密模块的需求和设计]]></title>
    <url>%2F%E7%A7%81%E4%BA%BA%E5%B7%A5%E5%85%B7%E9%A1%B9%E7%9B%AE%2F2014%2F10%2F30%2FQDaoDaoLiang-2014-10-30-%E8%BD%AF%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%9D%97%E7%9A%84%E6%A6%82%E8%A6%81%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[&gt;本文档为软件加密注册模块简要的设计文档，主要是为了其他人更好的理解本模块的设计思想和实现流程，也为了自己在以后修改过中能够快速熟悉模块的设计,避繁就简,就没再严格按照概要设计模板来编写. 1. 设计文档背景(需求) 该文档的设计是依据如下的需求来进行的设计，主要是为了解决需求中的问题，若是超过该需求的问题，可能该模块就有些不在适宜。 软件只能在一台机器上运行一个实例； 软件的一个分发版本只能在一台机器上运行，拷贝到其他机器是不能运行的； 软件分发出去的版本默认都是演示版本，有功能限制、时间限制、使用次数限制，超过限制条件则提示用户注册使用； 用户注册后可以正常使用软件，但是一个注册码只能使这一个软件在这一台机器上使用； 模块可以在任意Qt开发的软件中简单集成，使其原程序增加软件注册的功能； 用户的注册过程需要用户把软件产生的一个加密后密钥文件发送给软件分发商，软件分发商通过软件注册机来产生对应的注册码然后分发给对应的用户使用; 2. 模块使用场景 3. 模块基础划分 用户信息生成子模块 加解密子模块 UI提示接口子模块 注册码的产生和验证子模块 3.1 模块间关系 3.2 用户信息生成子模块 用户信息生成子模块用来收集用户的信息确保用户的全球唯一性，最终该文件是做为产生注册码的源文件，关于该模块的说明如下： 用户信息子模块最终产生为一个后缀为.userinfo的文件 文件内容需要经过加密子模块进行加密 用户信息主要包括如下内容： 用户网卡MAC 用户CPU信息(CPU个数) 当前时间(距离1970年的秒数) 硬盘硬件序列号 系统版本代号 用户程序ID(全球唯一标识符) 3.3 加解密子模块 负责给予其他模块提供基础的加解密和校验的接口 3.4 UI提示接口子模块&gt;负责给其他模块提供交互界面的接口，用来传递内部信息给用户和接受用户的反馈信息 消息提示框(通知、警告、错误) 3.5 注册码的产生和验证子模块&gt;负责记录用户的唯一标识和用户权限 3.5.1 注册码格式说明 2byte 16byte 16byte 8byte 8byte 2byte 2byte 2byte 用户类型 用户唯一识别码 软件唯一识别码 开始时间 结束时间 使用次数 转换算法代码 完整性校验 用户类型 0x01``` 时间限制型用户12345 * ```0x00 0x02``` 次数限制型用户 * ```0x00 0x03```-```0xff 0xff```保留类型 * **用户唯一识别码** * 原始串 = MAC地址 + 硬盘序列号 + CPU个数 + 系统版本代码 * 原始串进行摘要算法得到16字节的```数字指纹 软件唯一识别码 软件 GUID 16字节 开始时间 Unix时间，距离1970年的秒数 结束时间 Unix时间，距离1970年的秒数 使用次数 无符号短整型 转换算法代码 内部完整性校验前的字节转换算法代号 完整性校验 常规的完整性校验 3.6 校时模块 负责确保时间的相对正确性，时间出现较大偏差时会进行联网纠正，或者离线估算纠正。]]></content>
      <categories>
        <category>私人工具项目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[工具项目之QDaoDaoLiang向导]]></title>
    <url>%2F%E7%A7%81%E4%BA%BA%E5%B7%A5%E5%85%B7%E9%A1%B9%E7%9B%AE%2F2014%2F10%2F29%2FQDaoDaoLiang-2014-10-29-%E5%88%80%E5%88%80%E4%BA%AE%E7%A7%81%E4%BA%BA%E5%B7%A5%E5%85%B7%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[项目引导（QDaoDaoLiang） 平时由于项目需要，需要用到各种非原生Qt有的特性，这些特性有时需要重复劳动，有的可能毫无头绪，所以萌生根据实际需要进行抽象封装从而实现一套实用的组件库。QDaoDaoLiang的由来为本人网名，但愿组件库在发展的过程中会逐渐健壮，逐渐实用，本库遵循MIT开源协议，Enjoy it~ 开发环境构建说明 开发是在Windows下开发的项目 项目使用的DevKit为：Qt4.8.4(MSVC)+ Microsoft Visual C++ Compiler 9.0 + QCreator 2.7.0 文档使用MarkDown语言编写,编辑器使用MdCharm(感谢原作者提供方便的工具) 项目结构说明 项目进度 完成可移动的弹出框基础文件，可用来实现类似QQ新闻的右下角弹出和消失的效果； 完成自定义QLabel,在文字前方4个像素的位置画出红色星号，可用来实现表单的必填项的提示； 完成程序单例的集成； 完成程序崩溃的跟踪两套方案(minidump和基于google的breakpoint的crashdump) 项目开发计划 开发适用于程序注册机制的验证库和注册机 集成ECharts实现JS图表与C++交互的数据展示库 实现对常规样式的控件皮肤封装 嵌入Python进行数据交互，实现Python和C++库转换调用的中间库]]></content>
      <categories>
        <category>私人工具项目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 14.04 搭建Jenkins]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2014%2F10%2F24%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2014-10-24-Ubuntu14-04%E4%B8%8B%E6%90%AD%E5%BB%BAJenkins%2F</url>
    <content type="text"><![CDATA[本教程待本人搭建成功后更新]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[利用github搭建属于自己的博客]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F2014%2F10%2F18%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2014-10-18-%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[##相关知识准备 熟悉基本的Git操作，windows下面掌握Git的图形化操作工具会更加方便，linux下我一直使用的是命令交互的方式如果正在看这篇博文的你有什么好的工具记得推荐我:）。 熟悉基本的MarkDown语法，windows下我推荐MdCharm，linux下我推荐Remarkable,Mac OS(我买不起……)就不推荐了； 熟悉jekyll基本框架原理，只需要知道大体的框架原理即可，能够在以后做定制和集成插件的时候能够得心应手，要是喜欢可以顺便看一看ROR框架蛮不错的； ##搭建步骤 注册一个GitHub账号,不再多说了，注册地址GitHub官网 安装Git,不在详细说过程,windows狂点下一步,linux一条命令搞定,具体细节请查看Git官网 登陆Github账户，创建一个博客空间，这一步其实更简单，只需要在Github上面创建一个名字为YourName.github.io其中YourName为你的GitHub的账号名，所以一个账号只能创建一个博客空间，至此你可以获取该项目到本地了; 创建完毕后你可以在YourName.github.io这个工程里面添加你的网站了,Github默认会在下面寻找index.html页面，你要是感兴趣他的为工作方式请移步Github Pages ; 当然了,如果你是自带光环的WEB前端工程师，你就可以不在看剩下的内容了，请享受你的私人网站吧，我这里要说的是采用第三方的模板Jekyll，没错就是采用别人的模板，什么是模板？请出门左转自行Google或者Baidu，比如说你觉得我这个模板比较中意，那就到我的Github主页，Clone我的博客项目然后本着尊重作者的意图，请一定要删除博主原有的个人配置信息和博文，然后就可以尽情的享受了； 若有任何问题,或者觉得步骤不够详细的可以随时给我发邮件,交流； ##插件集成 该博客的模板最初并非本人原创，在此向原作者致敬,该模板采用jekyll框架，经过简单的个人定制而成，很值得称赞的是为了小白们的方便，里面集成了很多的第三方插件，比如评论系统多说,百度统计功能等等，通过简单地配置文件配置即可完成功能的集成，比如本博客的评论系统就是采用的多说插件，并且也添加了百度统计的功能,如下图: &gt;多说盒子自定义样式如下： 1234567891011121314151617181920212223242526272829303132#ds-thread #ds-reset ul.ds-comments-tabs li.ds-tab a.ds-current &#123;border:0px;color:#848568;text-shadow:none;background:#dddfc2&#125;#ds-thread #ds-reset .ds-highlight &#123;font-family:Arial, Helvetica, sans-serif;font-size:14px;font-weight:bold;color:#848568 !important;&#125;#ds-thread #ds-reset ul.ds-comments-tabs li.ds-tab a.ds-current:hover &#123;color:#696a52;background:#d4d6ba&#125;#ds-thread #ds-reset a.ds-highlight:hover &#123;color:#696a52 !important;&#125;#ds-thread &#123;padding-left:30px;&#125;#ds-thread #ds-reset li.ds-post,#ds-thread #ds-reset #ds-hot-posts &#123;overflow:visible&#125;#ds-thread #ds-reset .ds-post-self &#123;padding:10px 0 10px 10px;&#125;#ds-thread #ds-reset li.ds-post,#ds-thread #ds-reset .ds-post-self &#123;border:0 !important;&#125;#ds-reset .ds-avatar, #ds-thread #ds-reset ul.ds-children .ds-avatar &#123;position:absolute;top:26px;left:-14px;padding:5px;width:36px;height:36px;box-shadow:-1px 0 1px rgba(0,0,0,.15) inset;border-radius:46px; background:#E5E6D0;&#125;#ds-thread #ds-reset ul.ds-children .ds-avatar &#123;left:-23px;&#125;#ds-thread .ds-avatar a &#123;display:inline-block;padding:1px; width:32px;height:32px;border:1px solid #b9baa6;border-radius:50%; background-color:#fff !important&#125;#ds-thread .ds-avatar a:hover &#123;border-color:#de5a4e&#125;#ds-thread .ds-avatar &gt; img &#123;margin:2px 0 0 2px&#125;#ds-thread #ds-reset .ds-replybox &#123;box-shadow:none;&#125;#ds-thread #ds-reset ul.ds-children .ds-replybox.ds-inline-replybox a.ds-avatar,#ds-reset .ds-replybox.ds-inline-replybox a.ds-avatar &#123;left: 0;top: 0; padding: 0;width: 32px !important;height: 32px !important; background: none;box-shadow: none; &#125; #ds-reset .ds-replybox.ds-inline-replybox a.ds-avatar img &#123;width: 32px !important;height: 32px !important; border-radius:50%;&#125; #ds-reset .ds-replybox a.ds-avatar,#ds-reset .ds-replybox .ds-avatar img &#123; padding:0;width:50px !important;height:50px !important; border-radius:5px; &#125;#ds-reset .ds-avatar img &#123;width:32px !important;height:32px !important;border-radius:32px;box-shadow:0 1px 3px rgba(0, 0, 0, 0.22);-webkit-transition:.4s all ease-in-out;-moz-transition:.4s all ease-in-out;-o-transition:.4s all ease-in-out;-ms-transition:.4s all ease-in-out;transition:.4s all ease-in-out;&#125;.ds-post-self:hover .ds-avatar img &#123;-webkit-transform:rotate(360deg);-moz-transform:rotate(360deg);-o-transform:rotate(360deg);-ms-transform:rotate(360deg);transform:rotate(360deg);&#125;#ds-thread #ds-reset .ds-comment-body &#123;background: #F0F0E3;padding:15px 15px 12px 32px;border-radius:5px; box-shadow:0 1px 2px rgba(0,0,0,.15), 0 1px 0 rgba(255,255,255,.75) inset;&#125;#ds-thread #ds-reset .ds-comment-body p&#123;color:#787968&#125;#ds-thread #ds-reset .ds-comments a.ds-user-name &#123;font-weight:bold;color:#696A52 !important;&#125;#ds-thread #ds-reset .ds-comments a.ds-user-name:hover &#123;color:#D32 !important;&#125;#ds-thread #ds-reset #ds-hot-posts &#123;border:0&#125;#ds-reset #ds-hot-posts .ds-gradient-bg &#123;background:none;&#125;#ds-reset #ds-bubble #ds-ctx .ds-ctx-entry &#123;padding:0;&#125;#ds-reset #ds-bubble .ds-avatar, #ds-reset #ds-bubble #ds-ctx-bubble .ds-avatar a &#123;position:static;padding:0;border:0; background:none;box-shadow:none;&#125;#ds-reset #ds-bubble .ds-avatar img, #ds-reset #ds-bubble #ds-ctx-bubble .ds-avatar a &#123;width:45px !important;height:45px !important;&#125;#ds-reset #ds-bubble .ds-user-name&#123;padding-left:13px;&#125;]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[你好世界]]></title>
    <url>%2F%E5%BF%83%E4%B8%96%E7%95%8C%2F2014%2F10%2F18%2F%E6%96%B0%E4%B8%96%E7%95%8C-2014-10-18-%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C%2F</url>
    <content type="text"><![CDATA[你好世界,这是N久之后我终于在开开停停N多博客之后打算在这里开启我的博客之旅,无它,唯记录我的人生以供将来的我自省. 1print(&quot;Hello World!&quot;);]]></content>
      <categories>
        <category>心世界</category>
      </categories>
  </entry>
</search>